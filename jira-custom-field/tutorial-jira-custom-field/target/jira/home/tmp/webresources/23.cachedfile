;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/orderby.soy' */
// This file was automatically generated from orderby.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.OrderBy.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.OrderBy == 'undefined') { JIRA.Templates.OrderBy = {}; }


JIRA.Templates.OrderBy.orderBy = function(opt_data, opt_ignored) {
  return ((opt_data.sortBy && opt_data.sortBy.fieldId) ? '<a class="order-by ' + ((opt_data.sortBy.order == 'ASC') ? 'ascending' : 'descending') + '" data-field-id="' + soy.$$escapeHtml(opt_data.sortBy.fieldId) + '" data-direction="' + soy.$$escapeHtml(opt_data.sortBy.order) + '" href="#" title="' + soy.$$escapeHtml(AJS.format("Order by {0}",opt_data.sortBy.fieldName)) + '"><span>' + soy.$$escapeHtml(AJS.format("Order by {0}",opt_data.sortBy.fieldName)) + '</span><span class="aui-icon aui-icon-small aui-iconfont-' + ((opt_data.sortBy.order == 'ASC') ? 'up' : 'down') + '"></span></a>' : '<a class="order-by" title="' + soy.$$escapeHtml("Order by") + '"><span>' + soy.$$escapeHtml("Order by") + '</span></a>') + '<a class="order-options" title="' + soy.$$escapeHtml("Select the field that issues are ordered by.") + '">' + soy.$$escapeHtml("Select the field that issues are ordered by.") + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.OrderBy.orderBy.soyTemplateName = 'JIRA.Templates.OrderBy.orderBy';
}


JIRA.Templates.OrderBy.orderByOptions = function(opt_data, opt_ignored) {
  var output = '<select id="order-by-options" multiple="multiple" class="hidden"><optgroup data-footer-text="' + soy.$$escapeHtml(opt_data.footer) + '">';
  var optionList41 = opt_data.options;
  var optionListLen41 = optionList41.length;
  for (var optionIndex41 = 0; optionIndex41 < optionListLen41; optionIndex41++) {
    var optionData41 = optionList41[optionIndex41];
    output += '<option title="' + soy.$$escapeHtml(optionData41.fieldName) + '" value="' + soy.$$escapeHtml(optionData41.fieldId) + '" data-meta="' + soy.$$escapeHtml(optionData41.meta) + '">' + soy.$$escapeHtml(optionData41.fieldName) + '</option>';
  }
  output += '</optgroup></select>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.OrderBy.orderByOptions.soyTemplateName = 'JIRA.Templates.OrderBy.orderByOptions';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByModel.js' */
define("jira/components/orderby/orderbymodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var contextPath = AJS.contextPath();

    /**
     * Model for order by dropdown & toggle
     *
     * @type JIRA.Issues.OrderByModel
     */
    return Brace.Model.extend({

        namedEvents: ["sort"],
        namedAttributes: ["sortBy", "jql"],

        initialize: function() {
            this.on("change:jql", this.updateSelectedSort, this);
        },

        /**
         * Whenever we change jql get the data we need to display the description of the order (the ASC/DEC toggle)
         */
        updateSelectedSort: function() {
            jQuery.ajax({
                type: "POST",
                url: contextPath + "/rest/orderbycomponent/latest/orderByOptions/primary",
                data: JSON.stringify({jql: this.getJql()}),
                contentType: 'application/json',
                success: _.bind(function(res) {
                    this.setSortBy(res);
                }, this)
            });
        },

        /**
         * Toggles sort jql between DESC/ASC
         */
        toggleSort: function() {
            this.setJql(this.getSortBy().toggleJql);
            this.triggerSort(this.getJql());
        },

        /**
         * Sets updated jql and publishes event
         * @param jql
         */
        doSort: function(jql) {
            this.setJql(jql);
            this.triggerSort(this.getJql());
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByView.js' */
define("jira/components/orderby/orderbyview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var Events = require("jira/util/events");
    var OrderByEventTypes = require("jira/components/orderby/eventtypes");
    var OrderByTemplates = require("jira/components/orderby/templates");
    var OrderByDropDownView = require("jira/components/orderby/orderbydropdownview");

    /**
     * The order by view that's shown over the list of issues in split view.
     *
     * @type JIRA.Issues.OrderByView
     */
    return Brace.View.extend({

        template: OrderByTemplates.orderBy,

        events: {
            "click a.order-by": "_onClickOrderBy",
            "click a.order-options": "_toggleShowDropDown"
        },

        initialize: function() {
            // Whenever the sort jql changes then we re-render
            this.model.on("change:sortBy", this.render, this);
        },

        /**
         * Renders this view base on the SearchResults' 'sortBy' property.
         *
         * @return {JIRA.Issues.OrderByView}
         */
        render: function() {
            this.$el.html(this.template(this.model.toJSON()));
            return this;
        },

        deactivate: function() {
            // make sure we cleanup events when we switch to list view
            if (this.orderByDropDown) {
                this.orderByDropDown.deactivate();
            }
            this.undelegateEvents();
        },

        /**
         * Toggles sort between ASC/DESC
         * @param e
         */
        _onClickOrderBy: function(e) {
            var event = new jQuery.Event(OrderByEventTypes.ISSUE_TABLE_REORDER);
            Events.trigger(event);
            if (!event.isDefaultPrevented()) {
                var fieldId = jQuery(e.currentTarget).data('field-id');
                if (fieldId) {
                    this.model.toggleSort();
                }
            }
            e.preventDefault();
        },
        /**
         * Hiding/Showing of sparkler
         */
        _toggleShowDropDown: function(e) {
            if (!this.orderByDropDown) {
                // lazy create
                this.orderByDropDown = new OrderByDropDownView({
                    model: this.model,
                    offsetTarget: this.$('a.order-by'),
                    onHideCallback: _.bind(function() {
                        this.orderByDropDown = null;
                    }, this)
                });
            }
            this.orderByDropDown.toggle();
            e.preventDefault();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderByDropDownView.js' */
define("jira/components/orderby/orderbydropdownview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");
    var Events = require("jira/util/events");
    var OrderByEventTypes = require("jira/components/orderby/eventtypes");
    var OrderByTemplates = require("jira/components/orderby/templates");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var SelectSuggestHandler = require('jira/ajs/select/suggestions/select-suggest-handler');
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var BaseView = require("jira/issues/baseview");
    var Tipsy = require("jira/issues/tipsy");
    var contextPath = AJS.contextPath();

    /**
     * A pop-up where we display the new sort options.
     *
     * @type {JIRA.Issues.OrderByDropDownView}
     */
    return Brace.View.extend({
        /**
         * Creates a new OrderByDropDownView.
         *
         * @param {object} options
         * @param {JIRA.Issues.SearchModule} options.search the SearchModule
         * @param {Element} options.offsetTarget the element that the drop-down will be positioned under
         */
        initialize: function(options) {
            _.bindAll(this, '_onDropdownHidden', '_onDropdownShown');
            this.offsetTarget = options.offsetTarget;
            this._onHideCallback = options.onHideCallback;
            this._pending = null;
            this._inlineLayer = null;
        },

        /**
         * Hides this OrderByDropDownView and cancels any pending AJAX requests.
         */
        deactivate: function() {
            if (this._inlineLayer) {
                this._inlineLayer.hide();
            }
            BaseView.prototype.deactivate.apply(this, arguments);
        },

        /**
         * Toggles the visibility of this OrderByDropDownView, cancelling any pending AJAX requests when appropriate.
         */
        toggle: function() {
            // depending on whether the InlineLayer is visible or not we either
            // cancel pending requests or kick off new ones.
            if (!this._inlineLayer) {
                this._pending = jQuery.ajax(this._ajaxDefaults());
                this._inlineLayer = this._createInlineLayer(this._pending);
                this._inlineLayer.bind(InlineLayer.EVENTS.show, this._onDropdownShown);
                this._inlineLayer.bind(InlineLayer.EVENTS.hide, this._onDropdownHidden);
                this._inlineLayer.show();
            } else {
                this._inlineLayer.hide();
            }
        },

        /**
         * Creates the drop-down InlineLayer with the single select inside of it.
         *
         * @param deferred
         * @return {InlineLayer}
         * @private
         */
        _createInlineLayer: function(deferred) {
            var renderSelectAndAddTipsy = _.bind(function(data) {
                this._deferredAddTipsyToFooter(data);
                return this._renderInitialContent(data);
            }, this);

            var inlineLayer = new InlineLayer({
                offsetTarget: this.offsetTarget,
                content: function() {
                    return deferred.pipe(renderSelectAndAddTipsy);
                },
                width: 218
            });

            if (this._onHideCallback) {
                inlineLayer.bind(InlineLayer.EVENTS.hide, this._onHideCallback);
            }

            return inlineLayer;
        },

        /**
         * Enhances the order by single select to use a sparkler instead of a plain old HTML select list.
         *
         * @param {InlineLayer} layer the layer that contains the select
         * @private
         */
        _initSingleSelect: function(layer) {
            var orderBySelect = layer.find('select');

            // we are using a sparkler as if it were a single select here. to do this we
            // programatically hide the sparkler whenever the user clicks one of the options.
            orderBySelect.bind("selected", _.bind(this._onFieldSelected, this));

            this.selectControl = new CheckboxMultiSelect({
                element: orderBySelect,
                itemAttrDisplayed: "label",
                suggestionsHandler: SelectSuggestHandler,
                ajaxOptions: this._ajaxDefaults({
                    data: _.bind(function(query) {
                        return JSON.stringify(this._ajaxOptionsData(query));
                    }, this),
                    query: true, // keep going back to the sever for each keystroke
                    minQueryLength: 0,
                    formatResponse: _.bind(function(response) {
                        this._removeTipsy();

                        var sortFields = new GroupDescriptor();

                        // add each returned field
                        _.each(response.fields, function(option) {
                            sortFields.addItem(new ItemDescriptor({
                                title: option.fieldName,
                                value: option.fieldId,
                                label: option.fieldName,
                                meta: {sortJql: option.sortJql}
                            }));
                        });

                        // add a footer showing how many more fields there are
                        var footerText = this._getFooterText(response);
                        if (footerText) {
                            sortFields.footerText(footerText);
                            this._deferredAddTipsyToFooter(response);
                        }

                        // we only have 1 group
                        return [sortFields];
                    }, this)
                })
            });

            // focus the 'Search' area in the multi-select after rendering it
            var orderByInput = layer.find('#order-by-options-input');
            orderByInput.focus();
        },

        /**
         * Returns the default AJAX options for requesting suggestions.
         *
         * @param {object} ajaxOpts additional options that override the defaults
         */
        _ajaxDefaults: function(ajaxOpts) {

            var defaults = {
                url: contextPath + "/rest/orderbycomponent/latest/orderByOptions",
                type: "POST",
                contentType: 'application/json',
                data: JSON.stringify(this._ajaxOptionsData())
            };

            return _.extend(defaults, ajaxOpts);
        },

        /**
         * Returns the additional data to send back in the options request.
         *
         * @param {string} query the query
         * @return {Object} data to send
         * @private
         */
        _ajaxOptionsData: function(query) {
            var jql = this.model.getJql();
            var sortBy = this.model.getSortBy();
            return {
                query: query,
                jql: jql ? jql : undefined,
                sortBy: sortBy ? sortBy.fieldId : undefined
            };
        },

        /**
         * Renders the initial content for the InlineLayer.
         *
         * @param orderByOptions the options returned from the server
         * @return {jQuery} a div with the initial content
         * @private
         */
        _renderInitialContent: function(orderByOptions) {
            // the 'meta' needs to be stringified for inclusion in the select
            var optionsWithMeta = _.map(orderByOptions.fields, function(field) {
                return _.extend({}, field, {
                    meta: JSON.stringify({sortJql: field.sortJql})
                });
            });

            return jQuery('<div></div>')
                .addClass('order-dropdown')
                .html(OrderByTemplates.orderByOptions({
                    options: optionsWithMeta,
                    footer: this._getFooterText(orderByOptions)
                }));
        },

        /**
         * Initialises the single select control after the data has been inserted into the DOM.
         *
         * @param e
         * @param layer
         * @param id
         *
         * @private
         */
        _onDropdownShown: function(e, layer) {
            this._initSingleSelect(layer);
        },

        /**
         * Cleans up after the drop-down when it gets hidden. This includes removing the drop-down from the DOM.
         *
         * @param e
         * @param {InlineLayer} layer the layer
         * @param id
         * @private
         */
        _onDropdownHidden: function() {
            this._removeTipsy();

            // remove element
            jQuery('div.order-dropdown').remove();
            this._inlineLayer = null;
        },

        /**
         * Hides the drop-down and sorts by the selected field
         */
        _onFieldSelected: function(e, descriptor) {
            // frother made me do this. it seems we can't just hide the InlineLayer because it is still trying to do things
            // *after* this callback has run and will fail if we've hidden it. so we defer.
            var event = new jQuery.Event(OrderByEventTypes.ISSUE_TABLE_REORDER);
            Events.trigger(event);
            if (!event.isDefaultPrevented()) {
                _.defer(_.bind(function() {
                    // handling for bug in QueryableDropdownSelect - it incorrectly fires a request on enter key.
                    if (this.selectControl.outstandingRequest) {
                        this.selectControl.outstandingRequest.reject();
                    }
                    InlineLayer.current.hide();
                    // sort using the provided sort JQL
                    var meta = descriptor.meta();
                    this.model.doSort(meta.sortJql);
                }, this));
            }
        },

        /**
         * Returns the footer string to render in the dropdown, or undefined. If there are more fields to show than were
         * returned, the footer will read along the lines of "23 more fields not shown".
         *
         * @param {object} orderByOptions
         * @param {number} orderByOptions.maxResults the maximum number of returned fields
         * @param {number} orderByOptions.matchesCount the number of matched fields
         * @return {string}
         * @private
         */
        _getFooterText: function(orderByOptions) {
            if (typeof orderByOptions.matchesCount === 'number' && typeof orderByOptions.maxResults === 'number') {
                var notShown = orderByOptions.matchesCount - orderByOptions.maxResults;
                if (notShown > 0) {
                    return AJS.format("{0} more fields...", notShown);
                }
            }

            return "";
        },

        /**
         * Adds a tipsy to the footer telling users how to find fields that are not in the list. The actual adding of the
         * tipsy is deferred.
         *
         * @param {object} orderByOptions
         * @param {number} orderByOptions.maxResults the maximum number of returned fields
         * @param {number} orderByOptions.matchesCount the number of matched fields
         * @return {*}
         * @private
         */
        _deferredAddTipsyToFooter: function(orderByOptions) {
            if (this._inlineLayer) {
                var matched = orderByOptions.matchesCount;
                var shown = Math.min(orderByOptions.matchesCount, orderByOptions.maxResults);
                var tipsyText = AJS.format("Showing {0} of {1} matching fields. Find more fields by typing in the search box.", shown, matched);

                var instance = this;
                _.defer(function() {
                    instance._tipsyTrigger = new Tipsy({
                        el: instance._inlineLayer.$layer.find('.aui-list-section-footer'),
                        tipsy: {
                            title: function() {
                                return tipsyText;
                            },
                            className: "tipsy-front"
                        }
                    });
                });
            }
        },

        /**
         * Removes the footer tipsy.
         *
         * @return {*}
         * @private
         */
        _removeTipsy: function() {
            if (this._tipsyTrigger) {
                this._tipsyTrigger.hide();
                this._tipsyTrigger = null;
            }
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/OrderBy.js' */
define("jira/components/orderby", ["require"], function(require) {
    "use strict";

    var OrderByView = require("jira/components/orderby/orderbyview");
    var OrderByModel = require("jira/components/orderby/orderbymodel");

    return {

        create: function(options) {

            var model;
            var view;

            options = options || {};

            model = new OrderByModel({
                sortBy: options.sortBy,
                jql: options.jql
            });
            view = new OrderByView({model: model});

            // publish public api
            return {
                onSort: function() {
                    model.onSort.apply(model, arguments);
                    return this;
                },
                offSort: function(method) {
                    model.off("sort", method);
                    return this;
                },
                render: function() {
                    view.render();
                    return this;
                },
                setElement: function(el) {
                    view.setElement(el);
                    return this;
                },
                setJql: function(jql) {
                    model.setJql(jql);
                    return this;
                },
                setSortBy: function(options) {
                    model.setSortBy(options);
                    return this;
                }
            };
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/eventtypes.js' */
define("jira/components/orderby/eventtypes", [], function(){
    "use strict";

    return {
        ISSUE_TABLE_REORDER: "issueTableReorder"
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/orderby/templates", function() {
    "use strict";

    return JIRA.Templates.OrderBy;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../js/namespace.js)
 */
AJS.namespace("JIRA.Templates.OrderBy", null, require("jira/components/orderby/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:orderby', location = 'orderby/namespace.js' */
AJS.namespace("JIRA.Components.OrderBy", null, require("jira/components/orderby"));
AJS.namespace("JIRA.Issues.OrderByDropDownView", null, require("jira/components/orderby/orderbydropdownview"));
AJS.namespace("JIRA.Issues.OrderByView", null, require("jira/components/orderby/orderbyview"));
AJS.namespace("JIRA.Issues.OrderByModel", null, require("jira/components/orderby/orderbymodel"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPicker.soy' */
// This file was automatically generated from ColumnPicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Dialogs.ColumnPicker.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Dialogs == 'undefined') { JIRA.Templates.Dialogs = {}; }
if (typeof JIRA.Templates.Dialogs.ColumnPicker == 'undefined') { JIRA.Templates.Dialogs.ColumnPicker = {}; }


JIRA.Templates.Dialogs.ColumnPicker.popup = function(opt_data, opt_ignored) {
  var output = '<div><form action="#" method="post"  class="aui top-label column-picker"><div class="check-list-top-panel"><h3>' + soy.$$escapeHtml("Columns") + '</h3>';
  if (opt_data.columns.length > 1) {
    output += '<p class="aui-buttons">';
    var columnList9 = opt_data.columns;
    var columnListLen9 = columnList9.length;
    for (var columnIndex9 = 0; columnIndex9 < columnListLen9; columnIndex9++) {
      var columnData9 = columnList9[columnIndex9];
      output += '<button type="button" class="config-chooser aui-button ' + ((columnData9.isActive) ? ' active' : '') + '" id="columns-chooser-' + soy.$$escapeHtml(columnData9.name) + '" data-value="' + soy.$$escapeHtml(columnData9.name) + '"' + ((columnData9.isDisabled) ? 'aria-disabled="true"' : '') + '>' + soy.$$escapeHtml(columnData9.description) + '</button>';
    }
    output += '</p>';
  }
  output += '</div>';
  var columnList28 = opt_data.columns;
  var columnListLen28 = columnList28.length;
  for (var columnIndex28 = 0; columnIndex28 < columnListLen28; columnIndex28++) {
    var columnData28 = columnList28[columnIndex28];
    output += '<div class="' + soy.$$escapeHtml(columnData28.name) + '-column-sparkler hidden"></div>';
  }
  output += ((! opt_data.isAutoUpdate) ? '<div class="button-panel"><input accesskey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtml("Done") + '"/> <a accesskey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link close-dialog" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div>' : '') + '</form></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.popup.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.popup';
}


JIRA.Templates.Dialogs.ColumnPicker.trigger = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-subtle column-picker-trigger" title="' + soy.$$escapeHtml("Columns") + '">' + soy.$$escapeHtml("Columns") + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.trigger.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.trigger';
}


JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink = function(opt_data, opt_ignored) {
  return '<button class="aui-button aui-button-link restore-defaults">' + soy.$$escapeHtml(opt_data.linkText) + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink.soyTemplateName = 'JIRA.Templates.Dialogs.ColumnPicker.restoreDefaultsLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerModel.js' */
define("jira/components/columnpicker/model", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var contextPath = window.AJS.contextPath();
    var jQuery = require("jquery");

    return Brace.Model.extend({

        namedAttributes: [
        /** The source of the column configuration, e.g. "user", "filter", "explicit" */
            "columnConfig",
            "savedColumnConfig",
            "search",
            "availableColumns",
            "autoUpdate"
        ],

        namedEvents: [
            "columnsSync",
            "changeColumnConfigDisabled",
            "destroyColumnConfig"
        ],

        allColumnsUrl: contextPath + '/rest/gadget/1.0/availableColumns',

        shouldRefreshSearchOnActivation: function() {
            return this.getCurrentColumnConfig().shouldRefreshSearchOnActivation();
        },

        shouldCloseOnActivation: function() {
            return this.getCurrentColumnConfig().shouldCloseOnActivation();
        },

        shouldLoadDefaultsOnActivation: function() {
            return this.getCurrentColumnConfig().shouldLoadDefaultsOnActivation();
        },

        shouldRevertOnHide: function() {
            return this.getCurrentColumnConfig().shouldRevertOnHide();
        },

        loadDefaultColumns: function() {
            this.getCurrentColumnConfig().loadDefaultColumns();
        },

        initialize: function() {
            this.columnsData = {};
        },

        refreshSearchWithColumns: function(columnConfigModel) {
            columnConfigModel = columnConfigModel || this.getCurrentColumnConfig();
            this.triggerColumnsSync(columnConfigModel.getName(), columnConfigModel.getColumns());
        },

        fetchAvailableColumnsIfNeeded: function() {
            if (!this.has("availableColumns")) {
                jQuery.ajax(this.allColumnsUrl).done(_.bind(function(response) {
                    this.setAvailableColumns(response.availableColumns);
                }, this));
            }
        },

        getCurrentColumnConfig: function(name) {
            if (!name) {
                name = this.getColumnConfig();
            }
            return this.columnsData[name];
        },

        revertColumnConfig: function() {
            if (this.shouldRevertOnHide() && this.getSavedColumnConfig() !== this.getColumnConfig()) {
                //HACK
                //BackboneJS does not update the 'previousAttributes' if the change is silent. That means
                //the next time we change columnConfig (non-silent change), we will get the wrong value.
                //See https://extranet.atlassian.com/x/Cwq_fw
                this._previousAttributes.columnConfig = this.getSavedColumnConfig();
                this.setColumnConfig(this.getSavedColumnConfig(), {silent: true});
            }
        },

        setCurrentColumnConfig: function(columnConfig) {
            this.setColumnConfig(columnConfig);
            this.setSavedColumnConfig(columnConfig);
        },

        syncColumns: function(newColumnConfigName, columns) {
            _.each(this.columnsData, function(columnConfigModel) {
                if (columnConfigModel.getName() === newColumnConfigName) {
                    columnConfigModel.setColumns(columns);
                    columnConfigModel.setSavedColumns(columns);
                }
            });
        },

        /**
         * Save a list of columns in the current ColumnConfig.
         *
         * This method will save the list of columns in the provided order. In other words,
         * the previous order is deleted.
         *
         * @param {Array.string} cols Columns to save
         */
        saveColumns: function(cols) {
            this.getCurrentColumnConfig().setColumns(cols);
            this.getCurrentColumnConfig().save();
            this.getCurrentColumnConfig().triggerColumnsSync();
        },

        addColumnProvider: function(id, provider) {
            this.columnsData[id] = provider;

            provider.on("columnsSync sync destroy", _.bind(function() {
                this.refreshSearchWithColumns(provider);
            }, this));

            provider.on("change:isDisabled", _.bind(function(model, isDisabled) {
                this.triggerChangeColumnConfigDisabled(model, isDisabled);
            }, this));

            provider.on("destroy", _.bind(function(model) {
                this.triggerDestroyColumnConfig(model);
            }, this));
        }
    });

});
AJS.namespace("JIRA.Issues.ColumnPickerModel", null, require("jira/components/columnpicker/model"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnConfigModel.js' */
define("jira/components/columnpicker/columnconfigmodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var jQuery = require("jquery");

    var ColumnConfigModel = Brace.Model.extend({

        namedAttributes: [
            "name",
            "columns",
            "autoUpdate",
            "savedColumns",
            "description",
            "previousColumns",
            "actionBarText",
            "isActive"
        ],

        namedEvents: [
            "columnsSync"
        ],

        defaults: {
            actionBarText: "Restore Defaults",
            isActive: false
        },

        idAttribute: "name",

        initialize: function(attributes, options) {
            _.extend(this, options);
        },

        /**
         * Get the defaults columns, parsing the response from defaultColumns().
         * The promise can be resolved with the list of columns (Array.string) or
         * rejected with a null value
         *
         * @returns {jQuery.Promise}
         */
        getDefaultColumns: function() {
            var deferred = new jQuery.Deferred();

            this.defaultColumns().done(_.bind(function(response) {
                var parsedResponse = this.parse(response);
                if (parsedResponse && parsedResponse.columns) {
                    deferred.resolve(parsedResponse.columns);
                } else {
                    deferred.reject(null);
                }
            }, this));

            return deferred.promise();
        },

        /**
         * Parses the REST response to extract our model values.
         *
         * @param {Object} response REST response
         */
        parse: function(response) {
            if (!response) {
                return {};
            }

            return {
                columns: _.compact(_.pluck(response, "value"))
            };
        },

        /**
         * Checks if the column config is disabled.
         *
         * For example, "filter" column config is disabled if there is no active filter.
         *
         * By default, this method returns false (i.e. all column config are enabled). It can be
         * overridden when creating this model
         *
         * @returns {boolean}
         */
        isDisabled: function() {
            return false;
        },

        /**
         * Checks if the column config edition is disabled.
         *
         * For example, "filter" column config edition is disabled if the user does not own the filter.
         *
         * By default, this method returns false (i.e. all column config edit are enabled). It can be
         * overridden when creating this model
         *
         * @returns {boolean}
         */
        isEditDisabled: function() {
            return false;
        },

        /**
         * Returns a promise that will resolve with a list of defaults columns.
         *
         * This method will be used if the columnConfig contains no columns. By default,
         * the returned promise resolves immediately to an empty array.
         *
         * This method can be overridden when constructing this model
         *
         * @returns {jQuery.Promise}
         */
        defaultColumns: function() {
            var deferred = new jQuery.Deferred();
            deferred.resolve([]);
            return deferred.promise();
        },

        /**
         * Sorts a list of columns preserving the original order, using the following pattern:
         *    - Columns already present will keep their order
         *    - New columns will be append at the end
         *
         * Example:
         *    - Current columns ["a", "b", "c"]
         *    - New columns ["c", "d", "a"]
         *
         *    - Result ["a", "c", "d"]
         *
         * @param {Array.string} currentColumns Columns already present in the model
         * @param {Array.string} newColumns New columns to sort
         * @returns {Array.string} Sorted columns
         * @private
         */
        _sortColumnsUsingOriginalOrder: function(currentColumns, newColumns) {
            return _.intersection(currentColumns, newColumns).concat(_.difference(newColumns, currentColumns));
        },

        /**
         * Sets an unsorted list of columns in the model.
         *
         * This method will store the new list of columns, preserving the order of the previous column list.
         *
         * @param {Array.<string>} columns Columns to update the model with
         */
        setUnsortedColumns: function(columns) {
            columns = this._sortColumnsUsingOriginalOrder(this.getColumns(), columns);
            //TODO Check if this can be moved to backbone's previous() functionality
            this.setPreviousColumns(this.getColumns(), {silent: true});
            this.setColumns(columns);
        },

        /**
         * Creates a JSON representation for this model.
         *
         * This method will be used by Backbone when saving a model. We don't want to save the entire model, just
         * the columns, so the output only contains that attribute.
         *
         * @returns {{columns: Array.<string>}}
         */
        toJSON: function() {
            return {
                columns: this.getColumns()
            };
        },

        revertUnsavedColumns: function(opts) {
            if (this.getSavedColumns() !== this.getColumns()) {
                this.setColumns(this.getSavedColumns(), opts);
            }
        },

        loadDefaultColumns: function() {
            this.getDefaultColumns().done(_.bind(function(columns) {
                this.setColumns(columns);
            }, this));
        },

        shouldRefreshSearchOnActivation: function() {
            return true;
        },

        shouldCloseOnActivation: function() {
            return true;
        },

        shouldLoadDefaultsOnActivation: function() {
            return false;
        },

        shouldRevertOnHide: function() {
            return true;
        }
    });

    ColumnConfigModel.create = function(name, description, overriddenMethods, autoUpdate) {
        return new ColumnConfigModel({
            autoUpdate: autoUpdate,
            name: name,
            description: description
        }, overriddenMethods);
    };

    return ColumnConfigModel;
});
AJS.namespace("JIRA.Issues.ColumnConfigModel", null, require("jira/components/columnpicker/columnconfigmodel"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerSuggestHandler.js' */
define("jira/components/columnpicker/suggesthandler", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var jQuery = require("jquery");
    var SelectSuggestHandler = require('jira/ajs/select/suggestions/select-suggest-handler');
    var SuggestHandler = require("jira/ajs/select/suggestions/suggest-helper");
    var Templates = window.JIRA.Templates.Dialogs.ColumnPicker;

    return SelectSuggestHandler.extend({

        /**
         * Creates a actionBar item that contains a link. This link is usually used
         * to restore the defaults items in the sparkler
         *
         * @param {string} [text] Text to render inside the link
         *
         * @return {jQuery} LI element that contains the link
         */
        createActionBar: function(text) {
            //If there are no text, create nothing
            if (!text) {
                return null;
            }

            var $element = jQuery(Templates.restoreDefaultsLink({
                linkText: text
            }));

            $element.click(function(ev) {
                if (jQuery(ev.target).attr("aria-disabled") !== "true") {
                    $element.trigger("actionclick");
                }
                ev.preventDefault();
            });

            return jQuery("<li class='check-list-group-actions'></li>").append($element);
        },

        /**
         * Formats descriptors for display in checkbox multiselect
         *
         * @param descriptors
         * @return {Array} formatted descriptors
         */
        formatSuggestions: function(descriptors, query) {
            var selectedItems = SuggestHandler.removeDuplicates(this.model.getDisplayableSelectedDescriptors());
            var selectedGroup = new GroupDescriptor({
                styleClass: "selected-group",
                items: selectedItems
            });
            descriptors.splice(0, 0, selectedGroup);

            //Add the actionBar to the first group with items, so it is rendered as the first item in the scroll list
            //If there are selected elements, it will be the selectedItems group
            //If not, it will be the uneslectedItems group.
            var firstGroupWithItems = _.find(descriptors, function(group) {
                return group.items().length;
            });
            if (firstGroupWithItems) {
                firstGroupWithItems.actionBarHtml(this.createActionBar(this.options.actionBar));
            }

            if (query.length > 0) {
                descriptors = SuggestHandler.removeDuplicates(descriptors);
                // Extract all items from the descriptors and sort them by label.
                var items = SuggestHandler.extractItems(descriptors).sort(function(a, b) {
                    a = a.label().toLowerCase();
                    b = b.label().toLowerCase();
                    return a.localeCompare(b);
                });
                descriptors = [new GroupDescriptor({items: items})];
            }
            return descriptors;
        }
    });

});
AJS.namespace("JIRA.Issues.ColumnPickerSuggestHandler", null, require("jira/components/columnpicker/suggesthandler"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerSparklerView.js' */
define("jira/components/columnpicker/sparklerview", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var AJSTemplates = window.AJS.Templates;
    var Brace = require("jira/components/libs/brace");
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var ColumnPickerSuggestHandler = require("jira/components/columnpicker/suggesthandler");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var Message = require("aui/message");
    var jQuery = require("jquery");

    return Brace.View.extend(/* @lends JIRA.Issues.ColumnPickerSparklerView.prototype */{

        /**
         * This object wraps a Sparkler. It is used by the ColumnPicker to render sparklers for select columns
         * (it will render one sparkler per column layout).
         *
         * @constructs
         * @param {Object} config Configuration object for this object
         * @param {jQuery} config.el Element where the sparkler should be rendered
         * @param {ColumnConfigModel} config.model Model used for this view
         * @param {number} [config.maxResults=25] Max number of items to display
         */
        initialize: function(config) {
            //Don't use || to get the default value, it will fail with 0
            this._maxResults = (typeof config.maxResults === "number") ? config.maxResults : this.MAX_DISPLAYED_ITEMS;
            this._autoUpdate = !!config.autoUpdate;
            this.$el.scrollLock('.aui-list-scroll');
            if (!this._autoUpdate) {
                this.model.on("change:columns", _.bind(this._setSelectedColumns, this));
            }
        },

        /**
         * Default for max displayed columns
         * @type {Number}
         * @default
         * @private
         * @constant
         */
        MAX_DISPLAYED_ITEMS: 25,

        /**
         * Stores the actual AJS.CheckboxMultiSelect object that represents the sparkler
         * @type {AJS.CheckboxMultiSelect}
         * @private
         */
        _sparkler: null,

        activate: function() {
            this.model.setIsActive(true);
        },

        deactivate: function() {
            this.model.setIsActive(false);
        },

        /**
         * Hides the sparkler
         */
        hide: function() {
            this.model.revertUnsavedColumns({silent: true});

            this.$el.addClass("hidden");

            //Clear the sparkler search field
            var input = this.$el.find("input[id *= column-sparkler-input]");
            input.val('');
        },

        /**
         * Shows the sparkler
         */
        show: function() {
            this.$el.removeClass("hidden");

            //Set the selected columns
            this._setSelectedColumns();

            //Focus the sparkler input
            var input = this.$el.find("input[id *= column-sparkler-input]");
            if (!input.is(":disabled")) {
                input.focus();
            }
        },

        addMessage: function(message) {
            if (this.$el.find(".aui-message." + message.type).length === 0) {
                Message[message.type](this.$el, {
                    body: message.content,
                    closeable: false,
                    insert: "prepend",
                    id: message.id
                });
            }
        },

        /**
         * Disables the sparkler whenever the edit is disabled in the model
         *
         * @private
         */
        _disableEditIfNeeded: function() {
            if (this.model.isEditDisabled()) {
                this._disableEdit();
            } else {
                this._enableEdit();
            }
        },

        /**
         * Shows the EditDisabled message
         *
         * @private
         */
        _showEditDisabledMessage: function() {
            this.addMessage({
                content: "You cannot update the columns for a filter owned by another user.",
                type: "warning",
                id: this.model.getName() + '-edit-disabled-message'
            });
        },

        /**
         * Destroys the EditDisabled message
         *
         * @private
         */
        _hideEditDisabledMessage: function() {
            this.$el.find("#" + this.model.getName() + '-edit-disabled-message').remove();
        },

        /**
         * Disables the sparkler interactions.
         *
         * This method is used when the user does not have permission to change the columns.
         *
         * @private
         */
        _disableEdit: function() {
            //Disable the search input
            this._sparkler.disable();

            //Disable the checkboxes
            this.$el.find("input[type='checkbox']").attr("disabled", "disabled");  //Disable checkboxes
            this.$el.find(".check-list-item").addClass("disabled");                //Disable labels
            this.$el.find(".no-suggestions").addClass("disabled");                 //Disable "more" message

            //Disable the action bar
            this.$el.find(".restore-defaults").attr("aria-disabled", "true");

            //Show reason to user
            this._showEditDisabledMessage();
        },

        /**
         * Enables the sparkler interactions.
         *
         * This method is used when the user have permission to change the columns.
         *
         * @private
         */
        _enableEdit: function() {
            //Enable the search input
            this._sparkler.enable();

            //Enable the checkboxes
            this.$el.find("input[type='checkbox']").removeAttr("disabled");  //Enable checkboxes
            this.$el.find(".check-list-item").removeClass("disabled");       //Enable labels
            this.$el.find(".no-suggestions").removeClass("disabled");        //Enable "more" message

            //Enable the action bar
            this.$el.find(".restore-defaults").removeAttr("aria-disabled");

            //Remove editDisabled message
            this._hideEditDisabledMessage();
        },

        /**
         * Creates the internal sparkler
         *
         * @param {Array.<{label: string, value: string}>} items Items to include in the sparkler
         */
        createSparklerControl: function(items) {
            //Make sure we destroy the actual sparkler.
            //This should not happen unless some event is being fired twice
            if (this._sparkler) {
                this._sparkler.remove();
            }

            var selectElement = this._buildQueryableSelect(items);
            this.$el.append(selectElement);

            //Create the sparkler control
            this._sparkler = new CheckboxMultiSelect({
                element: selectElement,
                maxInlineResultsDisplayed: this._maxResults,
                suggestionsHandler: ColumnPickerSuggestHandler,
                actionBar: this.model.getActionBarText()
            });

            //Set the selected columns
            this._setSelectedColumns();

            if (this._autoUpdate) {
                selectElement.bind("selected", _.bind(this.saveColumns, this));
                selectElement.bind("unselect", _.bind(this.saveColumns, this));
            }

            this._sparkler.$field.focus();

            // Intercept column reset and use our own method
            this.$el.on("actionclick", _.bind(function(ev) {
                ev.preventDefault();
                this.model.unset("columns");
                this.model.destroy();
            }, this));

            this.model.on("change:editDisabled", _.bind(this._disableEditIfNeeded, this));
        },

        /**
         * Saves the sparkler's columns in our model and persists them
         */
        saveColumns: function() {
            this.model.setUnsortedColumns(this._sparkler.model.getSelectedValues());
            this.model.save(null, {wait: false});
        },

        /**
         * Sets the selected items in the sparkler
         * @private
         */
        _setSelectedColumns: function() {
            var selectedColumns = this.model.getColumns();
            var sparkler = this._sparkler;

            //If the sparkler has already been built, and we hae selectedColumns...
            if (sparkler && selectedColumns && selectedColumns.length) {
                _.each(sparkler.model.getDisplayableUnSelectedDescriptors(), function(descriptor) {
                    if (_.contains(selectedColumns, descriptor.value())) {
                        sparkler.selectItem(descriptor);
                    }
                });
                _.each(sparkler.model.getDisplayableSelectedDescriptors(), function(descriptor) {
                    if (!_.contains(selectedColumns, descriptor.value())) {
                        sparkler.unselectItem(descriptor);
                    }
                });

                sparkler.render();
                this._disableEditIfNeeded();
            }
        },

        /**
         * Builds the queryableSelect with all the available items
         *
         * @param {Array.<{label: string, value: string}>} columns Columns to include in the sparkler
         * @returns {jQuery} A select element containing all the options
         * @private
         */
        _buildQueryableSelect: function(columns) {
            var instance = this;
            var availableItems = _.map(columns, function(column) {
                return new ItemDescriptor(_.extend(column, {
                    title: column.label
                }));
            });

            return jQuery(AJSTemplates.queryableSelect({
                id: instance.model.getName() + "-column-sparkler",
                descriptors: [
                    new GroupDescriptor({
                        items: availableItems
                    })
                ]
            }));
        }
    });
});
AJS.namespace("JIRA.Issues.ColumnPickerSparklerView", null, require("jira/components/columnpicker/sparklerview"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPickerView.js' */
define("jira/components/columnpicker/view", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var InlineDialog = require("aui/inline-dialog");
    var Brace = require("jira/components/libs/brace");
    var ColumnPickerSparklerView = require("jira/components/columnpicker/sparklerview");
    var jQuery = require("jquery");
    var Templates = window.JIRA.Templates.Dialogs.ColumnPicker;
    var Meta = require('jira/util/data/meta');

    var modifierKey = Meta.get("keyboard-accesskey-modifier");

    return Brace.View.extend(/** @lends JIRA.Issues.ColumnPickerView.prototype */{
        /**
         * @classdesc
         * This view contains the column picker trigger, the dialog and one subview ({@link JIRA.Issues.ColumnPickerSparklerView})
         * per each column config. Its job is to open/close the dialog, display buttons to select the column config, and
         * display the corresponding subview based on those buttons.  It also handles the 'Save' and 'Cancel' buttons at
         * the bottom of the dialog.
         *
         * The model of this view is {@link JIRA.Issues.columnPickerModel}
         *
         * @constructs
         * @extends Brace.View
         * @param {Object} options
         * @param {JIRA.Issues.columnPickerModel} options.columnPickerModel Model to use in this view
         */
        initialize: function(options) {
            _.extend(this, options);
            _.bindAll(this,
                "_generateInlineDialogContent",
                "_onDOMCloseDialogClick",
                "_onDOMConfigChooserClick",
                "_onDOMDialogHide",
                "_onDOMFormSubmit",
                "_onDOMTriggerClick",
                "_onModelChangeAvailableColumns",
                "_onModelChangeColumnConfig",
                "_onModelChangeColumnConfigDisabled",
                "_onModelDestroyColumnConfig");

            /**
             * Stores all the subviews handled by this view, indexed by name
             * @type {Object.<string, JIRA.Issues.ColumnPickerSparklerView>}
             */
            this.subViews = {};

        },

        /**
         * Stores the inline dialog used by this view. Populated by {@link JIRA.Issues.ColumnPickerView#render}
         * @type {AJS.InlineDialog}
         */
        dialog: null,

        /**
         * Stores a reference to the active subview. Populated by {@link JIRA.Issues.ColumnPickerView#_activateNewSubView}
         * @type {JIRA.Issues.ColumnPickerSparklerView}
         */
        activeSubview: null,

        /**
         * Handles the click event on config chooser
         *
         * This method sets the columnConfig in our model and closes the dialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMConfigChooserClick: function(ev) {
            var $target = jQuery(ev.target);

            // If the button is disabled, do nothing
            if ($target.attr("aria-disabled")) {
                return;
            }

            this.columnPickerModel.setColumnConfig($target.data("value") || "user");
        },

        /**
         * Activate a new subview. Each column config has a different logic, so all the decisions are delegated
         * to the columnConfig models.
         *
         * @param {JIRA.Issues.ColumnPickerSparklerView} subview View being activated
         * @private
         */
        _activateNewSubView: function(subview) {
            subview.activate();

            if (this.columnPickerModel.shouldCloseOnActivation()) {
                this.dialog.hide();
            } else {
                this.activeSubview = subview;
                this.activeSubview.show();
                this.adjustHeight();
            }

            if (this.columnPickerModel.shouldRefreshSearchOnActivation()) {
                this.columnPickerModel.refreshSearchWithColumns();
            }

            if (this.columnPickerModel.shouldLoadDefaultsOnActivation()) {
                this.columnPickerModel.loadDefaultColumns();
            }
        },

        /**
         * Handles the form submit event
         *
         * This method saves the columns in the active columnConfig and closes the dialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMFormSubmit: function(ev) {
            // Stops the form submission
            ev.preventDefault();

            this.activeSubview.saveColumns();
            this.dialog.hide();
        },

        /**
         * Handles click event on the close dialog link
         *
         * This method hides the dialog
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMCloseDialogClick: function() {
            this.dialog.hide();
        },

        /**
         * Handles the click on the dialog trigger
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMTriggerClick: function() {
            //Display the dialog
            this.dialog.show();

            // Display the active sparkler
            this.activeSubview = this.subViews[this.columnPickerModel.getCurrentColumnConfig().getName()];
            this.activeSubview.show();
            this._activateConfigChooserButton(this.columnPickerModel.getCurrentColumnConfig().getName());

            // Send request to get the available columns
            this.columnPickerModel.fetchAvailableColumnsIfNeeded();
        },

        _activateConfigChooserButton: function(newButtonName) {
            this.dialog.find(".config-chooser.active").removeClass("active");
            this.dialog.find("#columns-chooser-" + newButtonName).addClass("active");
        },

        /**
         * Handles the close event on the InlineDialog
         *
         * @param ev (jQuery.Event)
         * @private
         */
        _onDOMDialogHide: function() {
            this.columnPickerModel.revertColumnConfig();
            this.activeSubview.hide();
        },

        /**
         * Handler for change:columnConfig
         *
         * @param {JIRA.Issues.columnPickerModel} columnPickerModel Model that has changed
         * @param {string} columnConfig New value for columnConfig
         * @private
         */
        _onModelChangeColumnConfig: function(columnPickerModel, columnConfig) {
            var newSubView = this.subViews[columnConfig];
            this._activateConfigChooserButton(newSubView.model.getName());

            var oldSubView = this.subViews[columnPickerModel.previous("columnConfig")];
            if (oldSubView !== newSubView) {
                oldSubView.hide();
                oldSubView.deactivate();
                this._activateNewSubView(newSubView);
            }
        },

        /**
         * Handler for change:availableColumns
         *
         * @param {JIRA.Issues.columnPickerModel} columnPickerModel Model that has changed
         * @param {Array.<{label: string, value: string}>} availableColumns New value for availableColumns
         * @private
         */
        _onModelChangeAvailableColumns: function(columnPickerModel, availableColumns) {
            _.each(this.subViews, function(columnPickerView) {
                columnPickerView.createSparklerControl(availableColumns);
            });
        },

        /**
         * Handler for destroy
         * @private
         */
        _onModelDestroyColumnConfig: function() {
            this.dialog.hide();
        },

        /**
         * Handler for change:isDisabled
         *
         * @param {JIRA.Issues.ColumnConfigModel} model Model that has changed
         * @param {boolean} isDisabled New value for isDisabled
         * @private
         */
        _onModelChangeColumnConfigDisabled: function(model, isDisabled) {
            var button = this.dialog.find("#columns-chooser-" + model.getName());
            if (isDisabled) {
                button.attr("aria-disabled", true);
            } else {
                button.removeAttr("aria-disabled");
            }
        },

        /**
         * Renders the trigger and the dialog
         */
        render: function() {
            if (!this.$trigger) {
                this.$trigger = jQuery(Templates.trigger());
            }
            this.$el.append(this.$trigger);
            this.$trigger.click(this._onDOMTriggerClick);

            this._renderInlineDialog();
        },

        /**
         * Adjust the height of the dialog based on window height
         *
         * @returns {Boolean}
         * @private
         */
        adjustHeight: function() {
            if (InlineDialog.current && InlineDialog.current.id === "column-picker-dialog" && this.activeSubview) {
                var scrollList = jQuery(this.activeSubview.el).find(".aui-list-scroll");
                //Maximum available height = ((window height - trigger y position) - dialog bottom padding)
                var maxDialogHeight = ((window.innerHeight - this.$trigger.offset().top) - 90);
                //Delta = max available height - actual height
                var heightDelta = maxDialogHeight - this.dialog.height();
                //Desired scroll list height = actual height + Delta
                //Height confined to: 80 pixel < Scroll list height < 270 pixel
                var scrollListHeight = Math.max(Math.min(scrollList.height() + heightDelta, 270), 80);
                scrollList.css("height", scrollListHeight);
                return true;
            }
            return false;
        },

        /**
         * Generates the dialog's content
         *
         * @param {jQuery} $content The div element that will contain the custom content
         * @param {jQuery} $trigger The element of your dialog trigger
         * @param {Function} done Callback to run when the content is ready to be displayed
         * @private
         */
        _generateInlineDialogContent: function($content, $trigger, done) {
            if (!this.dialogContent) {
                // Injects the template into the dialog
                $content.html(Templates.popup({
                    modifierKey: modifierKey,
                    isAutoUpdate: this.columnPickerModel.getAutoUpdate(),
                    columns: _.map(this.columnPickerModel.columnsData, _.bind(function(col) {
                        return {
                            name: col.getName(),
                            description: col.getDescription(),
                            selected: false,
                            isDisabled: col.isDisabled(),
                            isActive: this.columnPickerModel.getCurrentColumnConfig() === col
                        };
                    }, this))
                }));

                // Bind DOM handlers
                $content.find(".config-chooser").click(this._onDOMConfigChooserClick);
                $content.find("form").submit(this._onDOMFormSubmit);
                $content.find(".close-dialog").click(this._onDOMCloseDialogClick);

                // Avoid dialog being closed on click
                $content.click(function(e) {
                    e.stopPropagation();
                });

                // Create the sparklers
                this._createSubViews($content);

                this.dialogContent = $content.children();
            } else {
                $content.append(this.dialogContent);
            }

            done();
        },

        /**
         * Renders the InlineDialog
         *
         * @private
         */
        _renderInlineDialog: function() {
            // If the dialog has been already rendered, do nothing
            if (this.dialog) {
                return;
            }

            // Build the dialog
            this.dialog = new InlineDialog(
                this.$trigger,
                "column-picker-dialog",
                this._generateInlineDialogContent,
                {
                    offsetY: 15,
                    addActiveClass: true,
                    hideDelay: null,
                    noBind: true,
                    initCallback: _.bind(function() {
                        //This is called when the inline dialog has finished rendering
                        //Using a timeout to adjust the height because when this is called, the column picker
                        //has not been completely rendered into the page yet
                        var instance = this;
                        var timeoutAdjust = function() {
                            if (!instance.adjustHeight()) {
                                //noinspection DynamicallyGeneratedCodeJS
                                setTimeout(timeoutAdjust, 100);
                            }
                        };
                        timeoutAdjust();
                    }, this),
                    hideCallback: this._onDOMDialogHide
                }
            );
        },

        /**
         * Creates the sparklers subViews
         *
         * @param {jQuery} $content
         * @private
         */
        _createSubViews: function($content) {
            _.each(this.columnPickerModel.columnsData, _.bind(function(columnConfigModel) {
                this.subViews[columnConfigModel.getName()] = new ColumnPickerSparklerView({
                    el: $content.find("." + columnConfigModel.getName() + "-column-sparkler"),
                    model: columnConfigModel,
                    autoUpdate: this.columnPickerModel.getAutoUpdate()
                });
            }, this));

            //Create sparkler controls if/when we have the available columns
            if (this.columnPickerModel.has("availableColumns")) {
                this._onModelChangeAvailableColumns(this.columnPickerModel, this.columnPickerModel.getAvailableColumns());
            }
            this.columnPickerModel.on("change:availableColumns", this._onModelChangeAvailableColumns);

            //Bind model events
            this.columnPickerModel.on("change:columnConfig", this._onModelChangeColumnConfig);
            this.columnPickerModel.onChangeColumnConfigDisabled(this._onModelChangeColumnConfigDisabled);
            this.columnPickerModel.onDestroyColumnConfig(this._onModelDestroyColumnConfig);
        }

    });

});
AJS.namespace("JIRA.Issues.ColumnPickerView", null, require("jira/components/columnpicker/view"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:columnpicker', location = 'columnpicker/ColumnPicker.js' */
define("jira/components/columnpicker", ["require"], function(require){
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var ColumnConfigModel = require("jira/components/columnpicker/columnconfigmodel");
    var ColumnPickerModel = require("jira/components/columnpicker/model");
    var ColumnPickerView = require("jira/components/columnpicker/view");

    /**
     * A module that controls the column picker model and the column picker view in a single interface.
     */
    var ColumnPicker = Brace.Model.extend({

        initialize: function(attr, options) {

            this.columnPickerModel = new ColumnPickerModel({autoUpdate: options.autoUpdate});
            this.columnPickerView = new ColumnPickerView({columnPickerModel: this.columnPickerModel});

            _.each(options.providers, _.bind(function(descriptor) {
                if (descriptor instanceof ColumnConfigModel) {
                    this.columnPickerModel.addColumnProvider(descriptor.getName(), descriptor);
                } else {
                    this.columnPickerModel.addColumnProvider(descriptor.id, this._createProviderModel(descriptor));
                    if (descriptor.columns) {
                        this.columnPickerModel.syncColumns(descriptor.id, descriptor.columns);
                    }
                }
            }, this));

            this.setCurrentColumnConfig(options.providers[0].id);
            if (options.el) {
                this.columnPickerView.setElement(options.el).render();
            }
        },

        _createProviderModel: function(descriptor) {
            return ColumnConfigModel.create(descriptor.id, descriptor.label,
                _.omit(descriptor, "id", "label", "columns"));
        },

        getCurrentColumnConfig: function() {
            return this.columnPickerModel.getCurrentColumnConfig();
        },

        setElement: function($el) {
            this.columnPickerView.setElement($el);
            return this;
        },
        render: function() {
            this.columnPickerView.render();
            return this;
        },
        clearFilterConfiguration: function() {
            this.columnPickerModel.clearFilterConfiguration();
            return this;
        },
        adjustHeight: function() {
            this.columnPickerView.adjustHeight();
            return this;
        },
        setCurrentColumnConfig: function(name) {
            this.columnPickerModel.setCurrentColumnConfig(name);
            return this;
        },
        saveColumns: function(cols) {
            this.columnPickerModel.saveColumns(cols);
            return this;
        },
        syncColumns: function(name, columns) {
            this.columnPickerModel.syncColumns(name, columns);
            return this;
        },
        getColumnConfig: function() {
            this.columnPickerModel.getColumnConfig();
        },
        onColumnsSync: function(func, ctx) {
            this.columnPickerModel.onColumnsSync(func, ctx);
            return this;
        },
        on: function(evt, func, ctx) {
            this.columnPickerModel.on(evt, func, ctx);
            return this;
        },
        off: function(evt, func) {
            this.columnPickerModel.off(evt, func);
            return this;
        }

    });

    ColumnPicker.create = function(options) {
        return new ColumnPicker(null, options);
    };
    return ColumnPicker;
});
AJS.namespace("JIRA.Components.ColumnPicker", null, require("jira/components/columnpicker"));
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/datePicker.soy' */
// This file was automatically generated from datePicker.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.DateSearcher.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.DateSearcher == 'undefined') { JIRA.Templates.DateSearcher = {}; }


JIRA.Templates.DateSearcher.dateMeasurement = function(opt_data, opt_ignored) {
  return '<select class="js-measurement"><option value="m">' + soy.$$escapeHtml("minutes") + '</option><option value="h">' + soy.$$escapeHtml("hours") + '</option><option value="d">' + soy.$$escapeHtml("days") + '</option><option value="w">' + soy.$$escapeHtml("weeks") + '</option></select>';
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dateMeasurement.soyTemplateName = 'JIRA.Templates.DateSearcher.dateMeasurement';
}


JIRA.Templates.DateSearcher.renderWithinTheLast = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Within the last {0} {1}",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderWithinTheLast.soyTemplateName = 'JIRA.Templates.DateSearcher.renderWithinTheLast';
}


JIRA.Templates.DateSearcher.withinTheLast = function(opt_data, opt_ignored) {
  return '<input type="radio" class="js-dp-type-toggle" id="withinTheLastRadio"/>' + JIRA.Templates.DateSearcher.renderWithinTheLast({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.withinTheLast.soyTemplateName = 'JIRA.Templates.DateSearcher.withinTheLast';
}


JIRA.Templates.DateSearcher.nowOverdue = function(opt_data, opt_ignored) {
  return '<label><input type="radio" class="js-dp-type-toggle" />' + soy.$$escapeHtml("Now overdue") + '</label>';
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.nowOverdue.soyTemplateName = 'JIRA.Templates.DateSearcher.nowOverdue';
}


JIRA.Templates.DateSearcher.renderMoreThan = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("More than {0} {1} ago",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.renderMoreThan';
}


JIRA.Templates.DateSearcher.moreThan = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="moreThanRadio"/>' + JIRA.Templates.DateSearcher.renderMoreThan({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.moreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.moreThan';
}


JIRA.Templates.DateSearcher.renderDueMoreThan = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("More than {0} {1} overdue",opt_data.inputField,opt_data.dateMeasurementField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDueMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDueMoreThan';
}


JIRA.Templates.DateSearcher.dueMoreThan = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="moreThanRadio"/>' + JIRA.Templates.DateSearcher.renderDueMoreThan({inputField: '<input class="js-val" type="text" maxlength="15" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null)});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dueMoreThan.soyTemplateName = 'JIRA.Templates.DateSearcher.dueMoreThan';
}


JIRA.Templates.DateSearcher.renderDueInNext = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Due in next {0} {1} {2} overdue",opt_data.inputField,opt_data.dateMeasurementField,opt_data.clauseField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDueInNext.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDueInNext';
}


JIRA.Templates.DateSearcher.dueInNext = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="dueInNextRadio"/>' + JIRA.Templates.DateSearcher.renderDueInNext({inputField: '<input class="js-val" maxlength="15" type="text" />', dateMeasurementField: '' + JIRA.Templates.DateSearcher.dateMeasurement(null), clauseField: '<select class="js-clause"><option value="orIs">' + soy.$$escapeHtml("or is") + '</option><option value="andNot">' + soy.$$escapeHtml("and not") + '</option></select>'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dueInNext.soyTemplateName = 'JIRA.Templates.DateSearcher.dueInNext';
}


JIRA.Templates.DateSearcher.renderDateBetween = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("Between {0} and {1}",opt_data.startField,opt_data.endField));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderDateBetween.soyTemplateName = 'JIRA.Templates.DateSearcher.renderDateBetween';
}


JIRA.Templates.DateSearcher.dateBetween = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" class="js-dp-type-toggle" id="dateBetweenRadio"/>' + JIRA.Templates.DateSearcher.renderDateBetween({startField: '<input class="js-start-date" maxlength="15" placeholder="11-Jan-2012" type="text" /><span class="js-start-date-trigger aui-icon aui-icon-small aui-iconfont-calendar">' + soy.$$escapeHtml("Select a date") + '</span>', endField: '<input class="js-end-date" maxlength="12" placeholder="30-Jan-2012" type="text" /><span class="js-end-date-trigger aui-icon aui-icon-small aui-iconfont-calendar">' + soy.$$escapeHtml("Select a date") + '</span>'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.dateBetween.soyTemplateName = 'JIRA.Templates.DateSearcher.dateBetween';
}


JIRA.Templates.DateSearcher.renderInRange = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("In range {0} to {1}",opt_data.startInput,opt_data.endInput));
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.renderInRange.soyTemplateName = 'JIRA.Templates.DateSearcher.renderInRange';
}


JIRA.Templates.DateSearcher.inRange = function(opt_data, opt_ignored) {
  return '<input type="radio" tabIndex="-1" maxlength="15" class="js-dp-type-toggle" id="inRangeRadio"/>' + JIRA.Templates.DateSearcher.renderInRange({startInput: '<input class="js-start-range" placeholder="-3w 4d 12h" type="text" />', endInput: '<input class="js-end-range" maxlength="15" placeholder="3w 4d 12h" type="text" />'});
};
if (goog.DEBUG) {
  JIRA.Templates.DateSearcher.inRange.soyTemplateName = 'JIRA.Templates.DateSearcher.inRange';
}
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/DateSearcher.js' */
(function ($) {
    /**
     * https://jira.atlassian.com/browse/JRA-30741
     *
     * List of class definitions used by the date searcher, which we don't want to
     * 'labelfy'
     *
     * @type {Array}
     * @private
     */
    var _excludeList = ["js-dp-type-toggle", "js-val", "js-measurement", "js-clause",
                        "js-start-date", "js-end-date", "js-start-range", "js-end-range"];

    /**
     * https://jira.atlassian.com/browse/JRA-30741
     *
     * This function 'labelfy' raw html string.
     * The purpose of this is to automatically select the radio element when a labelfied element is clicked.
     *
     * This should only labelfy text element. Any non-text element, such as a dropdown list/text field should
     * be handled through javascript instead of abusing the label tag
     *
     * @param content {String} Raw html string of the field
     * @param radioKey {String} ID string of the radio element that will be selected when a labelfied element is clicked
     * @return {String} Raw html string that has been labelfied
     * @private
     */
    var _labelfyContent = function (content, radioKey) {
        var $content = jQuery("<div></div>").html(content).contents();
        var transformed = [];

        $content.each(function(index, element) {
            var $element = jQuery(element);
            var value = jQuery("<div/>").html(element).html();

            if (!_.contains(_excludeList, $element.attr("class"))) {
                /*
                 This is to ensure white spaces coming from the template are correctly displayed in html
                 */
                value = value.replace(/^\s+|\s+$/g, '&nbsp;');
                transformed.push( "<label for='" + radioKey + "'>" + value + "</label>");
            } else {
                transformed.push(value);
            }
        });

        return transformed.join("");
    };

    /**
     * This function takes the labelfied raw html and attach handlers to non-text element, such that
     * clicking on them will automatically select the radio element.
     *
     * Why don't we just inline the label element and put everything inside it you say?
     * Well, in the ideal world, there should only be one language, everybody should use chrome and the cake is NOT a lie.
     * But unfortunately, interactions between non-text elements inside a label tag behaves different
     * between browsers. In firefox, dropdown list and text field immediately lose their focus when you click on them,
     * and who knows what might happen in IE.
     *
     * See https://jira.atlassian.com/browse/JRA-30741
     *
     * @param data
     * @return {*}
     * @private
     */
    var _generateSearcherAndBindHandler = function(data) {
        var radioKey = data.radioKey + "Radio";
        var outputContent = data.$el.html(_labelfyContent(data.rawTemplate, radioKey));
        outputContent.find(":not(.js-dp-type-toggle):not(select):input").mousedown(function() {
            /*
             WHAT? why are you clicking on the label?
             3 characters: IE8
             Clicking on radio button doesn't work in IE8 because it doesn't unselect other radio buttons

             When using 'input', Firefox also matches the <select> elements, so we need to add a special clause for that
             */
            var $label = outputContent.find("label");
            if ($label.length > 0) {
                $label[0].click();
            }
        });
        return outputContent;
    };

    var NowOverdue = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "nowOverdue"},
        template: JIRA.Templates.DateSearcher.nowOverdue,
        getValues: function () {
            return {to: 0};
        },
        updateFromValues: function (values) {
            if (!values.from && values.to === "0") {
                return true;
            }
        },
        render: function () {
            return this.$el.html(this.template());
        }
    });


    var WithinTheLast = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "withinTheLast"},
        template: JIRA.Templates.DateSearcher.withinTheLast,
        getValues: function () {
            var val = this.$(".js-val").val();
            if (val) {
                return {
                    from: "-" + val + this.$el.find(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if (!values.to && values.from && values.from.charAt(0) === "-") {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.from);
                this.$(".js-val").val(vals.val.slice(1));
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function (verb) {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });


    var MoreThan = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "moreThan"},
        template: JIRA.Templates.DateSearcher.moreThan,
        getValues: function () {
            var val = this.$(".js-val").val();
            if (val) {
                return {
                    to: "-" + val + this.$el.find(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if (!values.from && values.to && values.to.charAt(0) === "-") {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.to);
                this.$(".js-val").val(vals.val.slice(1));
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function (verb) {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });

    var DueMoreThan = MoreThan.extend({
        className: "field-group",
        template: JIRA.Templates.DateSearcher.dueMoreThan
    });

    var DueInNext = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "dueInNext"},
        template: JIRA.Templates.DateSearcher.dueInNext,
        getValues: function () {
            var val = this.$el.find(".js-val").val();
            if (val) {
                return {
                    from: this.$el.find(".js-clause").val() === "andNot" ?  "0" : null,
                    to: val + this.$(".js-measurement").val()
                };
            }
        },
        updateFromValues: function (values) {
            if ((!values.from || values.from === "0") && values.to) {
                // gets the character that represents the measurement
                var vals = this.model.parseRelativeStr(values.to);
                var clause = values.from  === "0" ? "andNot" : "orIs";
                this.$(".js-val").val(vals.val);
                this.$(".js-clause").val(clause);
                if (vals.measurement) {
                    this.$(".js-measurement").val(vals.measurement);
                }
                return true;
            }
        },
        render: function () {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });

    var DatesBetween = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "dateBetween"},
        template: JIRA.Templates.DateSearcher.dateBetween,
        getValues: function () {
            return {
                startDate: this.$el.find(".js-start-date").val(),
                endDate: this.$el.find(".js-end-date").val()
            };
        },
        updateFromValues: function (values) {
            if (values.startDate || values.endDate) {
                this.$el.find(".js-start-date").val(values.startDate);
                this.$el.find(".js-end-date").val(values.endDate);
                return true;
            }
        },
        bindCalendar: function (inputClass, triggerClass) {
            var trigger = this.$el.find("." + triggerClass)[0];
            var input = this.$el.find("." + inputClass)[0];
            var calendarParams = _.extend({}, this.model.calendarConfig, {
                inputField: input,
                button: trigger
            });
            Calendar.setup(calendarParams);
        },
        render: function () {
            _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
            this.bindCalendar("js-end-date", "js-end-date-trigger");
            this.bindCalendar("js-start-date", "js-start-date-trigger");
            return this.$el;
        }
    });

    var InRange = Backbone.View.extend({
        className: "field-group",
        attributes: {"data-date-type" : "inRange"},
        template: JIRA.Templates.DateSearcher.inRange,
        getValues: function () {
            return {
                from: this.$el.find(".js-start-range").val(),
                to: this.$el.find(".js-end-range").val()
            };
        },
        updateFromValues: function (values) {
            if (values.from || values.to) {
                this.$el.find(".js-start-range").val(values.from);
                this.$el.find(".js-end-range").val(values.to);
                return true;
            }
        },
        render: function () {
            return _generateSearcherAndBindHandler({
                $el: this.$el,
                rawTemplate: this.template(),
                radioKey: this.attributes["data-date-type"]
            });
        }
    });


    /**
     * This model is a wrapper around 4 hidden input fields. The values of these fields is what actually gets sent to the
     * server.
     * @class
     * @extends external:"Backbone.Model"
     * @private
     */
    var DateSeacherModel = Backbone.Model.extend({

        /**
         * @constructs
         */
        initialize: function (options) {
            this.from$El = options.$el.find(".js-date-picker-from").hide();
            this.to$El = options.$el.find(".js-date-picker-to").hide();
            this.startDate$El = options.$el.find(".js-date-picker-start-date").hide();
            this.endDate$El = options.$el.find(".js-date-picker-end-date").hide();
            this.errors = JIRA.parseOptionsFromFieldset(options.$el.find('fieldset.js-date-picker-errors'));
            this.calendarConfig = JIRA.parseOptionsFromFieldset(options.$el.find('fieldset.datepicker-params'));
        },

        parseRelativeStr: function (str) {
            var measurement = str.slice(str.length-1);
            var val = str.slice(0, str.length-1);
            return {
                val: val,
                measurement: measurement
            };
        },

        update: function (updateParams) {
            this.clear();
            if (updateParams) {
                if (typeof updateParams.from !== "undefined") {
                    this.from$El.val(updateParams.from);
                }
                if (typeof updateParams.to !== "undefined") {
                    this.to$El.val(updateParams.to);
                }
                if (typeof updateParams.startDate !== "undefined") {
                    this.startDate$El.val(updateParams.startDate);
                }
                if (typeof updateParams.endDate !== "undefined") {
                    this.endDate$El.val(updateParams.endDate);
                }
            }
        },

        toJSON: function () {
            return {
                from: this.from$El.val(),
                to: this.to$El.val(),
                startDate: this.startDate$El.val(),
                endDate: this.endDate$El.val(),
                errors: this.errors
            };
        },

        /**
         * Clears all the hidden input values
         */
        clear: function () {
            this.from$El.val("");
            this.to$El.val("");
            this.startDate$El.val("");
            this.endDate$El.val("");
        }
    });

    /**
     * Renders the date searcher ui.
     * @class JIRA.DateSearcher
     * @extends external:"Backbone.View"
     */
    JIRA.DateSearcher = Backbone.View.extend({

        /**
         * @param {Object} options
         * @param {jQuery} options.el - Container element
         * @param {jQuery} options.dateTypes - Container element
         * @constructs
         */
        initialize: function (options) {
            var instance = this;
            this.verb = options.verb;
            this.model = new DateSeacherModel({$el: this.$el});
            this.setElement($("<div />").addClass("js-picker-ui").appendTo(this.$el));
            this.views = [];

            /*
             * JRADEV-17691: IE10 doesn't implement the input event very well it incorrectly fires when you have placeholder text and you tab to it.
             * So in the case of IE10 we use a keydown and keyup to compare the values to validate input instead.
             */
            var useInputEvent = !jQuery.browser.msie || parseInt(jQuery.browser.version, 10) < 10;

            _.each(options.dateTypes, function (dateType) {
                var view = new dateType({model: instance.model});
                instance.views.push(view);

                if (useInputEvent) {
                    view.$el.delegate(":text", "input", function () {
                        instance.update(view);
                    });
                } else {
                    view.$el.delegate(":text", "keydown", function () {
                        var $this = jQuery(this);
                        var currentVal = $this.val();
                        $this.one("keyup", function () {
                            if ($this.val() !== currentVal) {
                                instance.update(view);
                            }
                        });
                    });
                    // for copy and paste
                    view.$el.delegate(":text", "change", function () {
                        instance.update(view);
                    });
                }

                view.$el.delegate(":radio,select,input", "change", function () {
                    instance.update(view);
                }).delegate(".aui-iconfont-calendar", "click", function () {
                    instance.update(view);
                });
            });
        },

        update: function (selectedView, error) {
            this.model.update(selectedView.getValues());
            _.each(this.views, function (view) {
                if (view === selectedView) {
                    view.$(":radio").prop("checked", true);
                } else {
                    view.$(":radio").prop("checked", false);
                }
            });
        },

        render: function () {
            var instance = this;
            var values = this.model.toJSON();
            _.each(this.views, function (view) {
                instance.$el.append(view.render(instance.verb));
            });

            $.each(this.views, function (i, view) {
                if (this.updateFromValues(values)) {
                    instance.update(this);
                    if (values.errors) {
                        $.each(values.errors, function (i, error) {
                            $("<div />").addClass("error").text(error).appendTo(view.$el);
                            return false;
                        });
                    }
                    return false;
                }
            });

            // kickass default focuses first field. We don't want this unless we have nothing selected
            window.setTimeout(function () {
                instance.$el.find(":radio:checked").focus();
            }, 30);
        }
    });

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createDueDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [NowOverdue, DueMoreThan, DueInNext, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createResolvedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createCreatedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createUpdatedDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

    /**
     * @static
     * @param {HTMLElement} el
     * @returns {JIRA.DateSearcher}
     */
    JIRA.DateSearcher.createCustomDateSearcher = function (el) {
        return new JIRA.DateSearcher({
            el: el,
            dateTypes: [WithinTheLast, MoreThan, DatesBetween, InRange]
        }).render();
    };

})(AJS.$);


;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initDateSearchers.js' */
jQuery(function () {

    function initDueDateSearcher($ctx) {
        $ctx.find(".js-duedate-searcher").each(function () {
            JIRA.DateSearcher.createDueDateSearcher(this);
        });
    }

    function initResolvedDateSearcher($ctx) {
        $ctx.find(".js-resolutiondate-searcher").each(function () {
            JIRA.DateSearcher.createResolvedDateSearcher(this);
        });
    }

    function initCreatedDateSearcher($ctx) {
        $ctx.find(".js-created-searcher").each(function () {
            JIRA.DateSearcher.createCreatedDateSearcher(this);
        });
    }

    function initUpdatedDateSearcher($ctx) {
        $ctx.find(".js-updated-searcher").each(function () {
            JIRA.DateSearcher.createUpdatedDateSearcher(this);
        });
    }

    function initCustomFieldDateSearcher($ctx) {
        $ctx.find(".js-customdate-searcher").each(function () {
            JIRA.DateSearcher.createCustomDateSearcher(this);
        });
    }

    JIRA.bind(JIRA.Events.NEW_CONTENT_ADDED, function (e, context, reason) {
        if (reason === JIRA.CONTENT_ADDED_REASON.criteriaPanelRefreshed) {
            initDueDateSearcher(context);
            initResolvedDateSearcher(context);
            initCreatedDateSearcher(context);
            initUpdatedDateSearcher(context);
            initCustomFieldDateSearcher(context);
        }
    });
});


;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initSparklers.js' */
define('jira/searchers/element/sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/skate'
], function (CheckboxMultiSelect, skate) {

    return skate("js-default-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSelectCreated(element) {
            new CheckboxMultiSelect({
                element: element
            });
        }
    });
});

define('jira/searchers/element/status-lozenge-sparkler', [
    'jira/ajs/select/checkbox-multi-select-status-lozenge',
    'jira/skate'
], function (CheckboxMultiSelectStatusLozenge, skate) {

    return skate("js-default-checkboxmultiselectstatuslozenge", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSelectCreated(element) {
            new CheckboxMultiSelectStatusLozenge({
                element: element
            });
        }
    });
});

define("jira/searchers/element/label-sparkler", [
    'jira/ajs/select/checkbox-multi-select',
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'jira/skate',
    'jquery',
    'underscore',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    GroupDescriptor,
    ItemDescriptor,
    skate,
    $,
    _,
    contextPath
) {

    return skate("js-label-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function checkboxMultiSeletCreated(element) {
            var cms = new CheckboxMultiSelect({
                element: element,
                ajaxOptions: {
                    url: contextPath() + "/rest/api/1.0/labels/suggest",
                    query: true,
                    minQueryLength: 0,
                    formatResponse: function (response) {
                        var selectedValues = cms.model.getSelectedValues();
                        return [new GroupDescriptor({
                            items: _.map(_.sortBy(_.reject(response.suggestions, function (suggestion) {
                                return _.contains(selectedValues, suggestion.label);
                            }), "label"), function (suggestion) {
                                return new ItemDescriptor({
                                    highlighted: true,
                                    html: suggestion.html,
                                    label: suggestion.label,
                                    value: suggestion.label,
                                    title: suggestion.label
                                });
                            })
                        })];
                    }
                }
            });
        }
    });
});

// Invoke immediately
require([
    "jira/searchers/element/sparkler",
    "jira/searchers/element/status-lozenge-sparkler",
    "jira/searchers/element/label-sparkler"
]);
;
;
/* module-key = 'jira.webresources:searchers', location = '/includes/jira/searchers/initUserSparkler.js' */
define('jira/searchers/user-utils', [
    'jira/ajs/list/group-descriptor',
    'jira/ajs/list/item-descriptor',
    'underscore',
    'wrm/context-path'
], function(
    GroupDescriptor,
    ItemDescriptor,
    _,
    contextPath
) {

    // Creates group/item descriptors from an AJAX response.
    function _formatUserGroupResponse(response) {
        var users = _formatUserResponse(response.users, true);
        var groups = _formatGroupResponse(response.groups, true);
        var items = [].concat(users).concat(groups);
        return [new GroupDescriptor({items: items})];
    }

    function _formatUserResponse(response, prefix) {
        return _.map(response.users, function (item) {
            return new ItemDescriptor({
                highlighted: true,
                html: item.html,
                icon: item.avatarUrl,
                label: item.displayName,
                value: (prefix ? "user:" : "") + item.name
            });
        });
    }

    function _formatGroupResponse(response, prefix) {
        return _.map(response.groups, function (item) {
            return new ItemDescriptor({
                highlighted: true,
                html: item.html,
                icon: contextPath() + "/images/icons/icon_groups_16.png",
                label: item.name,
                value: (prefix ? "group:" : "") + item.name
            });
        });
    }

    return {
        formatGroupResponse: _formatGroupResponse,
        formatUserResponse: _formatUserResponse,
        formatUserGroupResponse: _formatUserGroupResponse
    };
});

define('jira/searchers/elements/user-group-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/data/parse-options-from-fieldset',
    'jira/searchers/user-utils',
    'jira/skate',
    'jquery',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    parseOptionsFromFieldset,
    utils,
    skate,
    $,
    contextPath
) {

    return skate("js-usergroup-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function usergroupSparklerCreated(element) {
            var ajaxData = {};
            // grab additional parameters from fieldset
            $(element).siblings(".user-group-searcher-params").each(function () {
                ajaxData = parseOptionsFromFieldset($(this));
            });
            ajaxData.showAvatar = true;
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 10,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/groupuserpicker",
                    data: ajaxData,
                    query: true,
                    formatResponse: utils.formatUserGroupResponse
                }
            });
        }
    });
});

define('jira/searchers/elements/user-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/searchers/user-utils',
    'jira/skate',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    utils,
    skate,
    contextPath
) {

    return skate("js-user-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function userSparklerCreated(element) {
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 5,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/user/picker",
                    data: {
                        showAvatar: true
                    },
                    query: true,
                    formatResponse: function (items) {
                        return utils.formatUserResponse(items, false);
                    }
                }
            });
        }
    });
});

define('jira/searchers/elements/group-sparkler', [
    'jira/ajs/select/checkbox-multi-select',
    'jira/searchers/user-utils',
    'jira/skate',
    'wrm/context-path'
], function(
    CheckboxMultiSelect,
    utils,
    skate,
    contextPath
) {

    return skate("js-group-checkboxmultiselect", {
        type: skate.type.CLASSNAME,
        created: function groupSparklerCreated(element) {
            new CheckboxMultiSelect({
                element: element,
                maxInlineResultsDisplayed: 5,
                content: "mixed",
                ajaxOptions: {
                    url: contextPath() + "/rest/api/latest/groups/picker",
                    data: {
                        showAvatar: true
                    },
                    query: true,
                    formatResponse: function (items) {
                        return utils.formatGroupResponse(items, false);
                    }
                }
            });
        }
    });
});

// Invoke immediately
require([
    'jira/searchers/elements/group-sparkler',
    'jira/searchers/elements/user-sparkler',
    'jira/searchers/elements/user-group-sparkler'
]);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchPageModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchPageModule");

    JIRA.Issues.SearchPageModule = JIRA.Issues.BaseModel.extend({

        namedEvents: ["changeFilterProps"],

        properties: [
            "currentLayout",
            "layouts",
            "filter",
            "jql",
            "searchId"
        ],

        defaults: function() {
            return {
                filter: null,
                jql: null
            };
        },

        initialize: function(attributes, options) {
            _.extend(this, options);

            this.registerColumnPicker();

            // This is here instead of in defaults, because we use the defaults
            // to reset this module's state (filter and jql) but we don't want to
            // reset the layouts.
            this.setLayouts({});

            this.registerLayout("list-view", {
                label: "List View",
                iconClass: 'aui-iconfont-view-table',
                View: JIRA.Issues.FullScreenLayout
            });

            this.registerLayout("split-view", {
                label: "Detail View",
                iconClass: 'aui-iconfont-view-list',
                View: require('jira/issues/views/details')
            });

            this._onFilterChanged();
            this.on("change:filter", this._onFilterChanged, this);
            JIRA.Issues.Application.on("issueEditor:close", this.returnToSearch, this);

            JIRA.Issues.Application.on("issueEditor:loadComplete", function(model, props) {
                if (!this.standalone && !props.reason) {
                    this.searchResults.selectIssueById(model.getId(), {reason: "issueLoaded"});
                    this.searchResults.updateIssueById({
                        id: model.getId(),
                        action: "rowUpdate"
                    }, {filter: this.getFilter()});
                     //Replace URL if issue key has changed
                    if (model.getKey()) {
                        JIRA.Issues.Application.execute("navigation:updateState", {selectedIssueKey: model.getKey()},
                                {replace: true, reason: "issuekey-changed"});
                    }
                }
            }, this);

            JIRA.Issues.Application.on("issueEditor:saveSuccess", function(props) {
                this.searchResults.updateIssueById({
                    id: props.issueId,
                    action: "inlineEdit"
                }, {filter: this.getFilter()});
            }, this);

            JIRA.Issues.Application.on("navigation:stateChanged", this.onStateChanged, this);
        },

        registerColumnPicker: function() {
            this.columnConfig = JIRA.Issues.ColumnPicker.create({search: this});
        },


        getInactiveLayouts: function() {
            var layouts = [];
            _.each(this.getLayouts(), function(layout, key) {
                if (key !== JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()) {
                    layouts.push(layout);
                }
            }, this);
            return layouts;
        },

        getActiveLayout: function() {
            return this.getLayouts()[JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()];
        },

        /**
         * Change the page layout.
         * <p/>
         * No-op if the requested layout is already selected.
         *
         * @param {string} key The key of the layout to change to.
         * @param {object} [options]
         * @param {boolean} [options.ajax=true] Whether to POST the user's preferred layout to the server.
         * @param {boolean} [options.render=true] Whether to render the new layout.
         */
        changeLayout: function(key, options) {
            var layout = this.getLayout(key);
            var newLayout;
            var previousLayout = this.getCurrentLayout();

            JIRA.Issues.changingLayout = true;

            // JRADEV-20786 - Scroll to top of page before changing layouts.
            jQuery("body, html").scrollTop(0);

            options = _.defaults({}, options, {
                ajax: true,
                render: true
            });

            if (layout) {
                // If the requested layout is already selected, do nothing.
                if (previousLayout instanceof layout.View) {
                    return;
                }

                if (previousLayout && previousLayout.close) {
                    previousLayout.close();
                    // now unselect the selected issue. the assumption here is that we are switching to
                    // a mode that does not have an issue selected by default (i.e. list view).
                    this.searchResults.unselectIssue({replace: true});
                }

                JIRA.Issues.LayoutPreferenceManager.setPreferredLayoutKey(key, options);

                newLayout = new layout.View({
                    fullScreenIssue: this.fullScreenIssue,
                    issueContainer: this.issueContainer,
                    issueCacheManager: this.issueCacheManager,
                    search: this.search,
                    searchContainer: this.searchContainer,
                    searchHeaderModule: this.searchHeaderModule,
                    columnConfig: this.columnConfig,
                    searchPageModule: this
                });

                newLayout.on("close", function() {
                    this.searchContainer.find('.navigator-content').addClass("pending");
                }, this);

                newLayout.on("render", function() {
                    this.searchContainer.find('.navigator-content').removeClass("pending");
                    JIRA.trigger(JIRA.Events.LAYOUT_RENDERED, [key]);
                }, this);

                if (options.render) newLayout.render();
                this.setCurrentLayout(newLayout);

                this.standalone = false;
            }
        },

        /**
         * Create an instance of the user's preferred layout and set it as the current layout.
         */
        createLayout: function() {
            if (!this.getCurrentLayout()) {
                this.changeLayout(JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey(), {render: false});
                this.fullScreenIssue.deactivate();
            }
        },

        _onFilterChanged: function() {
            var previousFilter = this.previous('filter');
            if (previousFilter) {
                previousFilter.off('change', this.triggerChangeFilterProps, this);
            }

            var currentFilter = this.getFilter();
            if (currentFilter) {
                currentFilter.on('change', this.triggerChangeFilterProps, this);
            }
        },

        /**
         * @param {string} key A layout key.
         * @return {object|null} The layout associated with <tt>key</tt> or <tt>null</tt>.
         */
        getLayout: function(key) {
            return this.getLayouts()[key] || null;
        },

        /**
         * @return {object} an array of all registered layouts, sorted by label.
         */
        getSortedLayouts: function() {
            return _.sortBy(this.getLayouts(), "label");
        },

        /**
         * Associate a layout class with a key.
         *
         * @param {string} key A key used to identify the layout. If the key isn't unique, the old layout is overridden.
         * @param {object} layout The layout class to be associated with <tt>key</tt>; its constructor, not an instance.
         */
        registerLayout: function(key, layout) {
            layout.id = key;
            this.getLayouts()[key] = layout;
        },

        /**
         * Get jql but make sure that any requests to get jql have completed.
         * @return {jQuery.Deferred}
         */
        getJqlDeferred: function() {
            var deferred = new jQuery.Deferred();
            var instance = this;
            // I am adding a settimeout to fix the following case and avoid similar ones in the future.
            // I open a searcher, make some changes. Clicking the "Save" button to update the filter, I want to
            // get the jql after the searcher have made their request to the server. Unfortunately because the click
            // event of the "Save" button happens before the searchers make their request, we need to delay a tad.
            _.defer(function() {
                instance.queryModule.searchersReady().always(function() {
                    // Similar senario as the one above except in this case the request has returned but the jql hasn't been set.
                    _.defer(function() {
                        deferred.resolve(instance.getEffectiveJql());
                    });
                });
            });
            return deferred.promise();
        },

        registerIssueSearchManager: function(searchManger) {
            this.issueSearchManager = searchManger;
        },

        registerIssueCacheManager: function(issueCacheManager) {
            this.issueCacheManager = issueCacheManager;
        },

        registerQueryModule: function(queryModule) {
            this.queryModule = queryModule;
            this.queryModule.onJqlChanged(this.queryModuleSearchRequested, this);
            this.queryModule.onJqlError(this.disableLayoutSwitcher, this);
            this.queryModule.onJqlSuccess(this.enableLayoutSwitcher, this);
            this.queryModule.onVerticalResize(JIRA.Issues.triggerVerticalResize);
            this.queryModule.onQueryTooComplexSwitchToAdvanced(function() {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.queryTooComplexSwitchToAdvanced");
            });
            this.queryModule.onBasicModeCriteriaCountWhenSearching(function(data) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.basicModeCriteriaCountWhenSearching", data);
            });
            this.queryModule.onChangedPreferredSearchMode(function(mode) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.switchto" + mode);
            });
            this.queryModule.onSearchChanged(_.bind(function(ev){
                var state = this.getState();
                var inputJql = ev.newJql;
                var filterJql = state.filterJql;
                var searchJql = state.jql;

                var isEditedFilter;
                var isPendingSearch;
                if (searchJql === null) {
                    // The current search is just the filter search, but the search box has a different JQL
                    isEditedFilter = filterJql !== inputJql;
                    isPendingSearch = filterJql !== inputJql;
                } else {
                    // The current search is different from the filter search or from the search box
                    isEditedFilter = filterJql !== searchJql || searchJql !== inputJql;
                    isPendingSearch = searchJql !== inputJql;
                }
                this.filterModule.updateFilterHeader({
                    isEdited: isEditedFilter,
                    isPendingSearch: isPendingSearch
                });

            }, this));            
            JIRA.Shifter.register(new JIRA.Issues.SearchShifter({
                isBasicMode: _.bind(this.queryModule.isBasicMode, this.queryModule),
                isFullScreenIssue: _.bind(this.isFullScreenIssueVisible, this),
                searcherCollection: this.queryModule.getSearcherCollection()
            }));
        },

        disableLayoutSwitcher: function() {
            if (this.layoutSwitcher) {
                this.layoutSwitcher.disableLayoutSwitcher();
            }
        },

        enableLayoutSwitcher: function() {
            if (this.layoutSwitcher) {
                this.layoutSwitcher.enableLayoutSwitcher();
            }
        },


        registerLayoutSwitcher: function(layoutSwitcher) {
            this.layoutSwitcher = layoutSwitcher;
        },

        registerFilterModule: function(newFilterModule) {
            if (this.filterModule) {
                this.filterModule.off('filterRemoved');
                this.filterModule.off('filterSelected');
            }

            this.filterModule = newFilterModule;
            this.filterModule.on('filterRemoved', function(props) {
                var currentFilter = this.getFilter();
                if (currentFilter && props.filterId === currentFilter.getId()) {
                    this.resetToBlank();
                }
            }, this);

            this.filterModule.on('filterSelected', function(props) {
                this.resetToFilter(props.filterId);
            }, this);
        },

        registerSearch: function(search) {
            this.search = search;
            this.searchResults = this.search.getResults();
            this.searchResults.on("change:resultsId", this._handleSearchResultsChange, this);
            this.searchResults.onStartIndexChange(this._handleSearchResultsChange, this);
            this.searchResults.onSelectedIssueChange(this._handleSearchResultsChange, this);

            var columnConfig = this.columnConfig;

            //TODO This event must be fired before searchResults.on*Change events in order to work
            //Make sure that is a design feature and not a coincidence
            this.on("change:filter", function() {
                //When switch to another filter, clear the columns
                columnConfig.clearFilterConfiguration();
            });

            this.searchResults.onColumnsChange(function(searchResults) {
                var configName = searchResults.getColumnConfig();
                if (configName) { //There is no columnConfig on empty search
                    columnConfig.syncColumns(configName, searchResults.getColumns());
                }
            });

            this.searchResults.onColumnConfigChange(function(searchResults) {
                var configName = searchResults.getColumnConfig();
                if (configName) { //There is no columnConfig on empty search
                    columnConfig.setCurrentColumnConfig(configName);
                    //When the columnConfig changes, always set the columns
                    columnConfig.syncColumns(configName, searchResults.getColumns());
                }
            });

            columnConfig.onColumnsSync(function(columnConfigName) {
                search.stableUpdate({
                    columnConfig: columnConfigName
                });
            });

            this.searchResults.onSelectedIssueChange(_.bind(function(issue) {
                if (!issue.hasIssue()) {
                    JIRA.Issues.Application.execute("issueEditor:removeIssueMetadata");
                }
            }, this));
        },

        _handleSearchResultsChange: function(model, options) {
            options = _.defaults({}, options, {reason: 'search-results-change'});
            JIRA.Issues.Application.execute('navigation:navigate', this.searchResults.getState(), options);
        },

        registerSearchHeaderModule: function(searchHeaderModule) {
            this.searchHeaderModule = searchHeaderModule;
        },

        registerFullScreenIssue: function(fullScreenIssue) {
            this.fullScreenIssue = fullScreenIssue;
            this.fullScreenIssue.bindIssueHidden(function() {
                JIRA.Issues.Application.execute("issueEditor:dismiss");

                this.updateWindowTitle(this.getFilter());
                JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.searchContainer, JIRA.CONTENT_ADDED_REASON.returnToSearch]);
            }, this);
        },

        /**
         * @param {element} options.issueContainer The element in which issues are to be rendered.
         * @param {element} options.searchContainer The element in which search results are to be rendered.
         */
        registerViewContainers: function(options) {
            this.issueContainer = options.issueContainer;
            this.searchContainer = options.searchContainer;
        },

        prevIssue: function() {
            if (!this.standalone && this.getCurrentLayoutKey() === "split-view") {
                require('jira/issues/views/details/metrics').start();
            }

            if (this._overlayIsVisible()) {
                return false;
            }
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment") && !this.standalone) {
                this.getCurrentLayout().prevIssue();
                return true;
            }

            return false;
        },

        nextIssue: function() {
            if (!this.standalone && this.getCurrentLayoutKey() === "split-view") {
                require('jira/issues/views/details/metrics').start();
            }

            if (this._overlayIsVisible()) {
                return false;
            }
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment") && !this.standalone) {
                this.getCurrentLayout().nextIssue();
                return true;
            }

            return false;
        },

        /**
         * Is there an issue currently being loaded
         * @return Boolean
         */
        isCurrentlyLoadingIssue: function() {
            if (this.fullScreenIssue.isVisible()) {
                return this.fullScreenIssue.isLoading();
            } else {
                return this.getCurrentLayout().isLoading();
            }

        },

        _overlayIsVisible: function() {
            return AJS.$(".aui-blanket").filter(":visible").length > 0;
        },

        /**
         * Retrieve the ID of the selected issue.
         * <p/>
         * If issue search is visible, the ID of the currently highlighted issue is
         * returned; if we're viewing an issue, its ID is returned.
         *
         * @param {AJS.Dialog} [dialog] The dialog requesting this information.
         * @return {number} The ID of the currently selected issue.
         */
        getEffectiveIssueId: function() {
            return this.getEffectiveIssue().getId();
        },

        /**
         * Update the UI in response to an issue update.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @return {jQuery.Deferred} A deferred that is resolved when the refresh completes.
         */
        updateIssue: function(issueUpdate) {
            var isDelete = issueUpdate.action === JIRA.Issues.Actions.DELETE;
            var isFullScreen = this.fullScreenIssue.isVisible();

            if (isDelete) {
                return this._deleteIssue(issueUpdate);
            } else if (isFullScreen) {
                return this.fullScreenIssue.updateIssue(issueUpdate).done(_.bind(function() {
                    // If it's not a standalone issue, then we also need to update the search results.
                    //
                    // Things break if these requests are made in parallel, so force them to be serial.
                    if (!this.standalone) {
                        this.searchResults.updateIssue(issueUpdate, {
                            showMessage: false,
                            filter: this.getFilter()
                        });
                    }
                }, this));
            } else {
                return this.searchResults.updateIssue(issueUpdate, {filter: this.getFilter()});
            }
        },

        /**
         * Update the UI in response to issue deletion.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @return {jQuery.Deferred} A deferred that is resolved when the update completes.
         * @private
         */
        _deleteIssue: function(issueUpdate) {
            var isFullScreen = this.fullScreenIssue.isVisible();
            var isVisibleIssue = issueUpdate.key === JIRA.Issues.Application.request("issueEditor:getIssueKey");

            if (!isFullScreen) {
                return this.searchResults.updateIssue(issueUpdate);
            } else if (!isVisibleIssue) {
                return this.fullScreenIssue.updateIssue(issueUpdate);
            } else if (this.standalone) {
                this.resetToBlank();
                JIRA.Issues.showNotification(issueUpdate.message, issueUpdate.key);
                return new jQuery.Deferred().resolve().promise();
            } else {
                this.returnToSearch();
                return this.searchResults.updateIssue(issueUpdate);
            }
        },

        /**
         * Retrieve the key of the selected issue.
         * <p/>
         * If issue search is visible, the key of the currently highlighted issue is
         * returned; if we're viewing an issue, its key is returned.
         *
         * @return {number} The key of the currently selected issue.
         */
        getEffectiveIssueKey: function() {
            return this.getEffectiveIssue().getKey();
        },

        getEffectiveIssue: function() {
            var hasHighlightedIssue = this.searchResults.hasHighlightedIssue();
            var hasSelectedIssue = this.searchResults.hasSelectedIssue();
            var issueModuleIssue;

            issueModuleIssue = new JIRA.Issues.SimpleIssue({
                id: JIRA.Issues.Application.request("issueEditor:getIssueId"),
                key: JIRA.Issues.Application.request("issueEditor:getIssueKey")
            });

            if (this.standalone) {
                return issueModuleIssue;
            } else if (hasSelectedIssue) {
                return this.searchResults.getSelectedIssue();
            } else if (hasHighlightedIssue) {
                return this.searchResults.getHighlightedIssue();
            } else {
                return issueModuleIssue;
            }
        },

        isHighlightedIssueAccessible: function() {
            return this.search.getResults().isHighlightedIssueAccessible();
        },

        /**
         * Show issue search and change the URL to match model state.
         * <p/>
         * If returning from a stand-alone issue, reset to a blank search.
         */
        returnToSearch: function() {
            if (this.standalone) {
                this.resetToBlank();
                JIRA.trace("jira.returned.to.search");
            } else if (this.fullScreenIssue.isVisible()) {
                require('jira/issues/navigator/metrics').notifyIssueNavList();

                this.searchResults.unselectIssue();
                JIRA.Issues.Application.execute("issueEditor:beforeHide");
                // TODO: defensive check, incase issue-nav-components is a lower version than expected. Can remove after
                // soaking for bit on ondemand.
                if (this.queryModule.refreshLayout) {
                    this.queryModule.refreshLayout();
                }
            } else {
                JIRA.trace("jira.returned.to.search");
            }
            jQuery.event.trigger("updateOffsets.popout");
        },

        toggleFilterPanel: function() {
            return this.filterModule.toggleFilterPanel();
        },

        issueTableSortRequested: function(jql, startIndex) {
            this.update({jql: jql, startIndex: startIndex});
        },

        issueTableSearchError: function(response) {
            if (response.status !== 0) {
                // if we haven't aborted the request
                this.filterModule.filtersComponent.markFilterHeaderAsInvalid();
                var errors;
                try {
                    errors = JSON.parse(response.responseText);
                } catch (error) {
                    errors = {errorMessages: ["Error occurred communicating with the server. Please reload the page and try again."]};
                }
                this.queryModule.onSearchError(errors);
            }
        },

        issueTableSearchSuccess: function(data) {
            this.update({
                startIndex: data.startIndex
            });
            this.queryModule.onSearchSuccess(data.warnings);
        },

        issueTableStableUpdate: function(startIndex) {
            this.update({startIndex: startIndex});
        },

        /**
         * Prompt the user to confirm navigation if there are any dirty forms.
         *
         * @param {object} [options]
         * @param {function} [options.confirm=window.confirm] Show a confirmation dialog.
         * @param {boolean} [options.ignoreDirtiness=false] Whether to ignore dirty forms.
         * @return {boolean} whether the user confirmed navigation.
         */
        confirmNavigation: function(options) {
            options = _.defaults({}, options, {
                // Why can't we use bind or apply, I hear you ask? IE8, that's why.
                confirm: function(message) {
                    /*eslint-disable no-alert*/
                    return window.confirm(message);
                    /*eslint-enable no-alert*/
                },
                ignoreDirtiness: false
            });

            var message = JIRA.DirtyForm.getDirtyWarning() || JIRA.Issue.getDirtyCommentWarning();
            return !!options.ignoreDirtiness || message === undefined || options.confirm(message);
        },

        /**
         * @return {boolean} whether a full screen issue is visible.
         */
        isFullScreenIssueVisible: function() {
            return this.fullScreenIssue && this.fullScreenIssue.isVisible();
        },

        /**
         * @returns {boolean} whether the current layout is the Split View.
         */
        isSplitViewLayout: function() {
            return this.getCurrentLayoutKey() === "split-view";
        },

        /**
         * @returns {boolean} whether the current layout is the List View.
         */
        isListViewLayout: function() {
            return this.getCurrentLayoutKey() === "list-view";
        },

        isIssueVisible: function() {
            var layoutKey = JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey();

            if (this.isFullScreenIssueVisible()) {
                return true;
            } else if (layoutKey === "list-view") {
                return this.fullScreenIssue.isVisible();
            } else if (layoutKey === "split-view") {
                // Issue is always visible in split view AS LONG AS there are results
                return this.search.getResults().hasIssues();
            }
            return false;
        },

        queryModuleSearchRequested: function(jql) {
            this.update({
                jql: jql,
                startIndex: 0,
                selectedIssueKey: null,
                searchId: _.uniqueId()
            });
        },

        filterModuleSaved: function(filterModel) {
            this.reset({filter: filterModel.getId(), filterJql: filterModel.getJql()});
        },

        discardFilterChanges: function() {
            this.update({
                jql: null,
                selectedIssueKey: null
            }, true);
        },

        getState: function() {
            var filter = this.getFilter();

            var state = {
                filter: filter && filter.getId(),
                filterJql: filter && filter.getJql(),
                jql: this.getJql()
            };

            if (this.standalone) {
                state.selectedIssueKey = JIRA.Issues.Application.request("issueEditor:getIssueKey");
            } else {
                _.extend(state, this.search.getResults().getState());
            }

            return state;
        },

        _doSearch: function(options) {
            options = options || {};
            var searchOptions = {};
            var searchPromise;
            var filter = this.getFilter();
            searchOptions.startIndex = options.startIndex;
            if (filter) {
                searchOptions.filterId = filter.getId();
            }

            if (options.columnConfig) {
                searchOptions.columnConfig = options.columnConfig;
            }

            searchOptions.jql = this.getEffectiveJql();
            searchPromise = this.issueSearchManager.search(searchOptions);

            searchPromise.done(_.bind(function(results) {
                if (this.fullScreenIssue.isVisible() && !AJS.Meta.get('serverRenderedViewIssue')) {
                    JIRA.Issues.Application.execute("issueEditor:beforeHide");
                }
                this.searchResults.resetFromSearch(_.extend(options, results.issueTable));
                this.queryModule.onSearchSuccess(results.warnings);
                jQuery.event.trigger("updateOffsets.popout");
            }, this)).fail(_.bind(function(xhr) {
                if (xhr.statusText !== "abort") {
                    if (xhr.status === 400 && options.selectedIssueKey) {
                        this.reset({selectedIssueKey: options.selectedIssueKey}, {replace: true});
                    } else {
                        this.searchResults.resetFromSearch(_.extend(_.pick(options, "selectedIssueKey"), this.searchResults.defaults));
                        this.issueTableSearchError(xhr);
                    }
                }
            }, this));

            return searchPromise;
        },

        updateWindowTitle: function(model) {
            if (this.isFullScreenIssueVisible()) {
                return;
            }

            var filter = model;
            var navigatorTitle = AJS.format('{0} - {1}', "Issue Navigator", JIRA.Settings.ApplicationTitle.get());

            if (filter && filter.getIsValid()) {
                document.title = "[" + filter.getName() + "] " + navigatorTitle;
            } else {
                document.title = navigatorTitle;
            }
        },

        _applyState: function(state, isReset, options) {
            options = options || {};
            var prevState = this.toJSON();
            this.set(_.extend({}, this.defaults(), _.pick(state, this.properties)));

            this.updateWindowTitle(this.getFilter());

            if (isReset) {
                var jql = (state.filter && state.jql == null) ? state.filter.getJql() : state.jql;
                this.queryModule.resetToQuery(jql, {focusQuery: options.isNewSearch}).always(_.bind(function() {
                    // Hide the query view for invalid filters.
                    this.queryModule.setVisible(!state.filter || state.filter.getIsValid());
                }, this));
            }

            var searchPromise;
            if (this.shouldPerformNewSearch(prevState, this.toJSON())) {
                searchPromise = this._doSearch(state);
            } else {
                searchPromise = new jQuery.Deferred().resolve();
                if (_.indexOf(['search-results-change', 'update-filter-jql', 'issuekey-changed'], options.reason) === -1) {
                    if ("selectedIssueKey" in state) {
                        this.searchResults.selectIssueByKey(state.selectedIssueKey);
                    }
                    // If an issue is selected, its position in the results determines the page and we can ignore startIndex.
                    if ("startIndex" in state && !state.selectedIssueKey) {
                        this.searchResults.goToPage(state.startIndex);
                    }
                }
            }

            this.trigger('searching', {searchPromise: searchPromise});

            //keep filterJql in the Navigation Module state
            if (state.filter && state.filter.getJql() !== state.filterJql) {
                JIRA.Issues.Application.execute('navigation:updateState', {
                    filterJql: state.filter.getJql()
                }, {replace: true, reason: 'update-filter-jql'});
            }
        },

        /**
         * Determines if we would need to perform a new (unstable) search if
         * <tt>SearchPageModule</tt> was to be updated with the given attributes.
         *
         * @return {boolean} whether we should perform a new search.
         */
        shouldPerformNewSearch: function(prevState, newState) {
            var prevFilterId = prevState.filter && prevState.filter.getId();
            var filterId = newState.filter && newState.filter.getId();
            var filterChanged = prevFilterId !== filterId;
            var jqlChanged = newState.jql !== prevState.jql;
            var searchIdChanged = newState.searchId !== prevState.searchId;
            return filterChanged || jqlChanged || searchIdChanged;
        },

        refreshSearch: function() {
            return this._doSearch(_.extend({}, this.getState(), {
                selectedIssueKey: undefined
            }));
        },

        onStateChanged: function(state, options) {
            options = _.defaults({}, options, { resetQuery: false, routerEvent: false });
            // we do not want to operate on provided state object internally, so let's make a copy
            var shallowStateCopy = _.clone(state);
            if (state.isStandaloneIssue()) {
                this.resetToStandaloneIssue(shallowStateCopy);
            } else if (options.routerEvent) { //special treatment for router events
                return this.applyState(shallowStateCopy, !this._isSearchStateEqual(shallowStateCopy), options);
            } else {
                return this.applyState(shallowStateCopy, options.resetQuery, options);
            }
        },

        /** @deprecated use JIRA.Issues.Application.execute("navigation:navigate") **/
        update: function(state, isReset, options) {
            JIRA.Issues.Application.execute("navigation:navigate", state, _.extend({}, options, {resetQuery: isReset}));
        },

        /** @deprecated use JIRA.Issues.Application.execute("navigation:navigate") **/
        reset: function(state, options) {
            state.searchId = _.uniqueId();
            JIRA.Issues.Application.execute("navigation:navigate", state, _.extend({}, options, {reset: true, resetQuery: true}));
        },

        _deactivateCurrentLayout: function() {
            var currentLayout = this.getCurrentLayout();
            if (currentLayout) {
                if (currentLayout.close) currentLayout.close();
                this.setCurrentLayout(null);
            }
        },

        resetToStandaloneIssue: function(state) {
            require('jira/issues/navigator/metrics').notifyIssueView();
            this._deactivateCurrentLayout();
            this.set(this.defaults());
            this.standalone = true;
            this.fullScreenIssue.show({
                key: state.selectedIssueKey,
                viewIssueQuery: state.viewIssueQuery
            });
        },

        applyState: function(state, isReset, options) {
            options = options || {};
            if (this.getFilter() instanceof JIRA.Components.Filters.Models.Filter && this.getFilter().getId() === state.filter) {
                state.filter = this.getFilter();
            }
            var filterRequest;
            var shouldFetchFilter = state.filter && !(state.filter instanceof JIRA.Components.Filters.Models.Filter);
            var systemFiltersRequest = this.initSystemFilters();

            if (JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() === 'split-view') {
                if (options.fullPageLoad === true) {
                    require('jira/issues/views/details/metrics').startFromPageLoad();
                } else {
                    require('jira/issues/views/details/metrics').start();
                }
            } else if (JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey() === 'list-view') {
                if (state.selectedIssueKey) {
                    require('jira/issues/navigator/metrics').notifyIssueView();
                } else {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }
            }

            JIRA.Issues.Application.execute("issueEditor:abortPending");
            this.createLayout();

            if (shouldFetchFilter) {
                // Wait for the system filters request to finish as state.filter may refer to a system filter.
                filterRequest = new jQuery.Deferred();
                systemFiltersRequest.always(_.bind(function() {
                    this.filterModule.getFilterById(state.filter).always(function(filterModel) {
                        state.filter = filterModel;
                        filterRequest.resolve();
                    });
                }, this));
            }

            jQuery.when(filterRequest, systemFiltersRequest).always(_.bind(function() {
                this._applyState(state, isReset, options);
            }, this));
        },

        hasSelectedIssue: function() {
            return this.search.getResults().getSelectedIssue().getKey();
        },

        /**
         * Reset the application state to match a given filter.
         *
         * @param {number|JIRA.Components.Filters.Models.Filter} filter The (id of) the filter to reset to.
         */
        resetToFilter: function(filter) {
            //Selecting a filter should always attempt to use the filter columns by default
            //This will ensure request are being made with the specified behaviour above
            //Returning issue table request will contain the actual columns being used and
            //  the preference state will be updated accordingly

            this.reset({
                filter: filter,
                searchId: _.uniqueId()
            });

        },

        /**
         * Reset the query to jql=
         * A reset forces a new search to be performed even if there are no changes.
         */
        resetToBlank: function(options) {
            this.reset({jql: ""}, options);
        },

        /**
         * @return {boolean} whether the current search is dirty (a modified filter).
         */
        isDirty: function() {
            var filter = this.getFilter();
            return !!filter && filter.getJql() !== this.getEffectiveJql();
        },

        getSearchMode: function() {
            return this.queryModule.getSearchMode();
        },

        getActiveBasicModeSearchers: function() {
            return this.queryModule.getActiveBasicModeSearchers();
        },

        /**
         * Set the user's session search to a given filter.
         *
         * @param filterModel The filter.
         * @private
         */
        setSessionSearch: function(filterModel) {
            var DarkFeatures = require("jira/components/issueviewer/services/darkfeatures");
            var httpSessionEnabled = !DarkFeatures.HTTP_SESSIONS_DISABLED.enabled;

            if (httpSessionEnabled) {
                // We don't really care if this request fails; it just means that the
                // URL may unnecessarily include the JQL parameter.
                AJS.$.ajax({
                    data: {
                        filterId: filterModel.getId()
                    },
                    type: "PUT",
                    url: AJS.contextPath() + "/rest/issueNav/1/issueTable/sessionSearch/"
                });
            }

            var LatestSearchStore = require("jira/components/search/latestStorage");
            var search = {
                data: {
                    filter: filterModel.getId(),
                    jql: filterModel.getJql()
                }
            };
            LatestSearchStore.save(search);

        },

        openFocusShifter: function() {
            JIRA.Issues.FocusShifter.show();
        },

        /**
         * @param {Object} issueProps. Either id or key needs to be present.
         * @param issueProps.issueId
         * @param issueProps.issueKey
         */
        setAsInaccessible: function(issueProps) {
            this.issueTableModule.setAsInaccessible(issueProps);
        },

        /**
         * @param {Object|null} issueProps. If null/undefined, use currently selected issue.
         * @param issueProps.issueId
         * @param issueProps.issueKey
         */
        showInlineIssueLoadError: function() {
            var html = JIRA.Components.IssueViewer.Templates.Body.errorsLoading();
            JIRA.Messages.showErrorMsg(html, {closeable: true});
        },

        /**
         * In the case of no filter selected, simply gets the jql property.
         * When a filter is selected, will get the filter jql and any modifications.
         *
         * @return {string} the effective JQL.
         */
        getEffectiveJql: function() {
            var filter = this.getFilter();
            var jql = this.getJql();

            if (_.isString(jql)) {
                return jql;
            } else if (filter) {
                return filter.getJql() || "";
            } else {
                return "";
            }
        },

        /**
         * On standalone VI, system filters data will not be available on page load
         * Thus make calls to make sure it is loaded properly via ajax
         */
        initSystemFilters: function() {
            return this.filterModule.initSystemFilters();
        },

        addOwnerToSystemFilters: function(systemFilters) {
            var loggedInUser = AJS.Meta.get('remote-user');

            if (!loggedInUser) {
                return systemFilters;
            }

            var ownerDisplayName = AJS.Meta.get('remote-user-fullname');
            var avatarUrl = AJS.Meta.get('remote-user-avatar-url');

            return _.map(systemFilters, function(filter) {
                filter.ownerUserName = loggedInUser;
                filter.ownerDisplayName = ownerDisplayName;
                filter.avatarUrl = avatarUrl;
                return filter;
            });
        },

        handleLeft: function() {
            if (this._allowLeftRightNavigation()) {
                if (this.getCurrentLayout()) this.getCurrentLayout().handleLeft();
            }
        },

        handleRight: function() {
            if (this._allowLeftRightNavigation()) {
                if (this.getCurrentLayout()) this.getCurrentLayout().handleRight();
            }
        },

        handleUp: function() {
            if (!this._allowUpDownNavigation()) {
                return false;
            }

            // Allow arrow scrolling up if first issue is highlighted.
            if (this.searchResults.isFirstIssueHighlighted()) {
                return false;
            }

            return this.prevIssue();
        },

        handleDown: function() {
            if (!this._allowUpDownNavigation()) {
                return false;
            }

            return this.nextIssue();
        },

        _allowLeftRightNavigation: function() {
            return !AJS.keyboardShortcutsDisabled;
        },

        _allowUpDownNavigation: function() {
            if (AJS.keyboardShortcutsDisabled) {
                return false;
            }

            // Don't allow up/down navigation if dropdowns are open.
            if (AJS.InlineLayer.current || AJS.Dropdown.current || JIRA.Dialog.current || AJS.$(".aui-dropdown2:visible").length > 0) {
                return false;
            }

            return this.getCurrentLayout() && !this.getCurrentLayout().isIssueViewActive();
        },

        _isSearchStateEqual: function(state) {
            var searchParams = ["filter", "jql", "startIndex"];
            return _.isEqual(_.pick(state, searchParams), _.pick(this.getState(), searchParams));
        },

        /**
         * Remove all of the tipsies that are open.
         */
        removeOpenTipsies: JIRA.Issues.Tipsy.revalidate,

        getCurrentLayoutKey: function() {
            var currentLayout = this.getCurrentLayout();
            if (!currentLayout) return;


            var layoutDescriptions = this.getLayouts();
            var layoutDescription = _.find(layoutDescriptions, function(layoutDescription) {
                return currentLayout instanceof layoutDescription.View;
            });
            if (!layoutDescription) return;

            return layoutDescription.id;
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/IssueSearchManager.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.IssueSearchManager");

    /**
     * Handles the AJAX issue search requests, including both jql search and stable update.
     * For the very first search, this class will return the initial search data delivered with the page,
     * if available.
     *
     * Also keeps AsyncData of issueKeys within the search.
     */
    JIRA.Issues.IssueSearchManager = JIRA.Issues.BaseEvented.extend({
        namedEvents: [
            // Triggered before executing a search.
            "beforeSearch",

            // Triggered when a search request fails.
            "searchError"
        ],

        /**
         * @param {object} options
         * @param {object} options.initialIssueTableState The issue table's initial state.
         */
        initialize: function(options) {
            _.extend(this, options);
            this.issueKeys = new JIRA.Components.IssueViewer.Legacy.AsyncData();
        },

        /**
         * @return {boolean} whether the next search request will return the initial search without making an AJAX request.
         */
        hasInitialSearch: function() {
            return !!this.initialIssueTableState;
        },

        /**
         * Execute a new search, generating a new set of stable issue IDs.
         *
         * @param {object} data
         * @param {number} [data.filterId] The ID of the search filter.
         * @param {string} data.jql The search JQL.
         * @param {number} [data.startIndex=0] The index of the first result to return.
         * @param {boolean} [data.columnConfig] The request columns to be used. Either user, filter, system or explicit.
         * @return {jQuery.Promise} a promise that is resolved when the search completes.
         */
        search: function(data) {
            var deferred;
            var traceKey;

            data = _.extend({}, data);

            if (_.isNumber(data.startIndex) === false) {
                data.startIndex = 0;
            }

            // We don't want to have more than one request in flight for results. This can cause unexpected results.
            if (this.activeResultsReq) {
                // If it is the same as the request we are currently waiting for we can just ignore.
                if (JSON.stringify(this.activeRequestData) === JSON.stringify(data)) {
                    return new jQuery.Deferred().reject().promise();
                } else {
                    // Otherwise we will abort and issue a new request.
                    this.activeResultsReq.abort();
                }
            }

            this.activeRequestData = data;
            this.triggerBeforeSearch();

            // Initial issue search state is included in the page to avoid making an AJAX request.
            if (this.hasInitialSearch()) {
                deferred = new jQuery.Deferred().resolve(this.initialIssueTableState);
                traceKey = "jira.search.finished.initial";
                this.initialIssueTableState = null;
                this.initialIssueIds = null;
            } else {
                deferred = this.activeResultsReq = this._doSearch(data);
                traceKey = "jira.search.finished.secondary";
            }

            deferred.always(_.bind(function() {
                this.activeResultsReq = null;
                this.activeRequestData = null;
                JIRA.trace(traceKey);
            }, this));

            deferred.done(_.bind(this._updateIssueKeysOnSearchSuccess, this));

            deferred.fail(_.bind(function() {
                this.issueKeys.reset();
                this.triggerSearchError();
                _.defer(JIRA.trace, "jira.search.finished");
            }, this));

            return deferred.pipe(function(data) {
                if (data.issueTable) {
                    // Only IssueSearchManager uses these.
                    delete data.issueTable.issueKeys;
                }

                return data;
            }).promise();
        },

        /**
         * Construct a request for issue table information.
         * <p/>
         * Fails fast if the given data is invalid (e.g. invalid filter ID) and
         * doesn't actually make an AJAX request; just returns a rejected deferred.
         *
         * @param data The data to use in the request.
         * @return {jQuery.Deferred} a deferred response.
         */
        _doSearch: function(data) {
            // If the filter ID is invalid, fail. We really should move this logic
            // into IssueTableResource, but that's a slightly more risky change.
            var isInteger = /^-?\d+$/;
            if (data.filterId && !isInteger.test(data.filterId)) {
                var response = {
                    status: 400,
                    responseText: JSON.stringify({
                        errors: ["Invalid filter id. Filter id must be a number."]
                    })
                };

                return new jQuery.Deferred().reject(response).promise();
            }

            return jQuery.ajax({
                type: "POST",
                url: AJS.contextPath() + "/rest/issueNav/1/issueTable",
                headers: JIRA.Issues.XsrfTokenHeader,
                data: _.extend(data, {
                    layoutKey: JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()
                })
            });
        },

        _updateIssueKeysOnSearchSuccess: function(searchResult) {
            var issueKeyMapping;
            var issueIds = searchResult.issueTable.issueIds;
            var issueKeys = searchResult.issueTable.issueKeys;

            if (issueIds && issueKeys) {
                issueKeyMapping = {};
                _.each(issueIds, function(issueId, index) {
                    issueKeyMapping[issueId] = {
                        value: issueKeys[index],
                        error: false
                    };
                });
                this.issueKeys.reset(issueKeyMapping);
            } else {
                // Stable search is off, resort to extracting keys for current page only from the table html
                issueKeyMapping = JIRA.Issues.IssueSearchManager._extractIssueKeysFromTable(searchResult.issueTable.table);
                this.issueKeys.reset(issueKeyMapping);
            }
        },

        /**
         * Retrieve issue table information for the issues matching the given IDs.
         *
         * @param {number[]} ids The issue IDs.
         * @return {jQuery.Deferred} A deferred that is resolved when the request completes.
         */
        getRowsForIds: function(ids, searchOptions) {
            if (!ids.length) {
                // Don't need to make a request, respond with an empty results set
                return new jQuery.Deferred().resolve({}).promise();
            }

            var request = jQuery.ajax({
                data: _.extend({
                    id: ids,
                    layoutKey: JIRA.Issues.LayoutPreferenceManager.getPreferredLayoutKey()
                }, searchOptions),
                type: "POST",
                headers: JIRA.Issues.XsrfTokenHeader,
                url: AJS.contextPath() + "/rest/issueNav/1/issueTable/stable"
            });

            request.fail(_.bind(function() {
                this.triggerSearchError();
            }, this));

            return request.pipe(function(data) {
                return data.issueTable;
            }).done(_.bind(function(data) {
                this.issueKeys.setMultiple(JIRA.Issues.IssueSearchManager._extractIssueKeysFromTable(data.table, ids));
                _.defer(JIRA.trace, "jira.search.finished");
            }, this)).promise();
        },

        setAsInaccessible: function(id) {
            return this.issueKeys.setError(id);
        }

    }, {

        // Returns id->key map information from issue table html.
        // @param issueTableHtml - table html for the current page
        // @param issueIds - optional. If supplied, inaccessible rows will have an entry in the map (mapping to null).
        _extractIssueKeysFromTable: function(issueTableHtml, issueIds) {
            var map = {};
            AJS.$(issueTableHtml).find('.issuerow').each(function(i) {
                var $row = AJS.$(this);
                var id = issueIds ? issueIds[i] : $row.attr('rel');
                var key = $row.data('issuekey') || null;
                if (id) {
                    map[id] = key ? {value: key, error: false} : {error: true};
                }
            });
            return map;
        }

    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchResults.js' */
(function($) {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchResults");

    JIRA.Issues.SearchResults = JIRA.Issues.BaseModel.extend({

        defaults: {
            issueIds: [],
            selectedIssue: new JIRA.Issues.SimpleIssue(),
            highlightedIssue: new JIRA.Issues.SimpleIssue(),
            total: 0
        },

        properties: [
            "columnSortJql",
            "highlightedIssue",
            "issueIds", // only present in stable search
            "issueIdsForPage",
            "jiraHasIssues",
            "pageSize",
            "resultsId",
            "selectedIssue",
            "startIndex",
            "sortBy",
            "columns",
            "table",
            "total",
            "initialPayload",
            "columnConfig"
        ],

        namedEvents: [
            "prevIssueSelected",
            "nextIssueSelected",

            "issueUpdated",
            "issueDeleted",

            "issueDoesNotExist",

            "stableUpdate"
        ],

        initialize: function(attr, options) {
            JIRA.Issues.ModelUtils.makeTransactional(this, "resetFromSearch", "selectNextIssue", "selectPrevIssue");
            this.issueUpdateCallbacks = [];
            this._issueSearchManager = options.issueSearchManager;
            this._initialSelectedIssue = options.initialSelectedIssue;
            this._columnConfig = options.columnConfig;
        },

        /**
         * Returns the startIndex for a given page.s
         *
         * @param {Number} page the page number (0 based)
         * @return {number} the startIndex
         */
        getStartIndexForPage: function(page) {
            return page * this.getPageSize();
        },

        hasIssue: function(id) {
            return _.indexOf(this.getIssueIds(), id) !== -1;
        },

        getPager: function() {
            if (this.hasIssue(this.getSelectedIssue().getId())) {
                var issueIds = this.getIssueIds();
                var selectedId = this.getSelectedIssue().getId();
                var position = _.indexOf(issueIds, selectedId);
                var resultCount = this.getTotal();
                var stableSearchLimit = issueIds.length;
                var pager = {
                    position: JIRA.NumberFormatter.format(position + 1),
                    resultCount: JIRA.NumberFormatter.format(resultCount)
                };
                if (position > 0) {
                    var prevIssueId = this._getPrevIssueId(selectedId);
                    if (prevIssueId) {
                        pager.previousIssue = {
                            id: prevIssueId,
                            key: this._getIssueKeyForId(prevIssueId)
                        };
                    }
                }
                if (position < resultCount - 1 && position < stableSearchLimit - 1) {
                    var nextIssueId = this._getNextIssueId(selectedId);
                    if (nextIssueId) {
                        pager.nextIssue = {
                            id: nextIssueId,
                            key: this._getIssueKeyForId(nextIssueId)
                        };
                    }
                }
                return pager;
            }
        },

        /**
         * Returns the number of pages in this SearchResults.
         *
         * @return {Number} the number of pages
         */
        getNumberOfPages: function() {
            return this._getPageNumberForStartIndex(this.getDisplayableTotal() - 1);
        },

        /**
         * Remove an issue from the search results.
         * <p/>
         * The highlighted issue is updated accordingly.
         *
         * @param {number} id The ID of the issue to remove.
         */
        removeIssue: function(id) {
            id = parseInt(id, 10);

            var isFirstIssue = this.getIssueIds()[0] === id;
            var isHighlighted = this.getHighlightedIssue().getId() === id;
            var isLastIssue = _.last(this.getIssueIds()) === id;

            if (isHighlighted) {
                if (!isLastIssue) {
                    this.highlightNextIssue({replace: true});
                } else if (!isFirstIssue) {
                    this.highlightPrevIssue({replace: true});
                }
            }

            this.setIssueIds(_.without(this.getIssueIds(), id));
            this.setTotal(this.getTotal() - 1);
            this.triggerIssueDeleted({
                id: id,
                key: this._getIssueKeyForId(id)
            });
        },

        isFirstIssueHighlighted: function() {
            if (!this.hasHighlightedIssue()) {
                return false;
            }

            return this.getHighlightedIssue().getId() === this.getIssueIds()[0];
        },

        updateIssueById: function(issueUpdateObject, options) {
            return this.updateIssue(issueUpdateObject, options);
        },

        /**
         * Update the search results in response to an issue update.
         *
         * @param {object} issueUpdate An issue update object (see <tt>JIRA.Issues.Utils.getUpdateCommandForDialog</tt>).
         * @param {object} [options]
         * @param {boolean} [options.showMessage=true] Whether a success message should be shown.
         * @param {JIRA.Components.Filters.Models.Filter} [options.filter=null] Filter, in which context issues should be shown.
         * @return {jQuery.Deferred} A deferred that is resolved when the update completes.
         */
        updateIssue: function(issueUpdate, options) {
            var isDelete = issueUpdate.action === JIRA.Issues.Actions.DELETE;
            var issueID = issueUpdate.id;
            var promises = [];

            options = _.defaults({}, options, {
                showMessage: true,
                filter: null
            });

            if (isDelete) {
                this.removeIssue(issueID);
                if (options.showMessage) this._notifyOfIssueUpdate(issueUpdate);
                return new jQuery.Deferred().resolve().promise();
            } else {
                return this.getResultForId(issueID, options.filter).done(_.bind(function(entity) {
                    _.each(this.issueUpdateCallbacks, function(callback) {
                        var result = callback.handler.call(callback.ctx || window, issueID, entity, issueUpdate);
                        if (result && result.promise) {
                            promises.push(result);
                        }
                    });

                    $.when(promises).done(_.bind(function() {
                        if (options.showMessage) this._notifyOfIssueUpdate(issueUpdate);
                    }, this));
                }, this));
            }
        },

        _notifyOfIssueUpdate: function(issueUpdate) {
            if (issueUpdate.message) JIRA.Issues.showNotification(issueUpdate.message, issueUpdate.key);
            JIRA.trace("jira.search.stable.update");
        },

        getResultForId: function(id, filter) {
            var options = {columnConfig: this._columnConfig.columnPickerModel.getColumnConfig()};

            //if used filter is system filter we don't want to get results based off him
            if (filter && !filter.getIsSystem()) {
                options = _.extend({filterId: filter.getId()}, options);
            }
            return this._issueSearchManager.getRowsForIds([id], options);
        },

        isHighlightedIssueAccessible: function() {
            if (!this.hasHighlightedIssue()) {
                return null;
            }
            return !this._issueSearchManager.issueKeys.hasError(this.getHighlightedIssue().getId());
        },

        getDisplayableTotal: function() {
            return this.getIssueIds().length;
        },

        selectIssueByKey: function(key, options) {
            if (!key) {
                this.unselectIssue();
                return;
            }

            var id = this._getIssueIdForKey(key);

            if (!id || id === -1) {
                this._unhighlightIssue();

                this.getSelectedIssue().set({
                    id: -1,
                    key: key
                });

                this.triggerIssueDoesNotExist();
            } else {
                this._selectExistingIssueById(id, options);
            }
        },

        _unhighlightIssue: function() {
            this.getHighlightedIssue().set({
                id: null,
                key: null
            });
        },

        selectFirstInPage: function(options) {
            this.selectIssueById(this.getIssueIds()[this.getStartIndex()], options);
        },

        getPrevPageStartIndex: function() {
            var target = (this.getStartIndex() || 0) - this.getPageSize();
            return (target < 0) ? null : target;
        },

        getNextPageStartIndex: function() {
            var target = this.getPositionOfLastIssueInPage();
            return (target >= this.getDisplayableTotal()) ? null : target;
        },

        /**
         * Returns the position in the search results of the last issue on the current page (e.g. if the page size is
         * 5 and we are on the first page this returns 5).
         *
         * @return {Number}
         */
        getPositionOfLastIssueInPage: function() {
            var startIndex = this.getStartIndex();
            var pageSize = this._pageSize();

            return Math.min(startIndex + pageSize, this.getDisplayableTotal());
        },

        highlightFirstInPage: function() {
            this.highlightIssueById(this.getIssueIds()[this.getStartIndex()]);
        },

        selectIssueById: function(id, options) {
            if (!id) {
                this.unselectIssue();
            } else {
                this._selectExistingIssueById(id, options);
            }
        },

        _selectExistingIssueById: function(id, options) {
            if (id !== this.getSelectedIssue().getId() && JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                id = id ? parseInt(id, 10) : null;
                this.getSelectedIssue().set({
                    id: id,
                    key: id ? this._getIssueKeyForId(id) : null
                }, options);
                this.highlightIssueById(id);
            }
        },

        /**
         * Sets the issue with the given id as the highlighted issue and updates the startIndex accordingly (such that
         * the startIndex is equal to the offset of the first issue of the page that contains the highlighted issue).
         *
         * @param {number} id The ID of the issue to highlight.
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         */
        highlightIssueById: function(id, options) {
            options = _.defaults({}, options, {
                replace: false
            });

            if (id && id !== this.getHighlightedIssue().getId()) {
                id = id ? parseInt(id, 10) : null;
                this.getHighlightedIssue().set({
                    id: id,
                    key: id ? this._getIssueKeyForId(id) : null
                }, options);
                if (id) {
                    this.setStartIndex(this._getStartIndexForIssueId(id));
                }
            }
        },

        getState: function() {
            return {
                selectedIssueKey: this.getSelectedIssue().getKey(),
                startIndex: this.getStartIndex()
            };
        },

        /**
         * Resets this SearchResults using new search data. This effectively wipes any existing state and replaces it
         * with the passed-in state.
         *
         * Calling this method generates a new <code>resultsId</code>, which triggers a "newPayload" event.
         *
         * @param state
         */
        resetFromSearch: function(state) {
            state.resultsId = _.uniqueId();
            this.getSelectedIssue().set({id: null, key: null});
            this.set({sortBy: null});
            this.set("startIndex", state.startIndex, {silent: true});
            this.set(_.pick(state, this.properties));
            if (typeof state.selectedIssueKey === 'string') {
                this.selectIssueByKey(state.selectedIssueKey);
            } else {
                if (this.hasIssues()) {
                    this.highlightFirstInPage();
                } else {
                    this.getHighlightedIssue().set({id: null, key: null});
                }
            }
        },

        hasIssues: function() {
            return !!this.getIssueIds().length;
        },

        isIssueOnPage: function(id) {
            return _.indexOf(this.getPageIssueIds(), id) !== -1;
        },

        isFirstIssueSelected: function() {
            if (this.hasIssue(this.getSelectedIssue().getId())) {
                var issueIds = this.getIssueIds();
                var selectedId = this.getSelectedIssue().getId();
                var position = _.indexOf(issueIds, selectedId);
                return position === 0;
            }

            return false;
        },

        /**
         * @param options
         * @param options.filterId
         * @param options.columnConfig
         */
        getResultsForPage: function(options) {
            _.extend(options, {columnConfig: this._columnConfig.columnPickerModel.getColumnConfig()});

            if (this.getTable()) {
                var result = this.getTable();
                this.setTable(null, {silent: true}); //do not trigger a new search
                _.defer(function() {
                    JIRA.trace("jira.search.finished");
                });
                return new $.Deferred().resolve(result).promise();
            }
            return this.getResultsForIds(this.getPageIssueIds(), options);
        },

        /**
         * @param ids
         * @param options
         * @param options.filterId
         * @param options.columnConfig
         */
        getResultsForIds: function(ids, options) {
            var instance = this;
            var deferred = new $.Deferred();
            this._issueSearchManager.getRowsForIds(ids, options)
                .done(function(result) {
                    //HACK - The REST endpoint for splitview always returns columnConfig="user", which is very
                    //wrong. We can update the columnConfig only for listview, as that REST endpoint is the one
                    //returning the good values.
                    var isSplitViewResponse = _.isArray(result.table);
                    if (!isSplitViewResponse) {
                        instance.setColumnConfig(result.columnConfig);
                        instance.setColumns(result.columns);
                        instance.setColumnSortJql(result.columnSortJql);
                    }
                    deferred.resolve(result.table);
                }).fail(deferred.reject)
                .always(function() {
                    _.defer(function() {
                        JIRA.trace("jira.search.finished");
                    });
                });
            return deferred;
        },

        applyState: function(state) {
            this.set(_.pick(state, this.properties));
        },

        unselectIssue: function(options) {
            var selectedIssue = this.getSelectedIssue();
            if (selectedIssue.getId() && JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                selectedIssue.set({
                    id: null,
                    key: null
                }, options);
            }
        },

        hasSelectedIssue: function() {
            return !!this.getSelectedIssue().getId();
        },

        hasHighlightedIssue: function() {
            return !!this.getHighlightedIssue().getId();
        },

        getPageIssueIds: function() {
            var startIndex = this.getStartIndex();
            var pageSize = this._pageSize();

            var issueIds = this.getIssueIds();
            return issueIds ? issueIds.slice(startIndex, Math.min(startIndex + pageSize, issueIds.length)) : [];
        },

        getPageIssues: function() {
            // return ids and keys
            return _.map(this.getPageIssueIds(), function(id) {
                return {id: id, key: this._getIssueKeyForId(id)};
            }, this);
        },

        getPageNumber: function() {
            return Math.floor(this.getStartIndex() / this._pageSize());
        },

        /**
         * Returns the position of the given issue id on the page (0-based).
         *
         * @param issueId
         * @return {number}
         */
        getPositionOfIssueInPage: function(issueId) {
            return this.getPositionOfIssueInSearchResults(issueId) % this._pageSize();
        },

        /**
         * Returns the position of the given issue in the stable search results (0-based).
         *
         * @param issueId
         * @return {*}
         */
        getPositionOfIssueInSearchResults: function(issueId) {
            return _.indexOf(this.getIssueIds(), issueId);
        },

        /**
         * (Async) Selects the next issue in the search results if possible. Clients can register a callback using
         * onSelectedIssueChange() to subscribe to selected issue change events, or alternatively use the promise
         * that this method returns.
         *
         * @return {jQuery.Promise} a promise with the id of the selected issue if successful
         */
        selectNextIssue: function(options) {
            if (!this.hasSelectedIssue()) {
                return new $.Deferred().reject().promise();
            }

            var nextId = this._getNextIssueId(this.getSelectedIssue().getId());
            this._triggerNextIssueSelectedEvent(nextId);

            return this._selectIssue(nextId, options);
        },

        /**
         * (Async) Selects the previous issue in the search results if possible. Clients can register a callback using
         * onSelectedIssueChange() to subscribe to selected issue change events, or alternatively use the promise
         * that this method returns.
         *
         * @return {jQuery.Promise} a promise with the id of the selected issue if successful
         */
        selectPrevIssue: function(options) {
            if (!this.hasSelectedIssue()) {
                return new $.Deferred().reject().promise();
            }

            var prevId = this._getPrevIssueId(this.getSelectedIssue().getId());
            this._triggerPrevIssueSelectedEvent(prevId);

            return this._selectIssue(prevId, options);
        },

        _selectIssue: function(issueId, options) {
            this.selectIssueById(issueId, options);
            return new $.Deferred().resolve(issueId).promise();
        },

        /**
         * (Async) Highlights the previous issue in the search results if possible. Clients can register a callback using
         * onHighlightedIssueChange() to subscribe to selected issue highlighted events, or alternatively use the
         * promise that this method returns.
         *
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         * @return {jQuery.Promise} a promise with the id of the highlighted issue if successful
         */
        highlightNextIssue: function(options) {
            if (!this.hasHighlightedIssue()) {
                return new $.Deferred().reject().promise();
            }

            // this is always synchronous in stable search but it is async when we are going across page boundaries
            // in dynamic search (we need to get the set of issues in the next page at this point)
            var nextId = this._getNextIssueId(this.getHighlightedIssue().getId());
            this.highlightIssueById(nextId, options);

            return new $.Deferred().resolve(nextId).promise();
        },

        /**
         * (Async) Highlights the next issue in the search results if possible. Clients can register a callback using
         * onHighlightedIssueChange() to subscribe to selected issue highlighted events, or alternatively use the
         * promise that this method returns.
         *
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether highlighting the issue should be a "replace" operation.
         * @return {jQuery.Promise} a promise with the id of the highlighted issue if successful
         */
        highlightPrevIssue: function(options) {
            if (!this.hasHighlightedIssue()) {
                return new $.Deferred().reject().promise();
            }

            // this is always synchronous in stable search but it is async when we are going across page boundaries
            // in dynamic search (we need to get the set of issues in the next page at this point)
            var prevId = this._getPrevIssueId(this.getHighlightedIssue().getId());
            this.highlightIssueById(prevId, options);

            return new $.Deferred().resolve(prevId).promise();
        },

        /**
         * Show the page starting at <tt>startIndex</tt>.
         * <p/>
         * This method is asynchronous.
         *
         * @param {number} startIndex The index of the first issue on the page.
         * @param {object} [options]
         * @param {boolean} [options.replace=false] Whether showing the page should be a "replace" operation.
         * @return {jQuery.Deferred} A deferred that will be resolved with the ID of the newly highlighted issue.
         */
        goToPage: function(startIndex, options) {
            options = _.defaults({}, options, {
                replace: false
            });

            if (startIndex === null || startIndex === this.getStartIndex()) {
                return new $.Deferred().resolve().promise();
            }

            // Highlighting an issue updates the startIndex to ensure it is on the current page.
            var ID = this.getIssueIds()[startIndex];
            this.highlightIssueById(ID, options);

            return new $.Deferred().resolve(ID).promise();
        },

        onHighlightedIssueChange: function(callback, context) {
            this.getHighlightedIssue().on("change", callback, context);
        },

        offHighlightedIssueChange: function(callback, context) {
            this.getHighlightedIssue().off("change", callback, context);
        },

        onSelectedIssueChange: function(callback, context) {
            this.getSelectedIssue().on("change", callback, context);
        },

        offSelectedIssueChange: function(callback, context) {
            this.getSelectedIssue().off("change", callback, context);
        },

        onColumnConfigChange: function(callback, context) {
            this.on("change:columnConfig", callback, context);
        },

        offColumnConfigChange: function(callback, context) {
            this.off("change:columnConfig", callback, context);
        },

        onColumnsChange: function(callback, context) {
            this.on("change:columns", callback, context);
        },

        offColumnsChange: function(callback, context) {
            this.off("change:columns", callback, context);
        },

        onStartIndexChange: function(callback, context) {
            this.on("change:startIndex", callback, context);
        },

        onNewIssueIds: function(callback, context) {
            this.on("change:issueIds", callback, context);
        },

        offNewIssueIds: function(callback, context) {
            this.off("change:issueIds", callback, context);
        },

        offStartIndexChange: function(callback, context) {
            this.off("change:startIndex", callback, context);
        },

        onNewPayload: function(func, context) {
            this.on("change:resultsId", func, context);
        },

        offNewPayload: function(func, context) {
            this.off("change:resultsId", func, context);
        },

        onIssueUpdated: function(func, ctx) {
            this.issueUpdateCallbacks.push({
                handler: func,
                ctx: ctx
            });
        },

        offIssueUpdated: function(func) {
            var filteredCallbacks = [];
            this.issueUpdateCallbacks = _.each(this.issueUpdateCallbacks, function(callback) {
                if (callback.handler !== func) {
                    filteredCallbacks.push(callback);
                }
            });
            this.issueUpdateCallbacks = filteredCallbacks;
        },

        _getNextIssueId: function(id) {
            var issueIds = this.getIssueIds();
            return issueIds[Math.min(_.indexOf(issueIds, id) + 1, this.getDisplayableTotal() - 1)];
        },

        getNextIssueForId: function(id) {
            var nextId = this._getNextIssueId(id);
            return {id: nextId, key: this._getIssueKeyForId(nextId)};
        },

        getNextIssueForSelectedIssue: function() {
            return this.getNextIssueForId(this.getSelectedIssue().getId());
        },

        _getPrevIssueId: function(id) {
            var issueIds = this.getIssueIds();
            return issueIds[Math.max(0, _.indexOf(this.getIssueIds(), id) - 1)];
        },

        /**
         * Calculate the start index that should be used to show a particular issue.
         * <p/>
         * Returns 0 if the issue isn't present in the search results.
         *
         * @param {number} id The issue's ID.
         * @return {number} The start index.
         * @private
         */
        _getStartIndexForIssueId: function(id) {
            var issueIndex = _.indexOf(this.getIssueIds(), id);
            var pageSize = this._pageSize();

            return Math.max(0, Math.floor(issueIndex / pageSize) * pageSize);
        },

        _getIssueIdForKey: function(key) {
            // this only happens if the selected issue is not in the search results (i.e. when the user
            // navigates to the selected issue directly but has a search context).
            if (this._initialSelectedIssue && key === this._initialSelectedIssue.key) {
                return this._initialSelectedIssue.id;
            }

            return this._getIssueKeysToIds()[key];
        },

        _getIssueKeyForId: function(id) {
            // this only happens if the selected issue is not in the search results (i.e. when the user
            // navigates to the selected issue directly but has a search context).
            if (this._initialSelectedIssue && id === this._initialSelectedIssue.id) {
                return this._initialSelectedIssue.key;
            }

            return this._getIssueIdsToKeys()[id];
        },

        _getIssueIdsToKeys: function() {
            return this._issueSearchManager.issueKeys.getAllCached();
        },

        _getIssueKeysToIds: function() {
            var obj = {};
            var idsToKeys = this._issueSearchManager.issueKeys.getAllCached();
            _.each(idsToKeys, function(value, name) {
                obj[value] = name;
            });

            return obj;
        },

        /**
         * Returns a 0-based page number.
         *
         * @param startIndex the start index
         * @return {Number} a 0-based page number.
         * @private
         */
        _getPageNumberForStartIndex: function(startIndex) {
            return Math.floor(startIndex / this._pageSize());
        },

        /**
         * Returns the page size used for the search.
         *
         * @return {Number} the page size
         * @private
         */
        _pageSize: function() {
            return this.getPageSize();
        },

        _triggerPrevIssueSelectedEvent: function(prevId) {
            if (prevId !== this.getSelectedIssue().getId()) {
                var prevPrevId = this._getPrevIssueId(prevId);

                this.trigger("prevIssueSelected", {
                    prevIssue: {id: prevId, key: this._getIssueKeyForId(prevId)},
                    prevPrevIssue: {id: prevPrevId, key: this._getIssueKeyForId(prevPrevId)}
                });
            }
        },

        _triggerNextIssueSelectedEvent: function(nextId) {
            if (nextId !== this.getSelectedIssue().getId()) {
                var nextNextId = this._getNextIssueId(nextId);

                this.trigger("nextIssueSelected", {
                    nextIssue: {id: nextId, key: this._getIssueKeyForId(nextId)},
                    nextNextIssue: {id: nextNextId, key: this._getIssueKeyForId(nextNextId)}
                });
            }
        }
    });
})(AJS.$);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/SearchModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchModule");

    JIRA.Issues.SearchModule = JIRA.Issues.BaseEvented.extend({
        initialize: function(options) {
            this._issueSearchManager = options.issueSearchManager;
            this._searchPageModule = options.searchPageModule;
            this._searchResults = new JIRA.Issues.SearchResults(null, {
                issueSearchManager: this._issueSearchManager,
                initialSelectedIssue: options.initialSelectedIssue,
                columnConfig: this._searchPageModule.columnConfig
            });

            // TF-447 - Refactoring step to remove nested dependencies on SearchModule.
            JIRA.Issues.Application.reqres.setHandler("issueNav:currentSearchRequest", this.getCurrentSearchRequest, this);

            JIRA.Issues.Application.commands.setHandler("issueNav:refreshSearch", this.refresh, this);
        },

        /**
         * Sorts this search using the specified JQL or fieldId.
         *
         * @param {object} sortOptions
         * @param {string} sortOptions.fieldId
         * @param {string} sortOptions.jql
         */
        doSort: function(jql) {
            if (jql) {
                this._searchPageModule.update({
                    jql: jql,
                    startIndex: null,
                    selectedIssueKey: null
                }, true);
            }
        },

        getFilterId: function() {
            var filter = this._searchPageModule.getFilter();
            return filter && filter.getId();
        },

        getJql: function() {
            return this._searchPageModule.getJql();
        },

        getEffectiveJql: function() {
            return this._searchPageModule.getEffectiveJql();
        },

        getResults: function() {
            return this._searchResults;
        },

        getState: function() {
            return this._searchPageModule.getState();
        },

        getCurrentSearchRequest: function() {
            return {
                jql: this.getJql(),
                filterId: this.getFilterId()
            };
        },

        /**
         * @param {object} [state=this._searchPageModule.getState()] The state to inspect.
         * @return {boolean} Whether <tt>state</tt> describes a state where a stand alone issue is visible.
         */
        isStandAloneIssue: function(state) {
            state = state || this._searchPageModule.getState();
            return !!state.selectedIssueKey && !_.isString(state.jql) && !state.filter;
        },

        /**
         * Register a callback to be executed before a search is performed.
         *
         * @param {function} callback The callback to execute.
         * @param {object} context The context in which to execute.
         */
        onBeforeSearch: function(callback, context) {
            this._issueSearchManager.bindBeforeSearch(callback, context);
        },

        /**
         * Remove a before search callback.
         *
         * @param {function} callback The callback to remove.
         * @param {object} context The callback's context.
         */
        offBeforeSearch: function(callback, context) {
            this._issueSearchManager.unbindBeforeSearch(callback, context);
        },

        /**
         * Register a callback to be executed when a search fails.
         *
         * @param {function} callback The callback to execute.
         * @param {object} context The context in which to execute.
         */
        onSearchError: function(callback, context) {
            this._issueSearchManager.bindSearchError(callback, context);
        },

        /**
         * Remove a search error callback.
         *
         * @param {function} callback The callback to remove.
         * @param {object} context The callback's context.
         */
        offSearchError: function(callback, context) {
            this._issueSearchManager.unbindSearchError(callback, context);
        },

        refresh: function() {
            return this._searchPageModule.refreshSearch();
        },

        /**
         * Triggers the StableUpdate event. It will force a new
         * search
         *
         * @param {Object} [opts] Config object with custom options
         */
        stableUpdate: function(opts) {
            this._searchResults.triggerStableUpdate(_.extend({
                force: true
            }, opts));
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-mess', location = 'content/js/search/EmptyResultsView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.EmptyResultsView");

    JIRA.Issues.EmptyResultsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            this.searchResults = options.searchResults;
        },

        render: function() {
            var message;
            var hint;
            var cssClass;
            var linkType;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
                linkType = 'login';
            } else if (this.searchResults.getJiraHasIssues() === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
                linkType = 'create';
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
                linkType = 'create';
            }

            this.$el.addClass("empty-results");
            this.$el.html(JIRA.Templates.IssueNavTable.noResults({
                message: message,
                hint: hint,
                cssClass: cssClass
            }));

            // Make links within the hint work
            var $links = this.$('.no-results-hint a');
            switch (linkType) {
                case 'create':
                    $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
                    break;
                case 'login':
                    $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
                    break;
            }

            _.defer(jQuery.event.trigger, 'updateOffsets.popout');
            _.defer(JIRA.trace, 'jira.search.finished');
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/IssueTable.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable");
    JIRA.Components.IssueTable = JIRA.Marionette.Controller.extend({

        initialize: function(options) {
            this.issueTableView = new JIRA.Issues.IssueTableView({
                columnConfig: options.columnConfig
            });
            this._createSearchService(options);
            this._createTableController(options);

            JIRA.Issues.Application.on("issueEditor:loadError", this._handleIssueLoadError, this);
        },

        _createSearchService: function(options) {
            this.searchService = options.searchService;
            this.listenTo(this.searchService, {
                "before:search": function() {
                    this.issueTableController.showPending();
                },
                "search": function(table, searchResults) {
                    this.latestResults = {
                        table: table,
                        sortOptions: searchResults.getSortBy(),
                        totalDisplayableIssues: searchResults.getDisplayableTotal(),
                        startIndex: searchResults.getStartIndex(),
                        pageSize: searchResults.getPageSize(),
                        pageNumber: searchResults.getPageNumber(),
                        numberOfPages: searchResults.getNumberOfPages(),
                        totalIssues: searchResults.getTotal(),
                        currentSearch: JIRA.Issues.Application.request("issueNav:currentSearchRequest"),
                        jiraHasIssues: searchResults.getJiraHasIssues(),
                        hasIssues: searchResults.hasIssues()
                    };
                    this.show();
                    this.highlightIssue(searchResults.getHighlightedIssue().id, false);
                },
                "error:search": function() {
                    this.issueTableController.showErrorMessage();
                },
                "issueUpdated": function(issueId, entity) {
                    this.issueTableController.updateIssue(issueId, entity.table);
                },
                "issueHighlighted": function(issueId) {
                    this.issueTableController.highlightIssue(issueId);
                },
                "selectedIssueChanged": function(selectedIssue, highlightedIssue) {
                    if (!selectedIssue.hasIssue()) {
                        this.issueTableController.highlightIssue(highlightedIssue.id);
                    }
                }

            });
        },

        _createTableController: function(options) {
            var columnConfig = options.columnConfig;
            var el = options.el;

            this.issueTableController = new JIRA.Components.IssueTable.Controllers.IssueTable({
                el: el
            });
            this.listenTo(this.issueTableController, {
                "goToPage": function(startIndex) {
                    this.searchService.goToPage(startIndex);
                },
                "columnsChanged": function(cols) {
                    columnConfig.saveColumns(cols);
                },
                "highlightIssue": function(issueId) {
                    this.trigger("highlightIssue", issueId);
                },
                "sort": function(fieldId) {
                    this.searchService.sort(fieldId);
                },
                "refresh": function() {
                    this.searchService.runCurrentSearch();
                },
                "renderTable": function($el) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$el, JIRA.CONTENT_ADDED_REASON.issueTableRefreshed]);
                    JIRA.trace("jira.search.stable.update");
                },
                "renderEmpty": function($el) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$el, JIRA.CONTENT_ADDED_REASON.issueTableRefreshed]);
                    JIRA.trace("jira.search.stable.update");
                },
                "issueRowUpdated": function($newRow) {
                    JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [$newRow, JIRA.CONTENT_ADDED_REASON.issueTableRowRefreshed]);
                    // even though we've only replaced one row, a search has occurred at this point. all our
                    // WebDriver tests expect this trace after modifying issues from the issue nav
                    JIRA.trace('jira.search.finished');
                }
            });
        },

        show: function() {
            if (!this.latestResults) {
                this.searchService.updateExitingResults();
            } else {
                this.issueTableController.show(this.latestResults);
                this.trigger("render");
                this.issueTableView._onSearchDone(this.issueTableController.view.$el);
            }
        },

        close: function() {
            this.issueTableController.close();
            this.stopListening(this.searchService);
            JIRA.Issues.Application.off("issueEditor:loadError", this._handleIssueLoadError, this);
            delete this.issueTableController;
            delete this.searchService;
        },

        handleIssueInaccessible: function(issueId) {
            this.issueTableController.markIssueAsInaccessible(issueId);
        },

        /**
         * Highlight an issue in the table.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function(issueId, focus) {
            this.issueTableController.highlightIssue(issueId, focus);
        },

        _handleIssueLoadError: function(entity) {
            // If the issue has been deleted, update its row in the table.
            if (entity.response.status === 404) {
                this.issueTableController.markIssueAsInaccessible(entity.issueId);
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-results.soy' */
// This file was automatically generated from issuenav-results.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNav.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNav == 'undefined') { JIRA.Templates.IssueNav = {}; }


JIRA.Templates.IssueNav.resultsCount = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.IssueNav.resultsCountHelper({start: '<span class="results-count-start">' + soy.$$escapeHtml(opt_data.start) + '</span>', end: '<span class="results-count-end">' + soy.$$escapeHtml(opt_data.end) + '</span>', total: '<span class="results-count-total results-count-link">' + soy.$$escapeHtml(opt_data.total) + '</span>'});
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.resultsCount.soyTemplateName = 'JIRA.Templates.IssueNav.resultsCount';
}


JIRA.Templates.IssueNav.resultsCountHelper = function(opt_data, opt_ignored) {
  return '<span class="results-count-text">' + soy.$$filterNoAutoescape(AJS.format("{0}\x26ndash;{1} of {2}",opt_data.start,opt_data.end,opt_data.total)) + '</span>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.resultsCountHelper.soyTemplateName = 'JIRA.Templates.IssueNav.resultsCountHelper';
}


JIRA.Templates.IssueNav.endOfStableMessage = function(opt_data, opt_ignored) {
  return '<p>' + soy.$$escapeHtml("Too many search results to display. Refine your search criteria and try again.") + '</p>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.endOfStableMessage.soyTemplateName = 'JIRA.Templates.IssueNav.endOfStableMessage';
}


JIRA.Templates.IssueNav.refreshResults = function(opt_data, opt_ignored) {
  return '<a href="#" class="refresh-table" title="' + soy.$$escapeHtml("Refresh results") + '"><span class="aui-icon aui-icon-small aui-iconfont-refresh-small">' + soy.$$escapeHtml("Refresh results") + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.refreshResults.soyTemplateName = 'JIRA.Templates.IssueNav.refreshResults';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-pagination.soy' */
// This file was automatically generated from issuenav-pagination.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavTable.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavTable == 'undefined') { JIRA.Templates.IssueNavTable = {}; }


JIRA.Templates.IssueNavTable.pagination = function(opt_data, opt_ignored) {
  var output = '<div class="pagination" data-displayable-total="' + soy.$$escapeHtml(opt_data.displayableTotal) + '">';
  var MAX_PAGES_DISPLAYED__soy6 = 5;
  var lastPage__soy7 = Math.floor((opt_data.displayableTotal - 1) / opt_data.pageSize);
  var pageNumber__soy8 = Math.floor(opt_data.startIndex / opt_data.pageSize);
  var urlFragment__soy9 = soy.$$escapeHtml("/jira") + '/' + soy.$$filterNoAutoescape(opt_data.searchQuery) + '&startIndex=';
  var prevStartIndex__soy15 = opt_data.startIndex - opt_data.pageSize;
  output += ((prevStartIndex__soy15 >= 0) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(prevStartIndex__soy15) + '" data-start-index="' + soy.$$escapeHtml(prevStartIndex__soy15) + '" class="icon icon-previous" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8,lastPage__soy7 + 1)) + '"><span>&lt;&lt; ' + soy.$$escapeHtml("Previous") + '</span></a>' : '') + JIRA.Templates.IssueNavTable.numberLinksLogicBranch({startPage: pageNumber__soy8 - Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), endPage: pageNumber__soy8 + Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), lastPage: lastPage__soy7, urlFragment: urlFragment__soy9, currentPage: pageNumber__soy8 + 1, maxPagesDisplayed: MAX_PAGES_DISPLAYED__soy6, pageSize: opt_data.pageSize, displayableTotal: opt_data.displayableTotal});
  var nextStartIndex__soy37 = Math.min(opt_data.startIndex + opt_data.pageSize, opt_data.displayableTotal);
  output += ((nextStartIndex__soy37 < opt_data.displayableTotal) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(nextStartIndex__soy37) + '" data-start-index="' + soy.$$escapeHtml(nextStartIndex__soy37) + '" class="icon icon-next" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8 + 2,lastPage__soy7 + 1)) + '"><span>' + soy.$$escapeHtml("Next") + ' &gt;&gt;</span></a>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.pagination.soyTemplateName = 'JIRA.Templates.IssueNavTable.pagination';
}


JIRA.Templates.IssueNavTable.numberLinksLogicBranch = function(opt_data, opt_ignored) {
  return '' + ((opt_data.lastPage < opt_data.maxPagesDisplayed) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.lastPage})) : (opt_data.startPage < 0) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.endPage - opt_data.startPage})) : (opt_data.endPage > opt_data.lastPage) ? JIRA.Templates.IssueNavTable.numberLinks(soy.$$augmentMap(opt_data, {startPage: opt_data.startPage - (opt_data.endPage - opt_data.lastPage), endPage: opt_data.lastPage})) : JIRA.Templates.IssueNavTable.numberLinks(opt_data));
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.numberLinksLogicBranch.soyTemplateName = 'JIRA.Templates.IssueNavTable.numberLinksLogicBranch';
}


JIRA.Templates.IssueNavTable.numberLinks = function(opt_data, opt_ignored) {
  var output = '';
  var size__soy72 = opt_data.endPage - opt_data.startPage + 1;
  if (size__soy72 > 1) {
    var iLimit75 = Math.round(size__soy72);
    for (var i75 = 0; i75 < iLimit75; i75++) {
      var pageIndex__soy76 = i75 + opt_data.startPage;
      var pageNumber__soy77 = pageIndex__soy76 + 1;
      var pageStartIndex__soy78 = pageIndex__soy76 * opt_data.pageSize;
      var pageEndIndex__soy79 = Math.min(pageStartIndex__soy78 + opt_data.pageSize, opt_data.displayableTotal);
      var pageBoundaries__soy80 = '' + soy.$$escapeHtml(AJS.format("Issues {0} - {1}",pageStartIndex__soy78 + 1,pageEndIndex__soy79));
      output += ' ' + ((pageNumber__soy77 == opt_data.currentPage) ? '<strong title="' + soy.$$escapeHtml(pageBoundaries__soy80) + '">' + soy.$$escapeHtml(pageNumber__soy77) + '</strong>' : '<a href="' + soy.$$escapeHtml(opt_data.urlFragment) + soy.$$escapeHtml(pageStartIndex__soy78) + '" data-page="' + soy.$$escapeHtml(pageNumber__soy77) + '" data-start-index="' + soy.$$escapeHtml(pageStartIndex__soy78) + '" title="' + soy.$$escapeHtml(pageBoundaries__soy80) + '">' + soy.$$escapeHtml(pageNumber__soy77) + '</a>');
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.numberLinks.soyTemplateName = 'JIRA.Templates.IssueNavTable.numberLinks';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/templates/issuenav-table.soy' */
// This file was automatically generated from issuenav-table.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavTable.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavTable == 'undefined') { JIRA.Templates.IssueNavTable = {}; }


JIRA.Templates.IssueNavTable.structure = function(opt_data, opt_ignored) {
  return '<div class="list-view"><div class="aui-group aui-group-split issue-table-info-bar"><div class="aui-item"><div class="results-count-top"></div><div class="refresh-table-top"></div></div><div class="aui-item"><div class="column-picker-trigger-container"></div></div></div><div class="issue-table-container"></div><div class="end-of-stable-message"></div><div class="aui-group aui-group-split count-pagination"><div class="aui-item"><div class="results-count-bottom"></div><div class="refresh-table-bottom"></div></div><div class="aui-item"><div class="pagination"></div></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.structure.soyTemplateName = 'JIRA.Templates.IssueNavTable.structure';
}


JIRA.Templates.IssueNavTable.noResults = function(opt_data, opt_ignored) {
  return '<div class="jira-adbox jira-adbox-medium no-results ' + soy.$$escapeHtml(opt_data.cssClass) + '"><h3>' + soy.$$filterNoAutoescape(opt_data.message) + '</h3>' + ((opt_data.hint) ? '<p class="no-results-hint">' + soy.$$filterNoAutoescape(opt_data.hint) + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.noResults.soyTemplateName = 'JIRA.Templates.IssueNavTable.noResults';
}


JIRA.Templates.IssueNavTable.listOptions = function(opt_data, opt_ignored) {
  var output = '<div class="aui-list">';
  var groupList20 = opt_data.groups;
  var groupListLen20 = groupList20.length;
  for (var groupIndex20 = 0; groupIndex20 < groupListLen20; groupIndex20++) {
    var groupData20 = groupList20[groupIndex20];
    output += ((groupData20.label) ? '<h5>' + soy.$$escapeHtml(groupData20.label) + '</h5>' : '') + '<ul ' + ((groupData20.id) ? 'id="' + soy.$$escapeHtml(groupData20.id) + '"' : '') + ' class="aui-list-section' + ((groupIndex20 == 0) ? ' aui-first' : '') + ((groupIndex20 == groupListLen20 - 1) ? ' aui-last' : '') + '">';
    var itemList40 = groupData20.items;
    var itemListLen40 = itemList40.length;
    for (var itemIndex40 = 0; itemIndex40 < itemListLen40; itemIndex40++) {
      var itemData40 = itemList40[itemIndex40];
      output += '<li class="aui-list-item"><a class="aui-list-item-link" ' + ((itemData40.id) ? 'id="' + soy.$$escapeHtml(itemData40.id) + '"' : '') + ' ' + ((itemData40.rel) ? 'rel="' + soy.$$escapeHtml(itemData40.rel) + '"' : '') + ' href="' + ((! itemData40.relativeLink) ? soy.$$escapeHtml("/jira") : '') + soy.$$escapeHtml(itemData40.link) + '" ' + ((itemData40.title) ? 'title="' + soy.$$escapeHtml(itemData40.title) + '"' : '') + '>' + soy.$$escapeHtml(itemData40.label) + '</a></li>';
    }
    output += '</ul>';
  }
  output += '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.listOptions.soyTemplateName = 'JIRA.Templates.IssueNavTable.listOptions';
}


JIRA.Templates.IssueNavTable.views = function(opt_data, opt_ignored) {
  return '' + ((opt_data.sections.issue && opt_data.sections.issue.length > 0) ? '<div class="issue-panel aui-dropdown2-section">' + JIRA.Templates.IssueNavTable.listOptions({groups: opt_data.sections.issue}) + '</div>' : '') + ((opt_data.sections.filter && opt_data.sections.filter.length > 0) ? '<div class="filter-panel aui-dropdown2-section">' + JIRA.Templates.IssueNavTable.listOptions({groups: opt_data.sections.filter}) + '</div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.views.soyTemplateName = 'JIRA.Templates.IssueNavTable.views';
}


JIRA.Templates.IssueNavTable.tools = function(opt_data, opt_ignored) {
  return '' + JIRA.Templates.IssueNavTable.listOptions(opt_data);
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.tools.soyTemplateName = 'JIRA.Templates.IssueNavTable.tools';
}


JIRA.Templates.IssueNavTable.inaccessibleIssueRow = function(opt_data, opt_ignored) {
  return '<tr class="issuerow inaccessible-issue" rel="' + soy.$$escapeHtml(opt_data.issueID) + '"><td class="nav" colspan="' + soy.$$escapeHtml(opt_data.columnCount) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.inaccessibleIssueRow.soyTemplateName = 'JIRA.Templates.IssueNavTable.inaccessibleIssueRow';
}


JIRA.Templates.IssueNavTable.headerSortIcon = function(opt_data, opt_ignored) {
  return '<span class="aui-icon aui-icon-small aui-iconfont-' + ((opt_data.order == 'ASC') ? 'up' : 'down') + ' issuetable-header-sort-icon"></span>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavTable.headerSortIcon.soyTemplateName = 'JIRA.Templates.IssueNavTable.headerSortIcon';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/EmptyResults.js' */
(function() {
    "use strict";
    AJS.namespace("JIRA.Components.IssueTable.Views.EmptyResults");

    /**
     * @class JIRA.Components.IssueTable.Views.EmptyResults
     *
     * Renders a message that tells the user there are no issues, with an optional link to create an issue
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
     */
    JIRA.Components.IssueTable.Views.EmptyResults = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNavTable.noResults,

        serializeData: function() {
            var message;
            var hint;
            var cssClass;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
            } else if (this.options.jiraHasIssues === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
            }

            return {
                message: message,
                hint: hint,
                cssClass: cssClass
            };
        },

        onRender: function() {
            this.$el.addClass("empty-results");

            var $links = this.$('.no-results-hint a');
            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
            } else {
                $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
            }

            this.hidePending();
        },

        showPending: function() {
            this.$el.addClass('pending');
        },

        hidePending: function() {
            this.$el.removeClass("pending");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/EndOfStableMessage.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.EndOfStableMessage");

    /**
     * @class JIRA.Components.IssueTable.Views.EndOfStableMessage
     *
     * Renders the end of stable message.
     *
     * @extends JIRA.Marionette.ItemView
     *
     * //TODO: This logic for deciding to show this message or not, can be moved to the controller.
     *
     * @param {object} options Options
     * @param {number} options.total Number of issues in this search
     * @param {number} options.displayableTotal Number of issues than can be displayed in a stable search
     * @param {number} options.pageNumber Number of the current page
     * @param {number} options.numberOfPages Total number of pages in the search results
     */
    JIRA.Components.IssueNavigator.Views.EndOfStableMessage = JIRA.Marionette.ItemView.extend({
        className: "end-of-stable-message",

        serializeData: function() {
            return this.options;
        },

        getTemplate: function() {
            return (this.shouldRender) ? JIRA.Templates.IssueNav.endOfStableMessage : jQuery.noop;
        },

        onBeforeRender: function() {
            this.shouldRender = this._hasMoreIssues() && this._onLastPage();
        },

        onRender: function() {
            if (this.shouldRender) {
                this.$el.addClass("visible");
            } else {
                this.$el.removeClass("visible");
            }
        },

        _hasMoreIssues: function() {
            return (this.options.total - this.options.displayableTotal) !== 0;
        },

        _onLastPage: function() {
            return this.options.pageNumber === this.options.numberOfPages;
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/IssueTable.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Views.IssueTable");

    /**
     * @class JIRA.Components.IssueTable.Views.IssueTable
     *
     * A table of issues.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.IssueTable.Views.IssueTable = JIRA.Marionette.ItemView.extend({

        /**
         * @event columnsChanged
         * When the order of the columns has changed
         */

        /**
         * @event highlightIssue
         * When the user wants to highlight an issue
         */

        /**
         * @event sort
         * When the user clicks on the column's header
         */

        events: {
            "blur .hidden-link": function(e) {
                jQuery(e.target).attr("tabIndex", -1);
            },
            "click tr.issuerow": function(e) {
                var row = jQuery(e.target).closest(".issuerow");
                var issueId = Number(row.attr("rel"));
                this.trigger("highlightIssue", issueId);
            },
            "click .sortable": function(e) {
                e.preventDefault();
                this.trigger("sort", jQuery(e.currentTarget).data("id"));
            }
        },

        inaccessibleIssueRowTemplate: JIRA.Templates.IssueNavTable.inaccessibleIssueRow,

        /**
         *
         * @param {object} options Configuration object
         * @param {jQuery} options.resultsTable Server-side rendered table with the results
         * @param {Object} [options.sortOptions] State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         */
        initialize: function(options) {
            this.resultsTable = options.resultsTable;
            this.sortOptions = options.sortOptions || {};
        },

        /**
         * Render the table of issues.
         *
         * @returns {JIRA.Components.IssueTable.Views.IssueTable} <tt>this</tt>
         */
        render: function() {
            this.triggerMethod("before:render", this);
            var table = jQuery(this.resultsTable)[0];
            this.$el.empty().append(table);
            this.triggerMethod("render", this);
            return this;
        },

        onRender: function() {
            this._decorateTableHeaderWithSortOptions();
            this._addDraggable();
            this._removeEmptyTextNodes();
        },

        onClose: function() {
            this._removeDraggable();
        },

        /**
         * Adds header decorations for sorted column.
         */
        _decorateTableHeaderWithSortOptions: function() {
            var $sortableColumns = this.$el.find('.rowHeader .sortable');
            $sortableColumns.each(function() {
                this.onclick = null;
            });

            var sortOptions = this.sortOptions;
            if (sortOptions.fieldId) {

                // Locate the element which should be decorated
                var $sortEl = $sortableColumns.filter(function() {
                    return this.getAttribute("data-id") === sortOptions.fieldId;
                });

                // If the sorting element is not already decorated
                if ($sortEl.size() && !$sortEl.hasClass("descending") && !$sortEl.hasClass("ascending")) {

                    // Clean any header with sort-related classes
                    $sortableColumns
                        .removeClass("descending ascending active")
                        .addClass("colHeaderLink");

                    // Remove any sort icons
                    $sortableColumns.find(".issuetable-header-sort-icon").remove();

                    // Decorate the element as sorted
                    var direction = sortOptions.order === "DESC" ? "descending" : "ascending";
                    $sortEl.removeClass('colHeaderLink').addClass('active ' + direction);
                    $sortEl.append(JIRA.Templates.IssueNavTable.headerSortIcon({
                        order: sortOptions.order
                    }));
                }
            }
        },

        _addDraggable: function() {
            this.$("#issuetable").dragtable({
                maxMovingRows: 1,
                containment: 'body',
                axis: false,
                revert: false,
                clickDelay: 250,
                tolerance: "intersect",
                dragaccept: ":not(.headerrow-actions)",
                persistState: _.bind(this._saveColumns, this)
            });
        },

        _removeDraggable: function() {
            this.$("#issuetable").dragtable("destroy");
        },

        /**
         * Fix the issue table element so it displays correctly in IE9.
         *
         * Cells can become misaligned in IE9 if the table's markup contains whitespace.
         * Only affects IE9. IE10 and IE11 are okay.
         */
        _removeEmptyTextNodes: function() {
            this.$el.find("table, tbody, thead, tr").contents().filter(function() {
                return this.nodeType === 3; // Node.TEXT_NODE
            }).remove();
        },

        _saveColumns: function() {
            var cols = [];
            this.$("#issuetable").find('th').each(function() {
                var id = jQuery(this).data('id');
                if (_.isNotBlank(id)) {
                    cols.push(id);
                }
            });
            this.trigger("columnsChanged", cols);
        },

        /**
         * Highlight an issue and scroll it into view.
         *
         * Triggers a "highlightIssue" event, passing the issue's ID.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function(issueId, focus) {
            var newRow = this._getIssueRow(issueId);
            var oldRow = this.$(".focused");

            oldRow.removeClass("focused");
            newRow.addClass("focused");

            if (newRow.length && newRow.closest(document.body).length) {
                // Focus the row so you can tab through its links.
                if (focus !== false) {
                    newRow.find(".hidden-link").removeAttr("tabIndex").focus();
                }
                newRow.scrollIntoView({marginBottom: 50});
            }
        },

        /**
         * Gets the row element that represents a particular issue
         *
         * @param {number} issueId ID of the issue to look for
         * @param {jQuery} [container=this.$el] Table that contain the issue's row
         * @returns {jQuery} The row element
         */
        _getIssueRow: function(issueId, container) {
            container = container || this.$el;
            return container.find(".issuerow").filter(function() {
                return parseInt(this.getAttribute("rel"), 10) === issueId;
            });
        },

        /**
         * Replaces an inaccessible issue in the table with a message.
         *
         * @param {number} issueId ID of the issue to replace
         */
        markIssueAsInaccessible: function(issueId) {
            this._getIssueRow(issueId).replaceWith(this.inaccessibleIssueRowTemplate({
                columnCount: this.$el.find("thead > tr > th").length,
                issueID: issueId
            }));
        },

        /**
         * Updates an issue in the table with a new row and highlights it.
         *
         * @param {number} issueId ID of the issue to update
         * @param {jQuery} newTable Server rendered table with the new data
         */
        updateIssue: function(issueId, newTable) {
            var $newRow = this._getIssueRow(issueId, jQuery(newTable));
            this._getIssueRow(issueId).replaceWith($newRow);

            this.highlightIssue(issueId);
            this.trigger("issueRowUpdated", $newRow);
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/IssueTableLayout.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Views.IssueTableLayout");

    JIRA.Components.IssueTable.Views.IssueTableLayout = JIRA.Marionette.Layout.extend({
        template: JIRA.Templates.IssueNavTable.structure,

        regions: {
            pagination: {
                selector: ".pagination",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            table: ".issue-table-container",
            resultsCountTop: {
                selector: ".results-count-top",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            refreshResultsTop: {
                selector: ".refresh-table-top",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            resultsCountBottom: {
                selector: ".results-count-bottom",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            refreshResultsBottom: {
                selector: ".refresh-table-bottom",
                regionType: JIRA.Marionette.ReplaceRegion
            },
            endOfStableMessage: {
                selector: ".end-of-stable-message",
                regionType: JIRA.Marionette.ReplaceRegion
            }
        },

        onRender: function() {
            this.hidePending();
        },

        showPending: function() {
            this.$el.addClass('pending');
        },

        hidePending: function() {
            this.$el.removeClass("pending");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/Pagination.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.Pagination");

    /**
     * @class JIRA.Components.IssueNavigator.Views.Pagination
     *
     * This view renders a set of pagination links
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {string} options.currentSearch Search that produced these search results
     * @param {string} [options.currentSearch.jql] JQL that produced these search results
     * @param {string} [options.currentSearch.filterId] ID of the filter used for this search
     * @param {number} options.pageSize Size of each page
     * @param {number} options.startIndex Index of first issue displayed in the table
     * @param {number} options.total Number of issues in this search
     */
    JIRA.Components.IssueNavigator.Views.Pagination = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNavTable.pagination,

        events: {
            /**
             * @event goToPage
             * When the user clicks in a pagination link
             */
            "simpleClick a[data-start-index]": function(e) {
                e.preventDefault();
                var val = e.target.getAttribute("data-start-index");
                this.trigger("goToPage", parseInt(val, 10));
            }
        },

        serializeData: function() {
            return {
                startIndex: this.options.startIndex,
                pageSize: this.options.pageSize,
                searchQuery: this._getPagingUri(),
                displayableTotal: this.options.total
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        /**
         * Construct a URL for an issue table pagination link.
         *
         * @return {string} the URL.
         */
        _getPagingUri: function() {
            return JIRA.Issues.URLSerializer.getURLFromState({
                selectedIssueKey: null,
                jql: this.options.currentSearch.jql,
                filter: this.options.currentSearch.filterId
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/RefreshResults.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.RefreshResults");

    /**
     * @class JIRA.Components.IssueNavigator.Views.RefreshResults
     *
     * This view renders a 'refresh' button.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.IssueNavigator.Views.RefreshResults = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNav.refreshResults,
        triggers: {
            /**
             * @event refresh
             * When the user clicks the refresh button
             */
            "click": "refresh"
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/views/ResultsCount.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.IssueNavigator.Views.ResultsCount");

    /**
     * @class JIRA.Components.IssueNavigator.Views.ResultsCount
     *
     * This view renders the count of results in a search (e.g "1-20 of 42")
     *
     * @extends JIRA.Marionette.ItemView
     *
     * @param {object} options Options
     * @param {number} options.total Number of issues in this search
     * @param {number} options.startIndex Index of first issue displayed in the table
     * @param {number} options.pageSize Size of each page
     */
    JIRA.Components.IssueNavigator.Views.ResultsCount = JIRA.Marionette.ItemView.extend({
        template: JIRA.Templates.IssueNav.resultsCount,

        serializeData: function() {
            var total = this.options.total;
            var start = this.options.startIndex + 1;
            var end = this.options.startIndex + this.options.pageSize;
            return {
                start: start,
                end: Math.min(end, total),
                total: total
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/issuetable/controllers/IssueTable.js' */
(function () {
    "use strict";

    AJS.namespace("JIRA.Components.IssueTable.Controllers.IssueTable");

    /**
     * @class JIRA.Components.IssueTable.Controllers.IssueTable
     *
     * Controller for the IssueTable
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.IssueTable.Controllers.IssueTable = JIRA.Marionette.Controller.extend({
        /**
         * @event columnsChanged
         * When the order of the columns has changed
         */

        /**
         * @event goToPage
         * When the user wants to load another page by clicking on the pager
         */

        /**
         * @event highlightIssue
         * When an issue has been highlighted.
         */

        /**
         * @event issueRowUpdated
         * When a issue in the table has been updated with new information
         */

        /**
         * @event refresh
         * When the user wants to refresh the search by clicking on the 'refresh' icon
         */

        /**
         * @event renderTable
         * When the table with results and the associated internal views have been rendered
         */

        /**
         * @event sort
         * When the results has been sorted by clicking on a column's header
         */

        /**
         * @param {Object} options Initialization options
         * @param {Element} options.el Element where the table should be rendered
         */
        initialize: function (options) {
            this.$el = jQuery(options.el);
        },

        /**
         * @returns {JIRA.Components.IssueTable.Views.IssueTableLayout}
         */
        _createMainView: function () {
            return new JIRA.Components.IssueTable.Views.IssueTableLayout();
        },

        /**
         * @param {jQuery} resultsTable Server-side rendered table with the results
         * @param {Object} sortOptions State of the current sort options
         * @param {string} sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @returns {JIRA.Components.IssueTable.Views.IssueTable}
         */
        _createTableView: function (resultsTable, sortOptions) {
            var table = new JIRA.Components.IssueTable.Views.IssueTable({
                resultsTable: resultsTable,
                sortOptions: sortOptions
            });
            this.listenAndRethrow(table, "columnsChanged");
            this.listenAndRethrow(table, "highlightIssue");
            this.listenAndRethrow(table, "issueRowUpdated");
            this.listenAndRethrow(table, "sort");
            return table;
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.startIndex Index of first issue displayed in the table
         * @param {number} data.pageSize Size of each page
         * @returns {JIRA.Components.IssueNavigator.Views.ResultsCount}
         * @private
         */
        _createResultsCount: function (data) {
            return new JIRA.Components.IssueNavigator.Views.ResultsCount(data);
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.startIndex Index of first issue displayed in the table
         * @param {number} data.pageSize Size of each page
         * @param {string} data.currentSearch JQL that produced this search results
         * @returns {JIRA.Components.IssueNavigator.Views.Pagination}
         * @private
         */
        _createPagination: function (data) {
            var pagination = new JIRA.Components.IssueNavigator.Views.Pagination(data);
            this.listenAndRethrow(pagination, "goToPage");
            return pagination;
        },

        /**
         * @returns {JIRA.Components.IssueNavigator.Views.RefreshResults}
         */
        _createRefreshResults: function () {
            var refreshResults = new JIRA.Components.IssueNavigator.Views.RefreshResults();
            this.listenAndRethrow(refreshResults, "refresh");
            return refreshResults;
        },

        /**
         * @param {object} data Data to use in this view
         * @param {number} data.total Number of issues in this search
         * @param {number} data.displayableTotal Number of issues than can be displayed in a stable search
         * @param {number} data.pageNumber Number of the current page
         * @param {number} data.numberOfPages Total number of pages in the search results
         * @returns {JIRA.Components.IssueNavigator.Views.EndOfStableMessage}
         */
        _createEndOfStableMessage: function (data) {
            return new JIRA.Components.IssueNavigator.Views.EndOfStableMessage(data);
        },

        /**
         * @param {object} data Data to use in this view
         * @param {boolean} data.jiraHasIssues Whether there are issues created in this JIRA instance
         * @returns {JIRA.Components.IssueTable.Views.EmptyResults}
         */
        _createEmptyResultsView: function (data) {
            return new JIRA.Components.IssueTable.Views.EmptyResults(data);
        },

        _layoutIsRendered: function () {
            return this.view && this.view instanceof JIRA.Components.IssueTable.Views.IssueTableLayout;
        },

        close: function () {
            if (this.view) {
                this.view.close();
                delete this.view;
            }
        },

        /**
         * @param {object} options Options
         * @param {jQuery} options.table Server-side rendered table with the results
         * @param {Object} options.sortOptions State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @param {number} options.totalIssues Number of issues in this search
         * @param {number} options.displayableTotal Number of issues than can be displayed in a stable search
         * @param {number} options.pageNumber Number of the current page
         * @param {number} options.numberOfPages Total number of pages in the search results
         * @param {number} options.startIndex Index of first issue displayed in the table
         * @param {number} options.pageSize Size of each page
         * @param {string} options.currentSearch JQL that produced this search results
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         * @param {boolean} options.hasIssues Whether there search result has issues
         */
        show: function (options) {
            if (options.hasIssues) {
                this._showTable(options);
            } else {
                this._showEmptyResults(options);
            }
        },

        /**
         * @param {object} options Options
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         */
        showErrorMessage: function (options) {
            this._showEmptyResults(options);
        },

        /**
         * Puts the view in the pending state (i.e. dims the table). This method also temporarily disables
         * the column reordering feature.
         */
        showPending: function () {
            if (this.view) {
                this.view.showPending();
                if (this._layoutIsRendered()) {
                    this.view.table.currentView._removeDraggable();
                }
            }
        },

        /**
         * @param {object} options Options
         * @param {jQuery} options.table Server-side rendered table with the results
         * @param {Object} options.sortOptions State of the current sort options
         * @param {string} options.sortOptions.fieldId ID of the field used for sorting the results
         * @param {string} options.sortOptions.order Direction used for the sorting ("DESC", "ASC")
         * @param {number} options.totalIssues Number of issues in this search
         * @param {number} options.totalDisplayableIssues Number of issues than can be displayed in a stable search
         * @param {number} options.pageNumber Number of the current page
         * @param {number} options.numberOfPages Total number of pages in the search results
         * @param {number} options.startIndex Index of first issue displayed in the table
         * @param {number} options.pageSize Size of each page
         * @param {string} options.currentSearch JQL that produced this search results
         */
        _showTable: function (options) {
            options = options || {};

            this.close();
            this.view = this._createMainView();
            var table = this._createTableView(options.table, options.sortOptions);
            var resultsCountTop = this._createResultsCount({
                total: options.totalIssues,
                startIndex: options.startIndex,
                pageSize: options.pageSize
            });
            var resultsCountBottom = this._createResultsCount({
                total: options.totalIssues,
                startIndex: options.startIndex,
                pageSize: options.pageSize
            });
            var pagination = this._createPagination({
                startIndex: options.startIndex,
                pageSize: options.pageSize,
                total: options.totalIssues,
                currentSearch: options.currentSearch
            });
            var endOfStableMessage = this._createEndOfStableMessage({
                total: options.totalIssues,
                displayableTotal: options.totalDisplayableIssues,
                pageNumber: options.pageNumber,
                numberOfPages: options.numberOfPages
            });

            this.listenTo(this.view, {
                "render": function () {
                    this.view.table.show(table);
                    this.view.resultsCountTop.show(resultsCountTop);
                    this.view.resultsCountBottom.show(resultsCountBottom);
                    this.view.pagination.show(pagination);
                    this.view.refreshResultsTop.show(this._createRefreshResults());
                    this.view.refreshResultsBottom.show(this._createRefreshResults());
                    this.view.endOfStableMessage.show(endOfStableMessage);
                }
            });

            this.view.render();
            this.$el.empty().append(this.view.$el);
            this.trigger("renderTable", this.$el);
        },

        /**
         * @param {object} options Options
         * @param {boolean} options.jiraHasIssues Whether there are issues created in this JIRA instance
         */
        _showEmptyResults: function (options) {
            this.close();
            this.view = this._createEmptyResultsView(options);
            this.view.render();
            this.$el.empty().append(this.view.$el);
            this.trigger("renderEmpty", this.$el);
        },

        /**
         * Highlight an issue in the table.
         *
         * @param {number} issueId The ID of the issue to highlight.
         * @param {boolean} [focus=true] Whether the highlighted issue should have the focus
         */
        highlightIssue: function (issueId, focus) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.highlightIssue(issueId, focus);
            }
        },

        /**
         * Marks an issue as inaccessible
         *
         * @param {number} issueId ID of the issue to mark
         */
        markIssueAsInaccessible: function (issueId) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.markIssueAsInaccessible(issueId);
            }
        },

        /**
         * Updates an issue in the table with a new row
         *
         * @param {number} issueId ID of the issue to update
         * @param {jQuery} newTable Server rendered table with the new data
         */
        updateIssue: function (issueId, newTable) {
            if (this._layoutIsRendered()) {
                this.view.table.currentView.updateIssue(issueId, newTable);
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuetable-component', location = 'content/js/components/search/Search.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.SearchService");

    /**
     * @class JIRA.Components.SearchService
     *
     * This service encapsulates all the search related stuff
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.SearchService = JIRA.Marionette.Controller.extend({
        /**
         * @event issueUpdated
         * When an issue has been updated
         */

        /**
         * @event search
         * When an new search has been done
         */

        /**
         * @event before:search
         * Before doing a new search
         */

        /**
         * @event error:search
         * When a new search has been done but it thrown an error
         */

        /**
         * @event issueHighlighted
         * When an issue has been marked as highlighted in the internal model
         */

        /**
         * @event selectedIssueChanged
         * When an issue has been marked as selected in the internal model
         */

        /**
         * @param {Object} options
         * @param {JIRA.Issues.SearchModule} options.searchModule
         * @param {JIRA.Issues.SearchResults} options.searchResults
         * @param {JIRA.Issues.ColumnConfigModel} options.columnConfig
         */
        initialize: function(options) {
            this.searchModule = options.searchModule;
            this.searchResults = options.searchResults;
            this.columnConfig = options.columnConfig;

            _.bindAll(this, "_onIssueUpdated", "_onHighlightedIssueChange", "_onSelectedIssueChange", "_onBeforeSearch");

            this.listenTo(this.searchResults, "change:resultsId change:startIndex stableUpdate issueDeleted", function() {
                this._doSearch();
            });

            // These are *not* regular Backbone events, we can't use listenTo.
            this.searchResults.onIssueUpdated(this._onIssueUpdated);
            this.searchResults.onHighlightedIssueChange(this._onHighlightedIssueChange);
            this.searchResults.onSelectedIssueChange(this._onSelectedIssueChange);

            this.searchModule.onBeforeSearch(this._onBeforeSearch);
        },

        _onSelectedIssueChange: function(issue) {
            this.trigger("selectedIssueChanged", issue, this.searchResults.getHighlightedIssue());
        },

        _onIssueUpdated: function(issueId, entity, reason) {
            this.trigger("issueUpdated", issueId, entity, reason);
        },

        _onHighlightedIssueChange: function(issue) {
            this.trigger("issueHighlighted", issue.getId());
        },

        _onBeforeSearch: function() {
            this.trigger("before:search");
        },

        close: function() {
            this.stopListening();
            this.searchResults.offIssueUpdated(this._onIssueUpdated);
            this.searchResults.offHighlightedIssueChange(this._onHighlightedIssueChange);
        },

        /**
         * Asks the SearchResults object to do a new search with the parameters already contained
         * in the SearchModule
         * @private
         */
        _doSearch: function() {
            this.searchInProgress = true;

            var filterId = this.searchModule.getFilterId();
            var isSystemFilter = filterId < 0;
            filterId = (isSystemFilter || _.isNull(filterId)) ? undefined : filterId;

            var LatestSearchStore = require("jira/components/search/latestStorage");
            var search = {
                filter: filterId,
                jql: this.searchModule.getEffectiveJql()
            };
            LatestSearchStore.save(search);

            this.searchResults.getResultsForPage({
                jql: this.searchModule.getEffectiveJql(),
                filterId: filterId
            })
                .always(_.bind(function() {
                    this.searchInProgress = false;
                }, this))
                .done(_.bind(function(table) {
                    if (!this.searchResults.hasHighlightedIssue()) {
                        this.searchResults.highlightFirstInPage();
                    }
                    this.trigger("search", table, this.searchResults);
                }, this))
                .fail(_.bind(function() {
                    this.trigger("error:search");
                }, this));
        },

        /**
         * Loads a page of the current search results. This code expects the issue position,
         * not the page number. Example: using a pageSize of 25, passing startIndex=50 will load the
         * issues #50 to #74.
         *
         * This method will do nothing if a search is already in progress
         *
         * @param {number} startIndex Position of the issue in the page
         */
        goToPage: function(startIndex) {
            if (this.searchInProgress) return;
            this._onBeforeSearch();
            this.searchResults.goToPage(startIndex);
        },

        /**
         * Sorts the current search results by a field.
         *
         * This method will do nothing if a search is already in progress
         *
         * @param {string} fieldId ID of the field to sort by
         */
        sort: function(fieldId) {
            if (this.searchInProgress) return;

            var allSorts = this.searchModule.getResults().getColumnSortJql();
            var sortJql = allSorts[fieldId];
            if (sortJql) {
                this.searchModule.doSort(sortJql);
            }
        },

        /**
         * Re-runs the current search.
         *
         * This method will do nothing if a search is already in progress
         */
        runCurrentSearch: function() {
            if (this.searchInProgress) return;

            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh");
                this.searchModule.refresh();
            }
        },

        /**
         * This method updates the existing set of results (aka Stable Search). It does not re-run the search again, so the
         * list of Issues will remain the same.
         *
         * This method will do nothing if a search is already in progress.
         */
        updateExitingResults: function() {
            if (this.searchInProgress) return;

            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh");
                this._doSearch();
            }
        },

        highlightIssue: function(issueId) {
            this.searchResults.highlightIssueById(issueId);
        },

        getPager: function() {
            return this.searchResults.getPager();
        },

        selectNextIssue: function() {
            this.searchResults.highlightNextIssue();
            if (this.searchResults.hasSelectedIssue()) {
                require('jira/issues/navigator/metrics').notifyIssueView();
                this.searchResults.selectNextIssue();
            }
        },

        selectPreviousIssue: function () {
            this.searchResults.highlightPrevIssue();
            if (this.searchResults.hasSelectedIssue()) {
                require('jira/issues/navigator/metrics').notifyIssueView();
                this.searchResults.selectPrevIssue();
            }
        },

        unselectIssue: function() {
            this.searchResults.unselectIssue();
        },

        hasSelectedIssue: function() {
            return this.searchResults.hasSelectedIssue();
        },

        getHighlightedIssue: function() {
            return this.searchResults.getHighlightedIssue().id;
        }

    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/templates/issuenav-searchheader.soy' */
// This file was automatically generated from issuenav-searchheader.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavSearchHeader.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavSearchHeader == 'undefined') { JIRA.Templates.IssueNavSearchHeader = {}; }


JIRA.Templates.IssueNavSearchHeader.layoutSwitcher = function(opt_data, opt_ignored) {
  var output = '<div class="aui-buttons"><button id="layout-switcher-button" class="aui-button aui-button-light drop-arrow js-default-dropdown" type="button"><span class="aui-icon aui-icon-small ' + soy.$$escapeHtmlAttribute(opt_data.activeLayout.iconClass) + '"></span></button><div class="aui-list hidden"><h5>' + soy.$$escapeHtml("Views") + '</h5><ul class="aui-list-section aui-first aui-last">';
  var layoutList8 = opt_data.layouts;
  var layoutListLen8 = layoutList8.length;
  for (var layoutIndex8 = 0; layoutIndex8 < layoutListLen8; layoutIndex8++) {
    var layoutData8 = layoutList8[layoutIndex8];
    output += '<li class="aui-list-item layout-switcher-item"><a href="#" class="aui-list-item-link" data-layout-key="' + soy.$$escapeHtmlAttribute(layoutData8.id) + '"><span class="aui-icon aui-icon-small ' + ((opt_data.activeLayout.id == layoutData8.id) ? 'aui-iconfont-success' : '') + '"></span>' + soy.$$escapeHtml(layoutData8.label) + '</a>';
  }
  output += '</ul></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavSearchHeader.layoutSwitcher.soyTemplateName = 'JIRA.Templates.IssueNavSearchHeader.layoutSwitcher';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/js/search/searchheader/LayoutSwitcherView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.LayoutSwitcherView");

    /**
     * The layout switcher control.
     */
    JIRA.Issues.LayoutSwitcherView = JIRA.Issues.BaseView.extend({
        template: JIRA.Templates.IssueNavSearchHeader.layoutSwitcher,

        /**
         * @param {object} options
         * @param {JIRA.Issues.SearchPageModule} options.searchPageModule
         */
        initialize: function(options) {
            _.bindAll(this, "_onLayoutSwitchClick");

            this.searchPageModule = options.searchPageModule;
            this.searchPageModule.on("change:currentLayout", this.render, this);
        },

        /**
         * @return {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        render: function() {
            this.$el.html(this.template({
                layouts: this.searchPageModule.getSortedLayouts(),
                activeLayout: this.searchPageModule.getActiveLayout()
            }));

            this._addLayoutSwitcherTooltip();

            // We can't use delegate events as the dropdown is appended to the body.
            this.$el.find(".aui-list-item-link").click(this._onLayoutSwitchClick);
            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$el, JIRA.CONTENT_ADDED_REASON.layoutSwitcherReady]);
            return this;
        },

        /**
         * @returns {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        enableLayoutSwitcher: function() {
            this.$el.find("#layout-switcher-button").removeClass("disabled").removeAttr('disabled');
            return this;
        },

        /**
         * @returns {JIRA.Issues.LayoutSwitcherView} <tt>this</tt>
         */
        disableLayoutSwitcher: function() {
            this.$el.find("#layout-switcher-button").addClass("disabled").attr('disabled', '');
            return this;
        },

        createHelptipForSwitchingToDetailView: function(weight) {
            var tip;
            if (this._shouldShowIntro() && this.$el.is(":visible")) {
                tip = new AJS.HelpTip({
                    id: "split-view-intro",
                    title: "Choose how you view issues",
                    url: AJS.Meta.get('issue-search-help-url'),
                    bodyHtml: "Switch between the details and list views to suit your preference.",
                    anchor: ".view-selector button",
                    isSequence: true,
                    weight: weight
                });
            }
            return tip;
        },

        _shouldShowIntro: function() {
            return this.searchPageModule.search.getResults().hasIssues();
        },

        /**
         * Adds a tooltip to the layout switcher button
         * @private
         */
        _addLayoutSwitcherTooltip: function() {
            function getTooltipMessage() {
                // If there is no shortcut for this action, just display the regular text. (i.e. without the 'Type X' part)
                var shortcut = AJS.KeyboardShortcut.getKeyboardShortcutKeys('switch.search.layouts');
                if (shortcut) {
                    return AJS.format("Change view (Type \'\'{0}\'\')", AJS.KeyboardShortcut.getKeyboardShortcutKeys('switch.search.layouts'));
                } else {
                    return "Change view";
                }
            }

            new JIRA.Issues.Tipsy({
                el: this.$el.find("#layout-switcher-button"),
                showCondition: ":not(.active)",
                tipsy: {
                    title: getTooltipMessage,
                    gravity: 'ne'
                }
            });
        },

        /**
         * Tell the <tt>SearchPageModule</tt> to change layout.
         * <p/>
         * Called when a layout button is clicked.
         *
         * @param {object} e The click event.
         * @param {object} [options] Options used in tests.
         *
         * @private
         */
        _onLayoutSwitchClick: function(e, options) {
            if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                // HACK: Hover intent has a strange bug that when we click the layout switcher it triggers a mouseleave event on the filters panel
                // To get around this, we disable it whilst we are transitioning to new layout.
                var layoutKey = AJS.$(e.target).closest("[data-layout-key]").data("layout-key");
                e.preventDefault();

                if (layoutKey === 'split-view') {
                    require('jira/issues/views/details/metrics').start();
                } else if (layoutKey === 'list-view') {
                    require('jira/issues/navigator/metrics').notifyIssueNavList();
                }

                this.searchPageModule.changeLayout(layoutKey, options);
            }
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-searchheader', location = 'content/js/search/searchheader/SearchHeaderModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.SearchHeaderModule");

    /**
     * Interface to the search header
     */
    JIRA.Issues.SearchHeaderModule = JIRA.Issues.BaseEvented.extend({

        initialize: function(options) {
            this._searchPageModule = options.searchPageModule;
        },

        registerSearch: function(search) {
            this._search = search;
        },

        createToolsView: function($toolsEl) {
            new JIRA.Issues.IssueTableHeaderOperationsView({
                el: $toolsEl,
                search: this._search,
                searchPageModule: this._searchPageModule
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/Filters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters");

    /**
     * @class JIRA.Components.Filters
     *
     * This class is the main entry point for the Filters component.
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters = JIRA.Marionette.Controller.extend({

        initialize: function(options) {
            this._initializeDialogController();
            this.searchPageModule = options.searchPageModule;

            this._initializeCollections(options);
            this._initializeSystemFiltersController();
            this._initializeFavouriteFiltersController();
            this._initializeFilterHeaderController();
        },

        _initializeCollections: function(options) {
            this.systemFiltersCollection = new JIRA.Components.Filters.Collections.SystemFilters(options.systemFilters);

            this.favouriteFiltersCollection = new JIRA.Components.Filters.Collections.FavouriteFilters([]);
            this.listenTo(this.favouriteFiltersCollection, {
                "change:favourite": function (filterModel, isFavourite) {
                    if (!isFavourite) {
                        this.favouriteFiltersCollection.remove(filterModel);
                    }
                },
                "remove": function(filterModel) {
                    this.trigger('filterUnfavourited', { filterId: filterModel.getId() });
                }
            });
        },

        _initializeDialogController: function() {
            this.dialogController = new JIRA.Components.Filters.Controllers.Dialog();

            this.listenTo(this.dialogController, "delete:success", function(filterModel) {
                this.favouriteFiltersCollection.remove(filterModel);
                // trigger a specific event when the filter is deleted, as this should update the search results page
                this.trigger('filterRemoved', { filterId: filterModel.getId() });

                JIRA.Messages.showSuccessMsg(
                    AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been deleted.", AJS.escapeHtml(filterModel.getName())),
                    JIRA.Issues.getDefaultMessageOptions()
                );

                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "delete:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "rename:success", function(filterModel) {
                JIRA.Messages.showSuccessMsg(
                    AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been renamed.", AJS.escapeHtml(filterModel.getName())),
                    JIRA.Issues.getDefaultMessageOptions()
                );

                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "rename:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "copy:success", function(newFilterModel) {
                this.trigger("newFilter", newFilterModel);
                this._addFavouriteFilter(newFilterModel);
                JIRA.trace("jira.filter.saved");
            }, this);

            this.listenTo(this.dialogController, "copy:error", function() {
                JIRA.trace("jira.filter.saved");
            });

            this.listenTo(this.dialogController, "saveas:success", function(newFilterModel) {
                this.trigger("newFilter", newFilterModel);
                this._addFavouriteFilter(newFilterModel);
                JIRA.trace("jira.filter.saved");
            }, this);

            this.listenTo(this.dialogController, "saveas:error", function() {
                JIRA.trace("jira.filter.saved");
            });

        },

        _initializeSystemFiltersController: function() {
            this.systemFiltersController = new JIRA.Components.Filters.Controllers.List({
                collection: this.systemFiltersCollection,
                className: "system-filters",
                errorMessage: "Failed to retrieve system filters from server.",
                loadingMessage: "Loading system filters...",
                emptyMessage: "There are no system filters.",
                loginMessage: AJS.format("You must be {0}logged in{1} to view system filters.", '<a class="login-link" href="' + JIRA.Issues.LoginUtils.redirectUrlToCurrent() + '">', '</a>')
            });

            this.systemFiltersController.on("selectFilter", function (filterModel) {
                this.headerController.closeDetails();
                this.trigger("filterSelected", filterModel.id);
            }, this);
        },

        _initializeFavouriteFiltersController: function() {
            this.favouriteFiltersController = new JIRA.Components.Filters.Controllers.ListWithActions({
                collection: this.favouriteFiltersCollection,
                className: "favourite-filters",
                title: "Favourite Filters",
                errorMessage: "Failed to retrieve favourite filters from server.",
                loadingMessage: "Loading favourite filters...",
                emptyMessage: "You don\'t have any favourite filters.",
                loginMessage: AJS.format("You must be {0}logged in{1} to view favourite filters.", '<a class="login-link" href="' + JIRA.Issues.LoginUtils.redirectUrlToCurrent() + '">', '</a>')
            });
            this.favouriteFiltersController.on("selectFilter", function(filterModel) {
                this.headerController.closeDetails();
                this.trigger("filterSelected", filterModel.id);
            }, this);
            this.favouriteFiltersController.on("deleteFilter", function(filterModel) {
                this.showDeleteDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("renameFilter", function(filterModel) {
                this.showRenameDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("copyFilter", function(filterModel) {
                this.showCopyDialog(filterModel.id);
            }, this);
            this.favouriteFiltersController.on("unfavouriteFilter", function(filterModel) {
                filterModel.saveFavourite(false);
            }, this);
            this.favouriteFiltersController.on("list:render", function() {
                this.trigger("list:render");
                JIRA.trace("jira.filter.favourites.render");
            }, this);
        },

        _initializeFilterHeaderController: function() {
            this.headerController = new JIRA.Components.Filters.Controllers.Header();

            this.listenTo(this.headerController, "saveAs", function(filterModel) {
                this.showSaveAsDialog(filterModel);
            });

            this.listenTo(this.headerController, "save", function(filterModel) {
                var filterName = AJS.escapeHtml(filterModel.getName());

                filterModel.saveFilter(this.searchPageModule.getEffectiveJql())
                    .done(_.bind(function() {
                        JIRA.Messages.showSuccessMsg(
                            AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e has been successfully saved.", filterName),
                            JIRA.Issues.getDefaultMessageOptions()
                        );

                        this.trigger("savedFilter", filterModel);
                    }, this))
                    .fail(function() {
                        JIRA.Messages.showErrorMsg(
                            AJS.format("The filter \u003cstrong\u003e{0}\u003c/strong\u003e could not be saved.", filterName),
                            JIRA.Issues.getDefaultMessageOptions()
                        );
                    });
            });

            this.listenTo(this.headerController, "discard", function() {
                this.trigger("filterDiscarded");
            });

            this.listenTo(this.headerController, "favourite", function(filterModel) {
                filterModel = this._addFavouriteFilter(filterModel);
                this.highlightFilter(filterModel);
                this.trigger("fitlerFavourited", filterModel);
            });
        },

        _addFavouriteFilter: function(filterModel) {
            var isFavourite = !!filterModel.getFavourite();
            var isInFavouriteCollection = !!this.favouriteFiltersCollection.get(filterModel.getId());

            if ( isFavourite && !isInFavouriteCollection) {
                this.favouriteFiltersCollection.add(filterModel);
            }

            return this.favouriteFiltersCollection.get(filterModel.getId());
        },

        getFilterByIdFromExistingCollections: function(filterId) {
            return this.systemFiltersCollection.get(filterId) || this.favouriteFiltersCollection.get(filterId);
        },
        
        getFilterById: function (filterId) {
            var filter = this.getFilterByIdFromExistingCollections(filterId);
            var deferred = new jQuery.Deferred();

            if (filter) {
                deferred.resolve(filter);
            } else {
                var model = new JIRA.Components.Filters.Models.Filter({ id: filterId });
                model.fetch({
                    success: _.bind(function() {
                        if (model.getFavourite()) {
                            this.favouriteFiltersCollection.add(model, {merge: true});

                            // We need to return the model in the collection, because 'add' will only merge the attributes,
                            // not the 'cid'. The 'cid' is used to identify the views associated with this model.
                            deferred.resolve(this.favouriteFiltersCollection.get(model.id));
                        } else if (model.getIsSystem()) {
                            this.systemFiltersCollection.add(model, {merge: true});
                            deferred.resolve(this.systemFiltersCollection.get(model.id));
                        } else {
                            deferred.resolve(model);
                        }
                    }, this),
                    error: function() {
                        model.setIsValid(false);
                        deferred.reject.apply(this, arguments);
                    }
                });
            }

            return deferred.promise();
        },

        showDeleteDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showDeleteDialog(filterModel);
            }, this));
        },

        showRenameDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showRenameDialog(filterModel);
            }, this));
        },

        showCopyDialog: function(filterId) {
            this.getFilterById(filterId).done(_.bind(function(filterModel) {
                this.dialogController.showCopyDialog(filterModel);
            }, this));
        },

        showSaveAsDialog: function(filterModel) {
            this.searchPageModule.getJqlDeferred()
                .done(_.bind(function(jql) {
                    this.dialogController.showSaveAsDialog(filterModel, jql);
                }, this));
        },

        showSystemFilters: function(el) {
            this.systemFiltersController.show(el);
        },

        showFavouriteFilters: function(el){
            this.favouriteFiltersController.show(el);
        },

        showFilterHeader: function(options) {
            this.headerController.show({
                el: options.el,
                model: options.model,
                isEdited: options.isEdited,
                isDirty: options.isDirty
            });
        },

        updateFilterHeader: function(options) {
            this.headerController.update({
                model: options.model,
                isEdited: options.isEdited || false,
                isDirty: options.isDirty || false
            });
        },

        highlightFilter: function(filterModel) {
            this.systemFiltersController.highlightFilter(filterModel);
            this.favouriteFiltersController.highlightFilter(filterModel);
        },

        markFilterHeaderAsInvalid: function() {
            this.headerController.markAsInvalid();
        },

        fetchSystemFilters: function() {
            return this.systemFiltersCollection.fetch();
        },

        fetchFavouriteFilters: function() {
            return this.favouriteFiltersCollection.fetch({reset: true});
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/Filter.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Models.Filter");

    /**
     * @class JIRA.Components.Filters.Models.Filter
     *
     * Represents a saved (normally favourite) filter, also known as a "Saved Search".
     *
     * @extends JIRA.Issues.Brace.Model
     */
    JIRA.Components.Filters.Models.Filter = JIRA.Issues.Brace.Model.extend({

        namedAttributes: [
            "id",
            "name",
            "description",
            "jql",
            "favourite",
            "isSystem",
            "sharePermissions",
            "subscriptions",
            "ownerUserName",
            "ownerDisplayName",
            "avatarUrl",
            "requiresLogin",
            "isValid"
        ],

        defaults: {
            isSystem: false,
            isValid: true
        },

        urlRoot: AJS.contextPath() + "/rest/api/2/filter/",

        getOwner: function () {
            return this.getOwnerDisplayName() || this.getOwnerUserName();
        },

        isFavouriteFilter: function () {
            return !this.getIsSystem() && !!this.getFavourite();
        },

        url: function() {
            return this.urlRoot + encodeURIComponent(this.id) + "?expand=subscriptions[-5:]";
        },

        isMyFilter: function () {
            return !this.getIsSystem() && this.getOwnerUserName() === JIRA.Issues.LoginUtils.loggedInUserName();
        },

        parse: function(response) {
            // Reverse the subscriptions so they're sorted newest to oldest.
            if (response.subscriptions && response.subscriptions.items) {
                response.subscriptions.items.reverse();
            }

            return {
                id: response.id,
                name: response.name,
                description: response.description,
                jql: response.jql,
                isSystem: response.isSystem,
                favourite: response.favourite,
                sharePermissions: response.sharePermissions || [],
                subscriptions: response.subscriptions,
                ownerUserName: response.owner && response.owner.name,
                ownerDisplayName: response.owner && response.owner.displayName,
                avatarUrl: response.owner && response.owner.avatarUrls['48x48'],
                requiresLogin: response.requiresLogin
            };
        },

        /**
         * Not all the subscriptions are retrieved from the server. This function
         * returns the number of un-retrieved subscriptions for the filter.
         */
        getNumberOfAdditionalSubscriptions: function() {
            var subs = this.getSubscriptions();
            return subs.size > subs.items.length ? subs.size - subs.items.length : 0;
        },

        saveFavourite: function(isFavourite) {
            var instance = this;
            var prevState = this.getFavourite();

            // Optimistically set favourite status
            this.setFavourite(isFavourite);

            // Abort previous pending request
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            this.pendingRequest = JIRA.SmartAjax.makeRequest({
                // This is v1 of the REST API. TODO: add the ability to set favourite to REST API v2
                url: AJS.contextPath() + '/rest/api/1.0/filters/' + encodeURIComponent(this.getId()) + '/favourite',
                type: isFavourite ? 'PUT' : 'DELETE'
            }).done(function(data) {
                var faveState = AJS.$(data).text().match(/favourite state: (\w+)/)[1] === 'true';
                delete instance.pendingRequest;
                instance.setFavourite(faveState);
            }).fail(function() {
                instance.setFavourite(prevState);
            });

            return this.pendingRequest;
        },

        saveFilter: function(newJql) {

            // Abort previous pending request
            if (this.pendingRequest) {
                this.pendingRequest.abort();
            }

            var json = this.toJSON();
            var data = {
                id: json.id,
                name: json.name,
                jql: newJql,
                favourite: json.favourite
            };

            var instance = this;
            this.pendingRequest = JIRA.SmartAjax.makeRequest({
                url: this.url(),
                type: 'PUT',
                contentType: "application/json",
                data: JSON.stringify(data)
            }).done(function(filterData) {
                instance.set(instance.parse(filterData));
            }).then(function() {
                delete instance.pendingRequest;
                JIRA.trace("jira.filter.saved");
            });

            return this.pendingRequest;
        },

        toJSON: function() {
            var json = JIRA.Issues.BaseModel.prototype.toJSON.apply(this);
            _.extend(json, {
                requiresLoginForUser: this._requiresLoginForUser(this.getRequiresLogin()),
                navUrl: this._constructNavUrl(this.getId(), this.getRequiresLogin())
            });
            return json;
        },

        _requiresLoginForUser: function(requiresLogin) {
            return !JIRA.Issues.LoginUtils.isLoggedIn() && requiresLogin;
        },

        _constructNavUrl: function(filterId, requiresLogin) {
            var navUrl = '/issues/?filter=' + filterId;
            // Set url to redirect to login if user is not logged in
            if (this._requiresLoginForUser(requiresLogin)) {
                return JIRA.Issues.LoginUtils.redirectUrl(navUrl);
            }
            else {
                return AJS.contextPath() + navUrl;
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/Filters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.Filters");

    /**
     * @class JIRA.Components.Filters.Collections.Filters
     *
     * A collection of FilterModel objects.
     *
     * @extends Backbone.Collection
     */
    JIRA.Components.Filters.Collections.Filters = JIRA.Issues.Brace.Collection.extend({

        model: JIRA.Components.Filters.Models.Filter,

        fetch: function () {
            var promise = JIRA.Issues.Brace.Collection.prototype.fetch.apply(this, arguments);

            promise.done(_.bind(function () {
                this.fetchState = "fetched";
                this.trigger("change:fetchState", this.fetchState);
            }, this));

            promise.fail(_.bind(function () {
                this.fetchState = "error";
                this.trigger("change:fetchState", this.fetchState);
            }, this));

            return promise;
        },

        initialize: function(models, options) {
            options = options || {};
            this.fetchState = options.fetchState;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/SystemFilters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.SystemFilters");

    /**
     * @class JIRA.Components.Filters.Collections.SystemFilters
     *
     * A collection of FilterModel objects.
     *
     * @extends JIRA.Components.Filters.Collections.Filters
     */
    JIRA.Components.Filters.Collections.SystemFilters = JIRA.Components.Filters.Collections.Filters.extend({

        _setFetchState: function(state) {
            var isNewSate = state !== this.fetchState;

            this.fetchState = state;
            if (isNewSate) {
                this.trigger("change:fetchState", this.fetchState);
            }
        },

        url: AJS.contextPath() + "/rest/issueNav/latest/systemFilters",

        fetch: function() {
            if (this.length > 0) {
                this._setFetchState("fetched");
                return new jQuery.Deferred().resolve();
            }

            return JIRA.Components.Filters.Collections.Filters.prototype.fetch.apply(this, _.toArray(arguments));
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/entities/FavouriteFilters.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Collections.FavouriteFilters");

    /**
     * @class JIRA.Components.Filters.Collections.FavouriteFilters
     *
     * @extends JIRA.Components.Filters.Collections.Filters
     */
    JIRA.Components.Filters.Collections.FavouriteFilters = JIRA.Components.Filters.Collections.Filters.extend({
        url: AJS.contextPath() + "/rest/api/2/filter/favourite?expand=subscriptions[-5:]",

        comparator: function(filter1, filter2) {
            return filter1.getName().toLowerCase().localeCompare(filter2.getName().toLowerCase());
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/actions.soy' */
// This file was automatically generated from actions.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Actions.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Actions == 'undefined') { JIRA.Components.Filters.Templates.Actions = {}; }


JIRA.Components.Filters.Templates.Actions.DropDown = function(opt_data, opt_ignored) {
  return '<div class="aui-list"><ul class="aui-list-section">' + ((opt_data.canEdit) ? '<li class="aui-list-item"><a href="" class="aui-list-item-link rename-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Rename") + '</a></li>' : '') + '<li class="aui-list-item"><a href="" class="aui-list-item-link copy-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Copy") + '</a></li></ul><ul class="aui-list-section' + ((! opt_data.canEdit) ? ' aui-last' : '') + '"><li class="aui-list-item"><a href="" class="aui-list-item-link unfavourite-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Remove from favourites") + '</a></li></ul>' + ((opt_data.canEdit) ? '<ul class="aui-list-section aui-last"><li class="aui-list-item"><a href="" class="aui-list-item-link delete-filter" data-id="' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '">' + soy.$$escapeHtml("Delete") + '</a></li></ul>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Actions.DropDown.soyTemplateName = 'JIRA.Components.Filters.Templates.Actions.DropDown';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/dialogs.soy' */
// This file was automatically generated from dialogs.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Dialogs.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Dialogs == 'undefined') { JIRA.Components.Filters.Templates.Dialogs = {}; }


JIRA.Components.Filters.Templates.Dialogs.Rename = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><form action="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/rest/api/2/filter/' + soy.$$escapeHtmlAttribute(opt_data.filter.id) + '" class="aui" id="rename-filter-form" method="put"><div class="aui-messages"></div><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml("Rename Filter") + ': ' + soy.$$escapeHtml(opt_data.filter.name) + '</h2><div class="field-group"><label for="filterName">' + soy.$$escapeHtml("Filter Name") + '<span class="aui-icon icon-required"><span class="content">Required</span></span></label><input type="text" id="filterName" name="name" value="' + soy.$$escapeHtmlAttribute(opt_data.filter.name) + '" class="text long-field"></div></div><div class="buttons-container form-footer"><div class="buttons"><input accesskey="' + soy.$$escapeHtmlAttribute("s") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtmlAttribute("Submit") + '" /><a accesskey="' + soy.$$escapeHtmlAttribute("`") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Dialogs.Rename.soyTemplateName = 'JIRA.Components.Filters.Templates.Dialogs.Rename';
}


JIRA.Components.Filters.Templates.Dialogs.Save = function(opt_data, opt_ignored) {
  var output = '<div class="aui-dialog-content"><form action="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.contextPath)) + '/rest/api/2/filter/" class="aui" id="save-filter-form" method="post"><div class="aui-messages"></div><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml(opt_data.headerText) + '</h2>' + ((opt_data.copyFromAnotherUser) ? '<p class="form-description">' + ((opt_data.filterOwnerName) ? soy.$$escapeHtml(AJS.format("This filter was created by {0}. You can save a copy of this filter but you cannot modify the original.",opt_data.filterOwnerName)) : soy.$$escapeHtml("You can save a copy of this filter but you cannot modify the original.")) + '</p>' : '') + '<div class="field-group"><label for="filterName">' + soy.$$escapeHtml("Filter Name") + '<span class="aui-icon icon-required"><span class="content">Required</span></span></label><input type="text" id="filterName" name="name"' + ((opt_data.prefilledFilterName) ? ' value="' + soy.$$escapeHtmlAttribute(opt_data.prefilledFilterName) + '"' : '') + 'class="text long-field"><div class="description">' + soy.$$escapeHtml("Enter a name for this Filter") + '</div>';
  var fieldList54 = opt_data.hiddenFields;
  var fieldListLen54 = fieldList54.length;
  for (var fieldIndex54 = 0; fieldIndex54 < fieldListLen54; fieldIndex54++) {
    var fieldData54 = fieldList54[fieldIndex54];
    output += '<input type="hidden" name="' + soy.$$escapeHtmlAttribute(fieldData54.name) + '" value="' + ((fieldData54.value) ? soy.$$escapeHtmlAttribute(fieldData54.value) : '') + '" />';
  }
  output += '</div>' + ((opt_data.isDefaultShareScopeGlobal) ? '<div class="aui-message info shadowed"><p class="title"><span class="aui-icon icon-info"></span><strong>' + soy.$$escapeHtml("By default your filters are shared with everyone.") + '</strong></p><input type="checkbox" id="setSharingPrivate" class="checkbox"><label for="setSharingPrivate">' + soy.$$escapeHtml("My filters should be private by default.") + '</label></div>' : '') + '</div><div class="buttons-container form-footer"><div class="buttons"><input accesskey="' + soy.$$escapeHtmlAttribute("s") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" type="submit" value="' + soy.$$escapeHtmlAttribute("Submit") + '" /><a accesskey="' + soy.$$escapeHtmlAttribute("`") + '" title="' + soy.$$escapeHtmlAttribute(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel" href="javascript:">' + soy.$$escapeHtml("Cancel") + '</a></div></div></form></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Dialogs.Save.soyTemplateName = 'JIRA.Components.Filters.Templates.Dialogs.Save';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/list.soy' */
// This file was automatically generated from list.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.List.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.List == 'undefined') { JIRA.Components.Filters.Templates.List = {}; }


JIRA.Components.Filters.Templates.List.Module = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="filter-panel-section">' + ((opt_data.title) ? '<h4 class="filter-title">' + soy.$$escapeHtml(opt_data.title) + '</h4>' : '') + '<div class="filter-content" /></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Module.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Module';
}


JIRA.Components.Filters.Templates.List.Message = function(opt_data, opt_ignored) {
  return '<p class="filter-info ' + soy.$$escapeHtmlAttribute(opt_data.className) + '">' + soy.$$filterNoAutoescape(opt_data.text) + '</p>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Message.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Message';
}


JIRA.Components.Filters.Templates.List.List = function(opt_data, opt_ignored) {
  return '<ul class="saved-filter filter-list ' + soy.$$escapeHtmlAttribute(opt_data.className) + '"></ul>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.List.soyTemplateName = 'JIRA.Components.Filters.Templates.List.List';
}


JIRA.Components.Filters.Templates.List.Filter = function(opt_data, opt_ignored) {
  return '<li><a class="filter-link' + ((opt_data.requiresLoginForUser) ? ' requires-login' : '') + '" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.navUrl)) + '" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '" title="' + soy.$$escapeHtmlAttribute(opt_data.name) + '">' + soy.$$escapeHtml(opt_data.name) + '</a>' + ((opt_data.useActions) ? '<a href="#" class="filter-actions" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '"><span>' + soy.$$escapeHtml("Filter Actions") + '</span></a>' : '') + '</li>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.List.Filter.soyTemplateName = 'JIRA.Components.Filters.Templates.List.Filter';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/header.soy' */
// This file was automatically generated from header.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Header.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Header == 'undefined') { JIRA.Components.Filters.Templates.Header = {}; }


JIRA.Components.Filters.Templates.Header.Main = function(opt_data, opt_ignored) {
  var output = '<div class="header-section-primary"><h1 class="search-title" title="' + soy.$$escapeHtmlAttribute(opt_data.title) + '">' + soy.$$escapeHtml(opt_data.title) + '</h1><ul class="filter-operations">' + ((opt_data.primaryOps && opt_data.primaryOps.length) ? '<li class="filter-edited-item"><span>' + soy.$$escapeHtml("Edited") + '</span></li>' : '');
  if (opt_data.primaryButton) {
    output += '<li>' + ((opt_data.primaryOps && opt_data.primaryOps.length) ? '<div class="aui-buttons">' : '') + '<button class="aui-button aui-button-light ' + soy.$$escapeHtmlAttribute(opt_data.primaryButton.styleClass) + '">' + soy.$$escapeHtml(opt_data.primaryButton.label) + '</button>';
    if (opt_data.primaryOps && opt_data.primaryOps.length) {
      output += '<button class="aui-button aui-button-light aui-dropdown2-trigger js-edited-trigger" aria-owns="js-edited-content" aria-haspopup="true" data-container=".aui-buttons"></button></div><div id="js-edited-content" class="aui-dropdown2 aui-style-default"><ul>';
      var opList27 = opt_data.primaryOps;
      var opListLen27 = opList27.length;
      for (var opIndex27 = 0; opIndex27 < opListLen27; opIndex27++) {
        var opData27 = opList27[opIndex27];
        output += '<li><a href="' + ((opData27.href) ? soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opData27.href)) : '#') + '" ' + ((opData27.styleClass) ? 'class="' + soy.$$escapeHtmlAttribute(opData27.styleClass) + '"' : '') + '>' + soy.$$escapeHtml(opData27.label) + '</a></li>';
      }
      output += '</ul></div>';
    }
    output += '</li>';
  }
  if (opt_data.owner) {
    var opList48 = opt_data.secondaryOps;
    var opListLen48 = opList48.length;
    for (var opIndex48 = 0; opIndex48 < opListLen48; opIndex48++) {
      var opData48 = opList48[opIndex48];
      output += '<li><a href="' + ((opData48.href) ? soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opData48.href)) : '#') + '" ' + ((opData48.title) ? 'title="' + soy.$$escapeHtmlAttribute(opData48.title) + '"' : '') + ' class="' + soy.$$escapeHtmlAttribute(opData48.styleClass) + '">' + ((opData48.label) ? soy.$$escapeHtml(opData48.label) : '') + '</a></li>';
    }
  }
  output += '</ul></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Header.Main.soyTemplateName = 'JIRA.Components.Filters.Templates.Header.Main';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/templates/details.soy' */
// This file was automatically generated from details.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Filters.Templates.Details.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Filters == 'undefined') { JIRA.Components.Filters = {}; }
if (typeof JIRA.Components.Filters.Templates == 'undefined') { JIRA.Components.Filters.Templates = {}; }
if (typeof JIRA.Components.Filters.Templates.Details == 'undefined') { JIRA.Components.Filters.Templates.Details = {}; }


JIRA.Components.Filters.Templates.Details.Main = function(opt_data, opt_ignored) {
  return '' + JIRA.Components.Filters.Templates.Details.Description(opt_data) + JIRA.Components.Filters.Templates.Details.Permissions(opt_data) + ((opt_data.userIsLoggedIn) ? JIRA.Components.Filters.Templates.Details.Subscriptions(opt_data) : '');
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Main.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Main';
}


JIRA.Components.Filters.Templates.Details.Description = function(opt_data, opt_ignored) {
  return '<div class="filter-details-section sub-section">' + ((opt_data.owner) ? JIRA.Components.Filters.Templates.Details.Owner(opt_data) : '') + ((opt_data.filter.description) ? '<p class="filter-name">' + soy.$$escapeHtml(opt_data.filter.description) + ((opt_data.permissions.userHasEditPermission) ? ' <a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditFilter!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">(' + soy.$$escapeHtml("Edit") + ')</a>' : '') + '</p>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Description.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Description';
}


JIRA.Components.Filters.Templates.Details.Permissions = function(opt_data, opt_ignored) {
  var output = '<div class="filter-details-section sub-section"><h4 class="section-header">' + soy.$$escapeHtml("Permissions") + '</h4>';
  if (opt_data.sharePermissions && opt_data.sharePermissions.length > 0) {
    output += '<p>' + soy.$$escapeHtml("This filter is visible to:") + '</p><ul class="shared-filters">';
    var shareList49 = opt_data.sharePermissions;
    var shareListLen49 = shareList49.length;
    for (var shareIndex49 = 0; shareIndex49 < shareListLen49; shareIndex49++) {
      var shareData49 = shareList49[shareIndex49];
      output += JIRA.Components.Filters.Templates.Details.SharePermissionItem({type: shareData49.type, project: '' + ((shareData49.project) ? '<a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/browse/' + soy.$$escapeHtml(shareData49.project.key) + '">' + soy.$$escapeHtml(shareData49.project.name) + '</a>' : ''), projectRole: '' + ((shareData49.role) ? soy.$$escapeHtml(shareData49.role.name) : ''), group: '' + ((shareData49.group) ? soy.$$escapeHtml(shareData49.group.name) : '')});
    }
    output += '</ul>';
  } else {
    output += '<p>' + soy.$$escapeHtml("This filter is only visible to you.") + '</p>';
  }
  output += ((opt_data.permissions.userHasEditSharingPermission) ? '<p><a class="edit-permissions" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditFilter!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml("Edit permissions") + '</a></p>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Permissions.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Permissions';
}


JIRA.Components.Filters.Templates.Details.Subscriptions = function(opt_data, opt_ignored) {
  return '<div class="filter-details-section full-section"><h4>' + soy.$$escapeHtml("Subscriptions") + '</h4>' + ((opt_data.subscriptions.items.length) ? '<p>' + soy.$$escapeHtml("This filter has the following subscriptions:") + '</p>' + JIRA.Components.Filters.Templates.Details.SubscriptionList(opt_data) : '<p>' + soy.$$escapeHtml("This filter has no subscriptions.") + '</p>') + '<ul class="manage-links"><li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/EditSubscription!default.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '&returnUrl=' + soy.$$escapeUri(opt_data.returnUrl) + '">' + soy.$$escapeHtml("New subscription") + '</a></li>' + ((opt_data.subscriptions.items.length) ? '<li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ViewSubscriptions.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml("Manage subscriptions") + '</a></li>' : '') + '</ul></div>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Subscriptions.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Subscriptions';
}


JIRA.Components.Filters.Templates.Details.SharePermissionItem = function(opt_data, opt_ignored) {
  return '' + ((opt_data.type == 'global') ? '<li>' + soy.$$escapeHtml("Everyone") + '</li>' : (opt_data.type == 'group') ? '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Group{1}: {2}",'<strong>','</strong>',opt_data.group)) + '</li>' : (opt_data.projectRole) ? '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Project{1}: {2} {3}Role{4}: {5}",'<strong>','</strong>',opt_data.project,'<strong>','</strong>',opt_data.projectRole)) + '</li>' : '<li>' + soy.$$filterNoAutoescape(AJS.format("{0}Project{1}: {2}",'<strong>','</strong>',opt_data.project)) + '</li>');
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.SharePermissionItem.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.SharePermissionItem';
}


JIRA.Components.Filters.Templates.Details.SubscriptionList = function(opt_data, opt_ignored) {
  var output = '<ul>';
  var subList150 = opt_data.filter.subscriptions.items;
  var subListLen150 = subList150.length;
  for (var subIndex150 = 0; subIndex150 < subListLen150; subIndex150++) {
    var subData150 = subList150[subIndex150];
    output += (subData150.group) ? '<li>' + soy.$$escapeHtml(subData150.group.name) + '</li>' : '<li>' + soy.$$escapeHtml(subData150.user.displayName) + '</li>';
  }
  output += ((opt_data.filter.subscriptions.additionalLength) ? '<li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ViewSubscriptions.jspa?filterId=' + soy.$$escapeUri(opt_data.filter.id) + '">' + soy.$$escapeHtml(AJS.format("{0} more",opt_data.filter.subscriptions.additionalLength)) + '</a></li>' : '') + '</ul>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.SubscriptionList.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.SubscriptionList';
}


JIRA.Components.Filters.Templates.Details.Owner = function(opt_data, opt_ignored) {
  var output = '<div class="search-owner">' + ((opt_data.avatarUrl) ? '<span class="aui-avatar aui-avatar-large search-owner-avatar"><span class="aui-avatar-inner"><img src="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.avatarUrl)) + '" /></span></span>' : '') + '<span class="search-owner-name">';
  var ownerLink__soy181 = '' + JIRA.Components.Filters.Templates.Details.OwnerLink(opt_data);
  output += soy.$$filterNoAutoescape(AJS.format("Owned by {0}",ownerLink__soy181)) + '</span></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.Owner.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.Owner';
}


JIRA.Components.Filters.Templates.Details.OwnerLink = function(opt_data, opt_ignored) {
  return '<a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri(opt_data.ownerUrl)) + '" class="user-hover" rel="' + soy.$$escapeHtmlAttribute(opt_data.ownerUserName) + '">' + soy.$$escapeHtml(opt_data.owner) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Components.Filters.Templates.Details.OwnerLink.soyTemplateName = 'JIRA.Components.Filters.Templates.Details.OwnerLink';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Actions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Actions");

    /**
     * @class JIRA.Components.Filters.Views.Actions
     *
     * Displays the actions dropdown for a filter
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.Actions = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.Actions.DropDown,

        triggers: {
            "click .rename-filter": "renameFilter",
            "click .copy-filter": "copyFilter",
            "click .unfavourite-filter": "unfavouriteFilter",
            "click .delete-filter": "deleteFilter"
        },

        /**
         * The view that was used as a trigger for the dropdown. Populated when this view is created.
         * @type {JIRA.Marionette.View}
         */
        triggerView: null,

        /**
         * Internal dropdown created with this view is rendered.
         * @type {AJS.Dropdown}
         */
        dropDown: null,

        /**
         * @param {Object} options Options
         * @param {JIRA.Components.Filters.Views.List.FilterWithActions} options.triggerView View that was used to trigger the dropDown
         */
        initialize: function(options) {
            this.triggerView = options.triggerView;
        },

        serializeData: function() {
            return {
                filter: this.model,
                canEdit: JIRA.Issues.LoginUtils.loggedInUserName() === this.model.getOwnerUserName()
            };
        },

        onBeforeRender: function() {
            this.dropDown = new AJS.Dropdown({
                alignment: AJS.LEFT,
                styleClass: "filter-actions-dropdown",
                content: _.bind(function() {
                    return this.$el;
                }, this),
                positioningController: new JIRA.Issues.WindowPositioning(),
                trigger: this.triggerView.getActionsTrigger()
            });

            // When the dropdown is hidden, close this view
            this.dropDown.bind("hideLayer", _.bind(this.close, this));
        },

        onRender: function() {
            this.dropDown.show();
            this._markFilterAsSelected();
        },

        onClose: function() {
            this.dropDown.hide();
            this.dropDown.layerController.placeholder().remove();
            this.dropDown = null;
            this._markFilterAsUnselected();
        },

        _markFilterAsSelected: function() {
            var trigger = this.triggerView.getActionsTrigger();
            trigger.find("span").addClass("active");
            trigger.closest("li").addClass("hover");
        },

        _markFilterAsUnselected: function() {
            var trigger = this.triggerView.getActionsTrigger();
            trigger.find("span").removeClass("active");
            trigger.closest("li").removeClass("hover");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Copy.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Copy");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Copy
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Copy = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Save,

        id: "copy-filter-dialog",

        /**
         * Generate the options needed to display the form, in the format expected by JIRA.FormDialog.
         *
         * @returns {Object}
         */
        dialogOptions: function() {
            var instance = this;
            return {
                content: function(callback) {
                    // Make REST call to see if user shares filters by default
                    JIRA.SmartAjax.makeRequest({
                        url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                        contentType: 'application/json'
                    }).done(function(data) {
                        callback(
                            instance.template(_.extend({
                                isDefaultShareScopeGlobal: data && data.scope === 'GLOBAL'
                            }, instance.serializeData()))
                        );
                    });
                }
            };
        },

        /**
         * Generate the data to be sent in the form request.
         *
         * @param {jQuery} form Form container.
         * @returns {Object} Data to be sent in the request.
         */
        formToRequestData: function(form) {
            return {
                name: form.find('[name=name]').val(),
                id: this.model.getId(),
                favourite: true
            };
        },

        /**
         * Generate the data needed by the template
         *
         * @returns {Object}
         */
        serializeData: function() {
            var model = this.model;
            return {
                headerText: "Copy Filter" + " : " + model.getName(),
                prefilledFilterName: AJS.format("Copy of {0}", model.getName()),
                modifierKey: AJS.Navigator.modifierKey(),
                contextPath: AJS.contextPath(),
                filter: model.toJSON(),
                copyFromAnotherUser: model.getOwnerUserName() !== AJS.Meta.get('remote-user'),
                filterOwnerName: model.getOwnerDisplayName(),
                hiddenFields: []
            };
        },

        /**
         * Method to run when the form has been submitted successfully.
         *
         * Changes the user sharing preference to 'PRIVATE' if needed.
         */
        onSubmitSuccess: function() {
            if (this.$el.find('#setSharingPrivate').prop('checked')) {
                JIRA.SmartAjax.makeRequest({
                    url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                    type: 'PUT',
                    contentType: 'application/json',
                    processData: false,
                    data: JSON.stringify({scope: 'PRIVATE'})
                });
            }
        },

        /**
         * Method to run when the form has been submitted with errors
         */
        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Delete.js' */
define("jira/issues/components/filters/views/dialogs/delete", ["require"], function(require) {
    "use strict";

    var DialogUtil = require('jira/dialog/dialog-util');

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Delete
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Delete = JIRA.Marionette.DialogView.extend({
        id: "delete-filter-dialog",

        serializeData: function () {
            var data = {
                modifierKey: AJS.Navigator.modifierKey()
            };

            if (this.model) {
                data.filter = this.model.toJSON();
            } else {
                data.filter = {subscriptions: {items: []}};
            }

            return data;
        },

        dialogOptions: function() {
            return {
                content: null, //override default behaviour of issuenav DialogView, which generates content using soy template
                url: AJS.contextPath() + "/secure/DeleteFilter!default.jspa?filterId=" + this.model.id,
                ajaxOptions: DialogUtil.getDefaultAjaxOptions,
                submitHandler: null, //fall back to FormDialog's original behaviour
                onUnSuccessfulSubmit: this._onSubmitError.bind(this),
                onSuccessfulSubmit: this._onSubmitSuccess.bind(this),
                onDialogFinished: function(){} //ensure that we do not do a page reload post form submission
            };
        }
    });
});
AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Delete", null, require("jira/issues/components/filters/views/dialogs/delete"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/Rename.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.Rename");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.Rename
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.Rename = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Rename,

        id: "rename-filter-dialog",

        serializeData: function() {
            return {
                modifierKey: AJS.Navigator.modifierKey(),
                filter: this.model.toJSON()
            };
        },

        /**
         * Generate the data to be sent in the form request
         *
         * @param {jQuery} form Form container
         * @returns {Object} Data to be sent in the request
         */
        formToRequestData: function(form) {
            return {
                name: form.find('[name=name]').val(),
                id: this.model.getId(),
                favourite: true
            };
        },

        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/dialogs/SaveAs.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Dialogs.SaveAs");

    /**
     * @class JIRA.Components.Filters.Views.Dialogs.SaveAs
     *
     * @extends JIRA.Marionette.DialogView
     */
    JIRA.Components.Filters.Views.Dialogs.SaveAs = JIRA.Marionette.DialogView.extend({
        template: JIRA.Components.Filters.Templates.Dialogs.Save,

        id: "save-filter-dialog",

        initialize: function(options) {
            this.jql = options.jql;
        },

        /**
         * Generate the options needed to display the form, in the format expected by JIRA.FormDialog
         *
         * @returns {Object}
         */
        dialogOptions: function() {
            var instance = this;
            return {
                content: function(callback) {
                    // Make REST call to see if user shares filters by default
                    JIRA.SmartAjax.makeRequest({
                        url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                        contentType: 'application/json'
                    }).done(function(data) {
                        callback(
                            instance.template(_.extend({
                                isDefaultShareScopeGlobal: data && data.scope === 'GLOBAL'
                            }, instance.serializeData()))
                        );
                    });
                }
            };
        },

        /**
         * Generate the data to be sent in the form request
         *
         * @param {jQuery} form Form container
         * @returns {Object} Data to be sent in the request
         */
        formToRequestData: function(form) {
            var opts = {
                name: form.find('[name=name]').val(),
                jql: this.jql,
                favourite: true
            };

            // If we are Saving a new serach, this.model will be undefined
            if (this.model && !this.model.getIsSystem()) {
                opts.id = this.model.getId();
            }

            return opts;
        },

        /**
         * Generate the data needed by the template
         *
         * @returns {Object}
         */
        serializeData: function() {
            var data = {
                headerText: "Save Filter",
                modifierKey: AJS.Navigator.modifierKey(),
                contextPath: AJS.contextPath(),
                hiddenFields: []
            };

            // If we are Saving a new search, this.model will be undefined
            var model = this.model;
            if (model) {
                _.extend(data, {
                    filter: model ? model.toJSON() : {},
                    copyFromAnotherUser: model.getOwnerUserName() !== AJS.Meta.get('remote-user'),
                    filterOwnerName: model.getOwnerDisplayName()
                });
            }

            return data;
        },

        /**
         * Method to run when the form has been submitted successfully.
         *
         * Changes the user sharing preference to 'PRIVATE' if needed.
         */
        onSubmitSuccess: function() {
            if (this.$el.find('#setSharingPrivate').prop('checked')) {
                JIRA.SmartAjax.makeRequest({
                    url: AJS.contextPath() + '/rest/api/2/filter/defaultShareScope',
                    type: 'PUT',
                    contentType: 'application/json',
                    processData: false,
                    data: JSON.stringify({ scope: 'PRIVATE' })
                });
            }
        },

        /**
         * Method to run when the form has been submitted with errors
         */
        onSubmitError: function() {
            this.dialog.$form.find("#filterName").focus();
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Filter.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Filter");

    /**
     * @class JIRA.Components.Filters.Views.List.Filter
     *
     * Renders each individual item in the filter's list.
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.List.Filter = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.List.Filter,

        ui: {
            filterLink: ".filter-link"
        },

        triggers: {
            "simpleClick .filter-link:not(.requires-login)": "selectFilter"
        },

        modelEvents: {
            "change": "render"
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        highlight: function() {
            this.ui.filterLink.addClass("active");
            this.ui.filterLink.scrollIntoView();
        },

        unhighlight: function() {
            this.ui.filterLink.removeClass("active");
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/FilterWithActions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.FilterWithActions");

    /**
     * @class JIRA.Components.Filters.Views.List.FilterWithActions
     *
     * Renders each individual item in the filter's list, including a dropdown for the filter Actions
     *
     * @extends JIRA.Components.Filters.Views.List.Filter
     */
    JIRA.Components.Filters.Views.List.FilterWithActions = JIRA.Components.Filters.Views.List.Filter.extend({
        ui: _.extend({
            actionsTrigger: ".filter-actions"
        }, JIRA.Components.Filters.Views.List.Filter.prototype.ui),

        triggers: _.extend({
            "click .filter-actions": "openActions"
        }, JIRA.Components.Filters.Views.List.Filter.prototype.triggers),

        templateHelpers: {
            useActions: true
        },

        /**
         * Returns the trigger used to display the Actions dropdown
         *
         * @returns {jQuery}
         */
        getActionsTrigger: function() {
            return this.ui.actionsTrigger;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/List.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.List");

    /**
     * @class JIRA.Components.Filters.Views.List.List
     *
     * Displays a list of filters
     *
     * @extends JIRA.Marionette.CompositeView
     */
    JIRA.Components.Filters.Views.List.List = JIRA.Marionette.CompositeView.extend({
        template: JIRA.Components.Filters.Templates.List.List,
        itemView: JIRA.Components.Filters.Views.List.Filter,
        itemViewContainer: ".filter-list",

        onRender: function() {
            this.unwrapTemplate();
        },

        templateHelpers: function() {
            return {
                className: this.className
            };
        },

        unhighlightAllFilters: function() {
            this.children.apply("unhighlight");
        },

        /**
         * Highlight a filter. If the model does not exist in the collection represented by this list,
         * this method does nothing.
         *
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model to highlight
         */
        highlightFilter: function(filterModel) {
            var itemView = this.children.findByModel(filterModel);
            if (itemView) {
                itemView.highlight();
            }
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/ListWithActions.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.ListWithActions");

    /**
     * @class JIRA.Components.Filters.Views.List.List
     *
     * Displays a list of filters
     *
     * @extends JIRA.Components.Filters.Views.List.List
     */
    JIRA.Components.Filters.Views.List.ListWithActions = JIRA.Components.Filters.Views.List.List.extend({
        itemView: JIRA.Components.Filters.Views.List.FilterWithActions,

        /**
         * Whether the items of the list should include the actions dropdown
         * @type {boolean}
         */
        useActions: false,

        /**
         * @param {Object} options Options
         * @param {boolean} [options.useActions=false] Whether the action's trigger should be displayed
         */
        initialize: function(options) {
            options = _.defaults({}, options, {
                useActions: false
            });

            this.useActions = options.useActions;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Message.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Message");

    /**
     * @class JIRA.Components.Filters.Views.List.Message
     *
     * Displays a message
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.List.Message = JIRA.Marionette.ItemView.extend({
        template: JIRA.Components.Filters.Templates.List.Message,

        /**
         * Text to display in the message
         * @type {string}
         */
        text: "",

        /**
         * @param {Object} options Options
         * @param {string} options.text Text to display in the message.
         */
        initialize: function(options) {
            this.text = options.text;
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        templateHelpers: function() {
            return {
                text: this.text,
                className: this.className
            };
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/list/Module.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.List.Module");

    /**
     * @class JIRA.Components.Filters.Views.List.Module
     *
     * Displays the main module for the list of filters. This view only renders the placeholder
     * for the other views (List, Empty or Error),  and an optional title
     *
     * @extends JIRA.Marionette.Layout
     */
    JIRA.Components.Filters.Views.List.Module = JIRA.Marionette.Layout.extend({
        template: JIRA.Components.Filters.Templates.List.Module,

        /**
         * Title to display in the message
         * @type {string}
         */
        title: "",

        regions: {
            content: ".filter-content"
        },

        /**
         * @param {Object} options Options
         * @param {string} [options.title] Title of the module. If not provided, the module will be rendered without title markup.
         */
        initialize: function(options) {
            options = _.defaults({}, options, {
                title: ""
            });
            this.title = options.title;
        },

        templateHelpers: function() {
            return {
                title: this.title
            };
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Header.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Header");

    /**
     * @class JIRA.Components.Filters.Controllers.Header
     *
     * @extends JIRA.Marionette.ItemView
     */
    JIRA.Components.Filters.Views.Header = JIRA.Marionette.ItemView.extend({
        operations: {
            save: {
                styleClass: "save-changes",
                label: "Save"
            },
            saveAs: {
                styleClass: "save-as-new-filter",
                label: "Save as"
            },
            discardChanges: {
                styleClass: "discard-filter-changes",
                label: "Discard changes"
            },
            details: {
                styleClass: "show-filter-details",
                title: "View information about this filter",
                label: "Details"
            },
            favouriteOn: {
                title: "Remove this filter from your Favourite Filters",
                label: "Remove this filter from your Favourite Filters",
                styleClass: "fav-link aui-icon aui-icon-small aui-iconfont-star"
            },
            favouriteOff: {
                title: "Add this filter to your Favourite Filters",
                label: "Add this filter to your Favourite Filters",
                styleClass: "fav-link aui-icon aui-icon-small aui-iconfont-unstar"
            }
        },

        template: JIRA.Components.Filters.Templates.Header.Main,

        ui: {
            filterFavouriteButton: ".fav-link",
            filterEditedLabel: ".filter-edited-item",
            saveButton: '.save-changes',
            saveAsButton: '.save-as-new-filter',
            detailsTrigger: '.show-filter-details',
            dropdownContent: '#js-edited-content'
        },

        triggers: {
            'click .fav-link': "toogleFavourite",
            "click .save-as-new-filter:not([aria-disabled=true])": {
                event: "saveAs",
                preventDefault: true,
                stopPropagation: false
            },
            "click .save-changes:not([aria-disabled=true])": {
                event: "save",
                preventDefault: true,
                stopPropagation: false
            },
            "click .discard-filter-changes": {
                event: "discard",
                preventDefault: true,
                stopPropagation: false
            }
        },

        events: {
            "click .show-filter-details": function() {
                this.trigger("details", this.ui.detailsTrigger);
            }
        },

        _generatePrimaryOperations: function() {
            var operations = [];

            if (this.isEdited && this.model.isMyFilter()) {
                operations.push(this.operations.save);
            }

            if (!this.isDirty && !!JIRA.Issues.LoginUtils.loggedInUserName()) {
                operations.push(this.operations.saveAs);
            }

            if (this.isEdited) {
                operations.push(this.operations.discardChanges);
            }

            return operations;
        },

        _generateSecondaryOperations: function() {
            var operations = [];

            if (!this.model.getIsSystem()) {
                operations.push(this.operations.details);
            }

            if (!!JIRA.Issues.LoginUtils.loggedInUserName() && !this.model.getIsSystem()) {
                var operation = this.model.isFavouriteFilter() ? this.operations.favouriteOn : this.operations.favouriteOff;
                operations.href = AJS.contextPath() + "/secure/EditFilter!default.jspa?filterId=" + this.model.id;
                operations.push(operation);
            }

            return operations;
        },

        serializeData: function() {
            if (!this.model) {
                return {
                    title: "Search",
                    primaryButton: this.operations.saveAs
                };
            }

            if (!this.model.getIsValid()) {
                return {
                    title: "Search"
                };
            }

            var primaryOperations = this._generatePrimaryOperations();
            var secondaryOperations = this._generateSecondaryOperations();

            var renderData = {
                title: this.model.getName(),
                primaryButton: primaryOperations.shift(),
                primaryOps: primaryOperations,
                secondaryOps: secondaryOperations
            };

            if (this.model.getOwner()) {
                _.extend(renderData, {
                    owner: this.model.getOwner() || "",
                    ownerUserName: this.model.getOwnerUserName() || "",
                    avatarUrl: this.model.getAvatarUrl(),
                    ownerUrl: AJS.contextPath() + '/secure/ViewProfile.jspa?name=' + encodeURIComponent(this.model.getOwnerUserName())
                });
            }

            return renderData;
        },

        render: function(options) {
            if (typeof options.model !== "undefined") {
                this.model = options.model;
            }
            this.isEdited = options.isEdited;
            this.isDirty = options.isDirty;
            return JIRA.Marionette.ItemView.prototype.render.call(this);
        },

        onRender: function() {
            this.ui.dropdownContent.on("aui-dropdown2-show", _.bind(function(e) {
                //HACK to use Backbone's event delegation on the dropdown content.
                //Backbone's 'delegateEvents()' works only on 'this.$el', so we need to set it before calling
                //the delegate method, and restore it afterwards to the real value.
                var viewEl = this.$el;
                this.$el = jQuery(e.target);
                this.delegateEvents();
                this.$el = viewEl;
            }, this));

            if (this.dirtyTipsy) {
                this.dirtyTipsy.remove();
                delete this.dirtyTipsy;
            }

            if (this.isDirty) {
                this.markAsInvalid();
            }
            new JIRA.Issues.Tipsy({el: this.ui.filterFavouriteButton});
        },

        markAsInvalid: function() {
            this.ui.saveButton.addClass("disabled");
            this.ui.saveButton.attr("aria-disabled", "true");

            this.dirtyTipsy = new JIRA.Issues.Tipsy({
                el: this.ui.saveButton,
                tipsy: {
                    delayIn: 0,
                    title: function() {
                        return "You need to run the search first before you can save your changes";
                    }
                }
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/views/Details.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Views.Details");

    /**
     * @class JIRA.Components.Filters.Controllers.Details
     *
     * @extends JIRA.Marionette.InlineDialogView
     */
    JIRA.Components.Filters.Views.Details = JIRA.Marionette.InlineDialogView.extend({
        template: JIRA.Components.Filters.Templates.Details.Main,
        id: "filter-details-overlay",

        dialogOptions: {
            addActiveClass: true,
            hideDelay: 36e5,
            offsetX: -36,
            width: 400
        },

        initialize: function(options) {
            this.trigger = options.triggerEl;
        },

        serializeData: function() {
            var currentFilter = this.model;
            var shares = _.sortBy(currentFilter.getSharePermissions(), function(share) {
                var criteria = [share.type];
                if (share.group) criteria.push(share.group.name);
                if (share.project) criteria.push(share.project.name);
                if (share.role) criteria.push(share.role.name);
                return criteria;
            });
            var subscriptions = _.clone(currentFilter.getSubscriptions());
            var canEdit = JIRA.Issues.LoginUtils.loggedInUserName() === currentFilter.getOwnerUserName();

            subscriptions.additionalLength = currentFilter.getNumberOfAdditionalSubscriptions();

            var data = {
                filter: currentFilter.toJSON(),
                sharePermissions: shares,
                subscriptions: subscriptions,
                permissions: {
                    // The "Edit Permissions" link should be displayed whenever the user can actually change sharing permissions.
                    // This is possible even when they do not have "create shared objects" permission. @see JRADEV-14810
                    userHasEditSharingPermission: canEdit && (!!JIRA.Issues.UserParms.createSharedObjects() || shares.length > 0),
                    userHasEditPermission: canEdit
                },
                userIsLoggedIn: JIRA.Issues.LoginUtils.isLoggedIn(),
                returnUrl: window.location
            };

            if (currentFilter.getOwner()) {
                _.extend(data, {
                    owner: currentFilter.getOwner() || "",
                    ownerUserName: currentFilter.getOwnerUserName() || "",
                    avatarUrl: currentFilter.getAvatarUrl(),
                    ownerUrl: AJS.contextPath() + '/secure/ViewProfile.jspa?name=' + encodeURIComponent(currentFilter.getOwnerUserName())
                });
            }

            return data;
        },

        onRender: function() {
            // Hack to work around JIRA's LayerManager.js closing this dialog.
            this.dialog.bind("click", function(event) {
                event.stopPropagation();
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/Dialog.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.Dialog");

    /**
     * @class JIRA.Components.Filters.Controllers.Dialog
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.Dialog = JIRA.Marionette.Controller.extend({
        /**
         * @constructor
         */
        initialize: function() {
            this.activeView = null;
        },

        _closeActiveDialog: function() {
            if (this.activeView) {
                this.activeView.close();
                this.stopListening(this.activeView);
                this.activeView = null;
            }
        },

        /**
         * Shows a dialog .
         *
         * @param {JIRA.Marionette.DialogView} Constructor Class of the dialog.
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter related to the dialog (e.g. in the deleteDialog, this is the filter being deleted).
         * @param {Object} [options] Options
         * @param {Object} [options.viewOptions] Options passed to the view's Constructor
         * @param {Function} [options.onSuccess] Handler for the 'submit:success' event
         * @param {Function} [options.onError] Handler for the 'submit:error' event
         *
         * @private
         */
        _showDialog: function(Constructor, filterModel, options) {
            _.defaults(options, {
                viewOptions: {},
                onSuccess: jQuery.noop,
                onError: jQuery.noop
            });

            this._closeActiveDialog();

            this.activeView = new Constructor(_.extend({
                model: filterModel
            }, options.viewOptions));

            this.listenTo(this.activeView, 'submit:success', function(serverResponse) {
                options.onSuccess.call(this, serverResponse, filterModel);
            });
            this.listenTo(this.activeView, "submit:error", function() {
                options.onError.call(this, filterModel);
            });

            this.activeView.render();
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being deleted.
         */
        showDeleteDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Delete, filterModel, {
                onSuccess: function(serverResponse, filterModel) {
                    this.trigger('delete:success', filterModel);
                },
                onError: function(filterModel) {
                    this.trigger('delete:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being renamed.
         */
        showRenameDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Rename, filterModel, {
                onSuccess: function(serverResponse, filterModel) {
                    filterModel.set("name", serverResponse.name);
                    this.trigger('rename:success', filterModel);
                },
                onError: function(filterModel) {
                    this.trigger('rename:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of the filter being copied.
         */
        showCopyDialog: function(filterModel) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.Copy, filterModel, {
                onSuccess: function(serverResponse) {
                    var newModel = new JIRA.Components.Filters.Models.Filter(serverResponse, {parse: true});
                    this.trigger('copy:success', newModel);
                },
                onError: function(filterModel) {
                    this.trigger('copy:error', filterModel);
                }
            });
        },

        /**
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model of  filter being saved.
         * @param {string} jql JQL of the filter being saved.
         */
        showSaveAsDialog: function(filterModel, jql) {
            this._showDialog(JIRA.Components.Filters.Views.Dialogs.SaveAs, filterModel, {
                viewOptions: {jql: jql},
                onSuccess: function(serverResponse) {
                    var newModel = new JIRA.Components.Filters.Models.Filter(serverResponse, {parse: true});
                    this.trigger('saveas:success', newModel);
                },
                onError: function(filterModel) {
                    this.trigger('saveas:error', filterModel);
                }
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/List.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.List");

    /**
     * @class JIRA.Components.Filters.Controllers.List
     *
     * This controllers displays a list of filters
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.List = JIRA.Marionette.Controller.extend({
        /**
         * Main view rendered by this controller
         * @type {JIRA.Components.Filters.Views.List.Module}
         */
        view: null,

        /**
         * @param {Object} options
         * @param {JIRA.Components.Filters.Collections.Filters} options.collection Collection of filters
         */
        initialize: function(options) {
            this.collection = options.collection;
            this.title = options.title;
            this.className = options.className;
            this.errorMessage = options.errorMessage;
            this.loadingMessage = options.loadingMessage;
            this.emptyMessage = options.emptyMessage;
            this.loginMessage = options.loginMessage;
        },

        /**
         * Displays the filter's list in the provided element
         *
         * @param {jQuery} el Container for the filter's list
         */
        show: function(el) {
            if (this.view) {
                this.close();
            }

            this.view = new JIRA.Components.Filters.Views.List.Module({
                el: el,
                title: this.title
            });
            this.view.render();

            this._showInternalView(this.collection.fetchState);
            this.listenTo(this.collection, "change:fetchState", this._showInternalView);
        },

        close: function() {
            if (this.view) {
                this.stopListening(this.collection, "change:fetchState", this._showRegion);
                this.stopListening(this.view);
                this.view.close();
                this.view = null;
            }
        },

        /**
         * Highlight a filter, unhighlights all the other filters
         *
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Model to highlight
         */
        highlightFilter: function(filterModel) {
            if (this._listView) {
                this._listView.unhighlightAllFilters();
                if (filterModel) {
                    this._listView.highlightFilter(filterModel);
                }
            }
        },

        /**
         * Displays the internal view based on the state of the filter's collection.
         *
         * @param {string} fetchState Fetch state of the collection, valid values are "error", "fetched" or ""
         * @private
         */
        _showInternalView: function(fetchState) {
            switch (fetchState) {
                case "error":
                    this._showError();
                    break;
                case "fetched":
                    this._showList();
                    break;
                default:
                    this._showLoading();
                    break;
            }
        },

        _showLoading: function() {
            this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                className: this.className,
                text: this.loadingMessage
            }));
        },

        _showError: function() {
            this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                className: this.className,
                text: this.errorMessage
            }));
        },

        _showList: function() {
            var collection = this.collection;
            if (collection.length) {
                this._showListWithItems();
            } else {
                this._showEmptyList();
            }
        },

        _getListViewConstructor: function() {
            return JIRA.Components.Filters.Views.List.List;
        },

        _showListWithItems: function() {
            var ViewConstructor = this._getListViewConstructor();
            this._listView = new ViewConstructor({
                collection: this.collection,
                className: this.className
            });
            this.view.content.show(this._listView);
            this.trigger("render");

            // When we remove the last item from the collection, render the empty list
            this.listenTo(this.collection, "remove", function f() {
                if (!this.collection.length) {
                    this.stopListening(this.collection, "remove", f);
                    this._showEmptyList();
                }
            });

            this.listenTo(this._listView, "itemview:selectFilter", function(itemView, args) {
                this.trigger("selectFilter", args.model);
            });
            this.listenTo(this._listView, "itemview:render", function() {
                this.trigger("render");
            });

            this.triggerMethod("list:render", this._listView);
        },

        _showEmptyList: function() {
            if (JIRA.Issues.LoginUtils.isLoggedIn()) {
                this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                    className: this.className,
                    text: this.emptyMessage
                }));
            } else {
                this.view.content.show(new JIRA.Components.Filters.Views.List.Message({
                    className: this.className,
                    text: this.loginMessage
                }));
            }

            // When we add a new item to the collection, render the list with items
            this.listenToOnce(this.collection, "add", function() {
                this._showListWithItems();
            });
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/ListWithActions.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.ListWithActions");

    /**
     * @class JIRA.Components.Filters.Controllers.ListWithActions
     *
     * @extends JIRA.Components.Filters.Controllers.List
     */
    JIRA.Components.Filters.Controllers.ListWithActions = JIRA.Components.Filters.Controllers.List.extend({
        /**
         * Actions view (i.e. dropdown) associated to a filter
         * @type {JIRA.Components.Filters.Views.Actions}
         */
        actionsView: null,

        _getListViewConstructor: function() {
            return JIRA.Components.Filters.Views.List.ListWithActions;
        },

        close: function() {
            this._closeActions();
            JIRA.Components.Filters.Controllers.List.prototype.close.call(this);
        },

        highlightFilter: function(filterModel) {
            this._closeActions();
            JIRA.Components.Filters.Controllers.List.prototype.highlightFilter.call(this, filterModel);
        },

        /**
         * Displays the Actions view related to a filter.
         *
         * @param {JIRA.Components.Filters.Views.List.Filter} triggerView View that triggered the actions dropdown.
         * @param {JIRA.Components.Filters.Models.Filter} filterModel Filter's model.
         * @private
         */
        _showActions: function(triggerView, filterModel) {
            var isActionsForFilterAlreadyOpen = (this.actionsView && this.actionsView.model === filterModel);
            this._closeActions();

            // If actions for this filter is already open, do not open it again
            if (!isActionsForFilterAlreadyOpen) {
                this.actionsView = new JIRA.Components.Filters.Views.Actions({
                    triggerView: triggerView,
                    model: filterModel
                });
                this.actionsView.render();

                this.listenTo(this.actionsView, "deleteFilter", function(args) {
                    this._closeActions();
                    this.trigger("deleteFilter", args.model);
                });

                this.listenTo(this.actionsView, "renameFilter", function(args) {
                    this._closeActions();
                    this.trigger("renameFilter", args.model);
                });

                this.listenTo(this.actionsView, "copyFilter", function(args) {
                    this._closeActions();
                    this.trigger("copyFilter", args.model);
                });

                this.listenTo(this.actionsView, "unfavouriteFilter", function(args) {
                    this._closeActions();
                    this.trigger("unfavouriteFilter", args.model);
                });
            }
        },

        _closeActions: function() {
            if (this.actionsView) {
                this.actionsView.close();
                this.stopListening(this.actionsView);
                this.actionsView = null;
            }
        },

        onListRender: function() {
            this.listenTo(this._listView, "itemview:selectFilter", function() {
                this._closeActions();
            });

            this.listenTo(this._listView, "itemview:openActions", function(itemView, args) {
                this._showActions(args.view, args.model);
            });
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:filters-component', location = 'content/js/components/filters/controllers/Header.js' */
(function(){
    "use strict";

    AJS.namespace("JIRA.Components.Filters.Controllers.Header");

    /**
     * @class JIRA.Components.Filters.Controllers.Header
     *
     * @extends JIRA.Marionette.Controller
     */
    JIRA.Components.Filters.Controllers.Header = JIRA.Marionette.Controller.extend({
        /**
         * @constructor
         */
        initialize: function() {
            this.view = null;
        },

        close: function() {
            if (this.view) {
                this.view.close();
                this.stopListening(this.view);
                this.view = null;
                this.trigger("close");
            }
        },

        closeDetails: function() {
            if (this.detailsView) {
                this.detailsView.close();
                this.stopListening(this.detailsView);
                this.detailsView = null;
            }
        },

        showDetails: function(triggerEl) {
            if (this.detailsView) {
                this.closeDetails();
            }

            this.detailsView = new JIRA.Components.Filters.Views.Details({
                model: this.model,
                triggerEl: triggerEl
            });
            this.listenTo(this.detailsView, "close", this.closeDetails);

            this.detailsView.render();
        },

        show: function(options) {
            if (this.view) {
                this.close();
            }

            this.view = new JIRA.Components.Filters.Views.Header({
                el: options.el
            });
            this.isInvalid = false;

            this.listenTo(this.view, {
                "saveAs": function(args) {
                    if (!JIRA.Issues.LoginUtils.isLoggedIn() || this.isInvalid) return;
                    this.trigger("saveAs", args.model);
                },
                "save": function(args) {
                    if (!JIRA.Issues.LoginUtils.isLoggedIn() || this.isInvalid) return;
                    this.trigger("save", args.model);
                },
                "discard": function() {
                    this.update({
                        isEdited: false,
                        isDirty: false
                    });
                    this.trigger("discard");
                },
                "details": function(triggerEl) {
                    this.showDetails(triggerEl);
                },
                "toogleFavourite": function(args) {
                    var model = args.model;

                    if (!model) return;

                    var currentlyFavourited = !!model.getFavourite();
                    model.saveFavourite(!currentlyFavourited);
                    // Need to add to the favourite filters collection if a filter has just been starred
                    if (!currentlyFavourited) {
                        this.trigger("favourite", model);
                    }
                },
                "close": this.close
            });

            this.update(options);
        },

        update: function(options) {
            if (!this.view) {
                return;
            }

            if (typeof options.model !== "undefined") {
                this.model = options.model;
            }

            this.isInvalid = false;

            this.view.render({
                model: this.model,
                isDirty: options.isDirty,
                isEdited: options.isEdited
            });

            this.model = options.model;
        },

        markAsInvalid: function() {
            if (this.view) {
                this.view.markAsInvalid();
            }
            this.isInvalid = true;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/templates/issuenav-filter.soy' */
// This file was automatically generated from issuenav-filter.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavFilter.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavFilter == 'undefined') { JIRA.Templates.IssueNavFilter = {}; }


JIRA.Templates.IssueNavFilter.collapsedFiltersPanel = function(opt_data, opt_ignored) {
  return '<a class="toggle-filter-panel" href="#" title="' + soy.$$escapeHtmlAttribute(AJS.format("Dock the filters panel ({0})",'[')) + '"></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavFilter.collapsedFiltersPanel.soyTemplateName = 'JIRA.Templates.IssueNavFilter.collapsedFiltersPanel';
}


JIRA.Templates.IssueNavFilter.filtersPanel = function(opt_data, opt_ignored) {
  return '<div class="filters-content"><h4 class="filter-title">' + soy.$$escapeHtml("Filters") + '</h4><ul class="filter-options"><li><a href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/issues/?jql=" class="new-search aui-button aui-button-light" title="' + soy.$$escapeHtmlAttribute("Create a new search filter") + '">' + soy.$$escapeHtml("New filter") + '</a></li><li><a class="find-filters" href="' + soy.$$escapeHtmlAttribute(soy.$$filterNormalizeUri("/jira")) + '/secure/ManageFilters.jspa?filterView=search">' + soy.$$escapeHtml("Find filters") + '</a></li></ul><div class="filter-panel-system-container"></div><div class="filter-panel-favourites-container"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavFilter.filtersPanel.soyTemplateName = 'JIRA.Templates.IssueNavFilter.filtersPanel';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterPanelView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterPanelView");

    /**
     * The collapsible filters panel.
     * <p/>
     * Lists system filters and the user's favourite filters.
     */
    JIRA.Issues.FilterPanelView = JIRA.Issues.BaseView.extend({
        events: {
            "simpleClick .system-filters a.filter-link:not(.requires-login)": "_onClickFilter",
            "simpleClick .new-search": "_onClickNewSearch",
            "click .ui-dock": "_onDockFilterPanelClick",
            "click .ui-undock": "_onUndockFilterPanelClick"
        },

        collapsedTemplate: JIRA.Templates.IssueNavFilter.collapsedFiltersPanel,

        template: JIRA.Templates.IssueNavFilter.filtersPanel,

        /**
         * @param {object} options
         */
        initialize: function(options) {

            _.bindAll(this, "adjustFavouriteFiltersHeight");
            if (options.easeOff) {
                this._adjustFavouriteFiltersHeight = _.debounce(this._adjustFavouriteFiltersHeight, options.easeOff);
            }
            JIRA.Issues.onVerticalResize(this.adjustFavouriteFiltersHeight);

            // Resolved when system and favourite filters are rendered
            this.panelReady = new jQuery.Deferred();

            JIRA.bind(JIRA.Events.LAYOUT_RENDERED, _.bind(function() {
                this._splitViewSidebarElement = AJS.$(".list-results-panel:first");
            }, this));
        },

        /**
         * Adjust the height of the favourite filters list.
         *
         * @private
         */
        adjustFavouriteFiltersHeight: function() {
            var feedbackLinkHeight = AJS.$(".jira-feedback-link-container.subtle-style").outerHeight(true);
            var feedbackLinkOffset = feedbackLinkHeight ? feedbackLinkHeight + 10 : 0;
            var filterList = this.$(".favourite-filters");
            var filterListTop = filterList.length && filterList.offset().top;
            var windowHeight = window.innerHeight;

            filterList.css("height", windowHeight - filterListTop - feedbackLinkOffset);
        },

        /**
         * When the dock filter link is clicked
         * @private
         */
        _onDockFilterPanelClick: function() {
            AJS.$('.navigator-container').removeClass('navigator-sidebar-collapsed');
        },

        /**
         * When the undock filter link is clicked.
         * @private
         */
        _onUndockFilterPanelClick: function() {
            AJS.$('.navigator-container').addClass('navigator-sidebar-collapsed');
        },

        toggleDockState: function() {
            this.$el.popoutSidebar("toggle");
        },

        _onClickFilter: function(e) {
            e.preventDefault();
            var filterId = jQuery(e.target).data("id");
            this.trigger("filterSelected", filterId);
        },

        _onClickNewSearch: function(e) {
            e.preventDefault();
            this.trigger("filterSelected", null);
        },

        render: function() {
            if (!this.model.isDocked()) {
                AJS.$('.navigator-container').addClass('navigator-sidebar-collapsed');
                this._renderCollapsed();
            } else {
                AJS.$('.navigator-container').removeClass('navigator-sidebar-collapsed');
                this._renderOpen();
            }

            var dockingShortcut = AJS.KeyboardShortcut.getKeyboardShortcutKeys('toggle.filter.panel');
            this.$el.popoutSidebar({
                isDocked: this.model.isDocked(),
                expandedWidth: this.model.getWidth(),
                renderExpanded: _.bind(this._renderOpen, this),
                renderCollapsed: _.bind(this._renderCollapsed, this),
                undockText: "Undock",
                undockTitle: AJS.format("Undock the filter panel so it is hidden when not being focused (Type \'\'{0}\'\')", dockingShortcut),
                dockText: "Dock",
                dockTitle: AJS.format("Dock the filter panel so you can always see the list of filters (Type \'\'{0}\'\')", dockingShortcut),
                toggleTarget: ".filter-title:first",
                persist: _.bind(function(isDocked, width) {
                    this.model.setDocked(isDocked);
                    this.model.setWidth(width);
                }, this),
                resize: _.bind(function() {
                    if (this._splitViewSidebarElement) this._splitViewSidebarElement.sidebar("updatePosition");
                }, this)
            });

            if (this.model.shouldShowDockIntro()) {
                this.$el.popoutSidebar("collapse", false);
            }

            if (this.model.isDocked()) {
                this.$el.popoutSidebar("renderDockState");
            }
            this._fireDockAnalytics();
            this.panelReady.resolve();

            return this.$el;
        },

        _fireDockAnalytics: function() {
            if (localStorage.getItem("dockStatesAnalyticsEnabled")) {
                var docked = this.model.isDocked();
                if (localStorage.getItem("dockStateAnalytic") !== "" + docked) {
                    localStorage.setItem("dockStateAnalytic", docked);
                    JIRA.Issues.Application.execute("analytics:trigger", "kickass.filters.docked", {
                        isDocked: this.model.isDocked()
                    });
                }
            }
        },

        /**
         * Render the collapsed filter panel.
         *
         * @return {JIRA.Issues.FilterPanelView} <tt>this</tt>
         * @private
         */
        _renderCollapsed: function() {
            var $feedback = jQuery(".jira-feedback-link-container.subtle-style").detach().addClass("left noborder");
            this.$el.addClass("collapsed").html(this.collapsedTemplate({isDocked: this.model.isDocked()}));
            this.trigger("renderCollapsed");
            JIRA.Issues.triggerHorizontalResize();
            $feedback.appendTo("body");
            return this;
        },

        /**
         * Render the open filter panel.
         *
         * @return {JIRA.Issues.FilterPanelView} <tt>this</tt>
         * @private
         */
        _renderOpen: function() {
            var $feedback = jQuery(".jira-feedback-link-container.subtle-style").detach().removeClass("left noborder");
            this.$el.removeClass("collapsed");

            this.$el.width(this.model.getWidth());
            this.$el.html(this.template({}));

            this.trigger("renderOpen");
            $feedback.appendTo(this.$el);

            JIRA.trigger(JIRA.Events.NEW_CONTENT_ADDED, [this.$el, JIRA.CONTENT_ADDED_REASON.filterPanelOpened]);
            JIRA.Issues.triggerHorizontalResize();
            return this;
        },

        _renderSelectedFilter: function() {
            //FIXME Disabled until both views are moved to FilterComponent
            //this.favouriteFiltersController.activateFilter(this.model.get("activeFilter"));
            //this.systemFilters.activateFilter(this.model.get("activeFilter"));
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/Browser.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.Browser");

    /** @deprecated */
    JIRA.Issues.Browser = {
        /** @deprecated since JIRA 6.3. Use window.innerWidth if you absolutely need to know. You shouldn't, though. */
        getWindowWidth: function() {
            return window.innerWidth;
        }
    };
}(AJS.$));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterPanelModel.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterPanelModel");

    var IS_DOCKED_STORAGE_KEY = "issues.sidebar.docked";
    var WIDTH_STORAGE_KEY = "issues.sidebar.width";

    /**
     * The state of the filters panel: favourite filter data, system filter data
     * .
     */
    JIRA.Issues.FilterPanelModel = JIRA.Issues.BaseModel.extend({
        properties: [
            "activeFilter"
        ],

        defaults: {
            "activeFilter": null
        },

        /**
         * @param {object} attributes
         * @param {object} options
         * @param {object[]} options.systemFilters
         */
        initialize: function(attributes, options) {
            _.extend(this, _.defaults(options, {
                storage: window.localStorage
            }));
        },

        setDocked: function(state) {
            this._getStorage().setItem("dockStatesAnalyticsEnabled", true);
            return this._getStorage().setItem(IS_DOCKED_STORAGE_KEY, state);
        },

        setWidth: function(width) {
            return this._getStorage().setItem(WIDTH_STORAGE_KEY, width);
        },

        getWidth: function() {
            var storedWidth = parseInt(this._getStorage().getItem(WIDTH_STORAGE_KEY), 10);
            return ((storedWidth > 0) ? storedWidth : 200);
        },


        _getStorage: function() {
            return this.storage || window.localStorage;
        },

        isDockedPrefGiven: function() {
            return this._getStorage().getItem(IS_DOCKED_STORAGE_KEY) !== null;
        },

        shouldShowDockIntro: function() {
            return !this.isDocked() && !this.isDockedPrefGiven();
        },

        isExpanded: function() {
            //Showing dock intro should collapse the filter panel
            return this.shouldShowDockIntro() ? false : this.isDocked();
        },

        /**
         *
         * @return {boolean}
         */
        isDocked: function() {
            var storage = this._getStorage();
            //dock the sidebar by default or if the user has chosen to do so.
            return storage.getItem(IS_DOCKED_STORAGE_KEY) == null || storage.getItem(IS_DOCKED_STORAGE_KEY) === "true";
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/filters/FilterModule.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.FilterModule");

    /**
     * Interface to the filter system.
     */
    JIRA.Issues.FilterModule = JIRA.Issues.BaseEvented.extend({
        initialize: function(options) {
            this._searchPageModule = options.searchPageModule;

            this.filterPanelModel = options.filterPanelModel || new JIRA.Issues.FilterPanelModel({}, {
                searchPageModule: options.searchPageModule
            });

            this.filtersComponent = new JIRA.Components.Filters({
                systemFilters: options.systemFilters,
                searchPageModule: this._searchPageModule
            });

            this.filtersComponent.on("newFilter", function(newFilterModel) {
                this._searchPageModule.filterModuleSaved(newFilterModel);

                if (JIRA.Issues.Application.request("issueEditor:canDismissComment")) {
                    this._searchPageModule.setSessionSearch(newFilterModel);
                }
            }, this);

            this.filtersComponent.on("filterRemoved", function(args) {
                this.trigger("filterRemoved", args);
            }, this);

            this.filtersComponent.on("filterUnfavourited", function(args) {
                this.trigger("filterUnfavourited", args);
            }, this);

            this.filtersComponent.on("filterSelected", this._onFilterSelected, this);

            this.filtersComponent.on("filterDiscarded", function() {
                this._searchPageModule.discardFilterChanges();
            }, this);

            this.filtersComponent.on("savedFilter", function(filterModel) {
                this._searchPageModule.setSessionSearch(filterModel);
                this.filtersComponent.highlightFilter(filterModel);
            }, this);

            this.filtersComponent.on("list:render", function() {
                var currentFilter = this._searchPageModule.getFilter();
                if (currentFilter) {
                    var filterToActivateId = currentFilter.id;
                    var filterToActivate = this.filtersComponent.getFilterByIdFromExistingCollections(filterToActivateId);
                    this.filterPanelModel.set("activeFilter", filterToActivate);
                }
            }, this);

            this._searchPageModule.on('change changeFilterProps', function() {
                this.filtersComponent.updateFilterHeader({
                    model: this._searchPageModule.getFilter(),
                    isPendingSearch: false,
                    isEdited: this._searchPageModule.isDirty()
                });
            }, this);

            this.filtersComponent.fetchFavouriteFilters();

            this.filterPanelModel.bind("change:activeFilter", this._markFilterAsActive, this);
            this.filterPanelModel.set("activeFilter", this._searchPageModule.getFilter());
            this._searchPageModule.bind("change:filter", function(searchPageModule, newFilter) {
                this.filterPanelModel.set("activeFilter", newFilter);
            }, this);
        },

        canEditColumns: function() {
            var filter = this._searchPageModule.getFilter();
            return filter && filter.isMyFilter();
        },

        /**
         * Retrieve system filter information via AJAX.
         * <p/>
         * System filter information is not present on the stand alone view issue page.
         *
         * @return {jQuery.Deferred} a deferred that is resolved after system filter information has been retrieved.
         */
        initSystemFilters: function() {
            return this.filtersComponent.fetchSystemFilters();
        },

        /**
         * Finds the filter with the given id. Attempts to fetch from the server if it does not exist. Returns a promise.
         */
        getFilterById: function(filterId) {
            return this.filtersComponent.getFilterById(filterId);
        },

        /**
         * Creates a FilterPanelView and renders it into the provided elements
         * @param els - a map of elements
         */
        createView: function(els) {
            this.filterPanelView = new JIRA.Issues.FilterPanelView({
                el: els.$filterPanelEl,
                model: this.filterPanelModel,
                searchPageModule: this._searchPageModule,
                easeOff: (!!jQuery.browser.msie && jQuery.browser.version <= 8) ? 500 : 0
            });

            this.filterPanelView.on("renderOpen", function() {
                this.filtersComponent.showSystemFilters(this.filterPanelView.$el.find(".filter-panel-system-container"));
                this.filtersComponent.showFavouriteFilters(this.filterPanelView.$el.find(".filter-panel-favourites-container"));
                this._markFilterAsActive();
                this.filterPanelView.adjustFavouriteFiltersHeight();
            }, this);

            this.filterPanelView.on("filterSelected", this._onFilterSelected, this);

            this.filterPanelView.render();

            return this.filterPanelView;
        },

        _markFilterAsActive: function() {
            var activeFilter = this.filterPanelModel.get("activeFilter");
            this.filtersComponent.highlightFilter(activeFilter);
        },

        toggleFilterPanel: function() {
            this.filterPanelView.toggleDockState();
        },

        createHelptipForFilterPanelDocking: function(weight) {
            var tip;
            var filterPanelModel = this.filterPanelModel;
            var filterPanelView = this.filterPanelView;

            if (filterPanelModel.shouldShowDockIntro() && filterPanelView.$el.is(":visible")) {
                tip = new AJS.HelpTip({
                    id: "filters-dock-intro",
                    title: "Did you notice?",
                    bodyHtml: "You can dock the filter bar to always show your list of filters.",
                    anchor: ".ui-dock",
                    isSequence: true,
                    weight: weight,
                    callbacks: {
                        beforeShow: function() {
                            filterPanelView.$el.popoutSidebar("expand", false);
                        },
                        init: function() {
                            if (filterPanelView.$el.popoutSidebar("isUndocked")) {
                                filterPanelView.$el.popoutSidebar("unbindHoverIntent");
                            }
                        },
                        hide: function() {
                            if (filterPanelView.$el.popoutSidebar("isUndocked")) {
                                filterPanelView.$el.popoutSidebar("bindHoverIntent");
                                filterPanelView.$el.popoutSidebar("collapse");
                            }
                        }
                    }
                });
            }
            return tip;
        },

        _onFilterSelected: function(filterId) {
            if (filterId === null) {
                this._searchPageModule.resetToBlank({isNewSearch: true});
            } else {
                this._searchPageModule.resetToFilter(filterId);
            }
        },
        
        updateFilterHeader: function(options) {
            options = options || {};
            var isEdited = options.isEdited || false;
            var isPendingSearch = options.isPendingSearch || false;

            this.filtersComponent.updateFilterHeader({
                isEdited: isEdited,
                isDirty: isPendingSearch
            });
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-filter', location = 'content/js/search/util/WindowPositioning.js' */
(function() {
    "use strict";

    /**
     * An <tt>AJS.InlineLayer</tt> positioning controller that ensures the layer doesn't overflow the bottom of the window.
     */
    JIRA.Issues.WindowPositioning = AJS.InlineLayer.StandardPositioning.extend({
        /**
         * @param {object} offset The offset from which to calculate the overflow.
         * @return {Number} The amount by which the layer overflows the window.
         * @private
         */
        _calculateOverflow: function(offset) {
            var isFixed = this.layer().css("position") === "fixed";
            var layerBottom = offset.top + this.layer().outerHeight(true);
            var windowHeight = window.innerHeight;
            var windowScroll = jQuery(window).scrollTop();

            if (isFixed) {
                return Math.max(0, layerBottom - windowHeight);
            } else {
                return Math.max(0, layerBottom - windowScroll - windowHeight);
            }
        },

        left: function() {
            var offset = this._super();
            var overflow = this._calculateOverflow(offset);

            if (overflow > 0) {
                offset.left += this.offsetTarget().outerWidth();
                offset.top -= overflow;
            }

            return offset;
        },

        right: function() {
            var offset = this._super();
            var overflow = this._calculateOverflow(offset);

            if (overflow > 0) {
                offset.left -= this.offsetTarget().outerWidth();
                offset.top -= overflow;
            }

            return offset;
        }
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common-templates', location = 'content/templates/issuenav.soy' */
// This file was automatically generated from issuenav.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNav.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNav == 'undefined') { JIRA.Templates.IssueNav = {}; }


JIRA.Templates.IssueNav.issueTable = function(opt_data, opt_ignored) {
  return '<thead><tr></tr></thead><tbody></tbody>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.issueTable.soyTemplateName = 'JIRA.Templates.IssueNav.issueTable';
}


JIRA.Templates.IssueNav.columnHeader_issuetype = function(opt_data, opt_ignored) {
  return '<th class="issue-type issue-icon-result persist-result"><div>' + soy.$$escapeHtml("T") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_issuetype.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_issuetype';
}


JIRA.Templates.IssueNav.column_issuetype = function(opt_data, opt_ignored) {
  return '<td class="issue-type issue-icon-result persist-result"><img src="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.iconUrl) + '" alt="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.name) + '" title="' + soy.$$escapeHtml(opt_data.issue.fields.issuetype.description) + '" align="absmiddle" border="0" height="16" width="16"></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_issuetype.soyTemplateName = 'JIRA.Templates.IssueNav.column_issuetype';
}


JIRA.Templates.IssueNav.columnHeader_keysummary = function(opt_data, opt_ignored) {
  return '<th class="issue-key persist-result"><div>' + soy.$$escapeHtml("Key") + '</div></th><th class="issue-summary issue-text-result persist-result"><div>' + soy.$$escapeHtml("Summary") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_keysummary.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_keysummary';
}


JIRA.Templates.IssueNav.column_keysummary = function(opt_data, opt_ignored) {
  return '<td class="issue-key-summary issue-text-result persist-result" colspan="2"><div><a href="' + soy.$$escapeHtml(opt_data.contextPath) + '/browse/' + soy.$$escapeHtml(opt_data.issue.key) + '" class="issue"><span class="secondary-text">' + soy.$$escapeHtml(opt_data.issue.key) + '</span>' + soy.$$escapeHtml(opt_data.issue.fields.summary) + '</a></div></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_keysummary.soyTemplateName = 'JIRA.Templates.IssueNav.column_keysummary';
}


JIRA.Templates.IssueNav.columnHeader_status = function(opt_data, opt_ignored) {
  return '<th class="issue-status"><div>' + soy.$$escapeHtml("Status") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_status.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_status';
}


JIRA.Templates.IssueNav.column_status = function(opt_data, opt_ignored) {
  return '<td class="issue-status"><div class="status-lozenge">' + soy.$$escapeHtml(opt_data.issue.fields.status.name) + '</div></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_status.soyTemplateName = 'JIRA.Templates.IssueNav.column_status';
}


JIRA.Templates.IssueNav.columnHeader_assignee = function(opt_data, opt_ignored) {
  return '<th class="issue-user"><div>' + soy.$$escapeHtml("Assignee") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_assignee.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_assignee';
}


JIRA.Templates.IssueNav.column_assignee = function(opt_data, opt_ignored) {
  return '<td class="issue-user">' + ((opt_data.issue.fields.assignee) ? '<img src="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.avatarUrls['16x16']) + '" alt="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.name) + '" height="16" width="16" /><a class="user-hover" rel="' + soy.$$escapeHtml(opt_data.issue.fields.assignee.name) + '" href="#">' + soy.$$escapeHtml(opt_data.issue.fields.assignee.displayName) + '</a>' : soy.$$escapeHtml("Unassigned")) + '</td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_assignee.soyTemplateName = 'JIRA.Templates.IssueNav.column_assignee';
}


JIRA.Templates.IssueNav.columnHeader_updated = function(opt_data, opt_ignored) {
  return '<th class="issue-datetime"><div>' + soy.$$escapeHtml("Updated") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_updated.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_updated';
}


JIRA.Templates.IssueNav.column_updated = function(opt_data, opt_ignored) {
  return '<td class="issue-datetime"><time datetime="' + soy.$$escapeHtml(opt_data.issue.fields.updated) + '">' + soy.$$escapeHtml(opt_data.TMP_FORMATTED_DATE) + '</time></td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_updated.soyTemplateName = 'JIRA.Templates.IssueNav.column_updated';
}


JIRA.Templates.IssueNav.columnHeader_resolution = function(opt_data, opt_ignored) {
  return '<th class="issue-resolution"><div>' + soy.$$escapeHtml("Resolution") + '</div></th>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.columnHeader_resolution.soyTemplateName = 'JIRA.Templates.IssueNav.columnHeader_resolution';
}


JIRA.Templates.IssueNav.column_resolution = function(opt_data, opt_ignored) {
  return '<td class="issue-resolution">' + ((opt_data.issue.fields.resolution) ? soy.$$escapeHtml(opt_data.issue.fields.resolution.name) : soy.$$escapeHtml("Unresolved")) + '</td>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.column_resolution.soyTemplateName = 'JIRA.Templates.IssueNav.column_resolution';
}


JIRA.Templates.IssueNav.issueResultsError = function(opt_data, opt_ignored) {
  return '<tr class="error"><td colspan="' + soy.$$escapeHtml(opt_data.columnCount) + '">' + soy.$$escapeHtml(opt_data.errorText) + '</td></tr>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNav.issueResultsError.soyTemplateName = 'JIRA.Templates.IssueNav.issueResultsError';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/ColumnPicker.js' */
(function(){
    "use strict";

    /**
     * A module that adds the issue nav specific logic to the generic column picker.
     */
    JIRA.Issues.ColumnPicker = JIRA.Components.ColumnPicker.extend({

        initialize: function (attr, options) {
            var providers = [this._getUserColumnProvider(), this._getFilterColumnProvider()];
            if (JIRA.isAdmin()) {
                providers.push(this._getSystemColumnProvider());
            }
            JIRA.Components.ColumnPicker.prototype.initialize.call(this, null, {
                providers: providers
            });
            this.search = options.search;
            this.search.on("change:filter", function() {
                var filterModel = this.filterColumn;
                var isEditDisabled = filterModel.isEditDisabled();
                var isColumnConfigDisabled = filterModel.isDisabled();
                filterModel.trigger("change:isDisabled", filterModel, isColumnConfigDisabled);
                filterModel.trigger("change:editDisabled", filterModel, isColumnConfigDisabled || isEditDisabled);
            }, this);
        },

        /**
         * Is the system filter column config in play.
         * @returns {boolean}
         */
        isSystemMode: function () {
          return this.columnPickerModel.getColumnConfig() === "system";
        },

        sanitizeColumnConfig: function(columnConfig) {
            columnConfig = columnConfig.toLowerCase();
            var shouldOverrideSystem = columnConfig === "system" && !this.isSystemMode();
            return shouldOverrideSystem ? "user" : columnConfig;
        },

        syncColumns: function(newColumnConfigName, columns) {
            newColumnConfigName = this.sanitizeColumnConfig(newColumnConfigName);
            return JIRA.Components.ColumnPicker.prototype.syncColumns.call(this, newColumnConfigName, columns);
        },

        clearFilterConfiguration: function() {
            this.filterColumn.unset('columns');
            this.filterColumn.unset('savedColumns');
        },

        setCurrentColumnConfig: function(columnConfig) {
            columnConfig = this.sanitizeColumnConfig(columnConfig);
            return JIRA.Components.ColumnPicker.prototype.setCurrentColumnConfig.call(this, columnConfig);
        },

        _getFilterColumnProvider: function() {
            var instance = this;
            this.filterColumn = JIRA.Issues.ColumnConfigModel.create(
                "filter",
                "Filter",
                {
                    url: function() {
                        return AJS.contextPath() + '/rest/api/2/filter/' + instance.search.getState().filter + '/columns';
                    },
                    isDisabled: function() {
                        return !instance.search.getFilter() || instance.search.getFilter().getIsSystem();
                    },
                    isEditDisabled: function() {
                        return !instance.search.filterModule.canEditColumns();
                    },
                    shouldRefreshSearchOnActivation: function() {
                        //If the filter has configured columns, refresh the search on activation
                        return this.has("savedColumns");
                    },
                    shouldCloseOnActivation: function() {
                        //If the filter has configured columns, close the column picker on activation
                        return this.has("savedColumns");
                    },
                    shouldLoadDefaultsOnActivation: function() {
                        //If the filter has not  configured columns, load the default columns
                        return !this.has("savedColumns");
                    },
                    defaultColumns: _.bind(function(){
                        //If a filter doesn't have columns, then it will use the user columns by default
                        //Need to retrieve the user columns and set that as the selected columns
                        if (this.userColumns.has("columns")) {
                            var deferred = new jQuery.Deferred();
                            deferred.resolve(_.map(this.userColumns.getColumns(), function(item){return {value: item};}));
                            return deferred.promise();
                        } else {
                            return jQuery.ajax(this.userColumns.url()).promise();
                        }
                    }, this)
                }
            );
            return this.filterColumn;
        },

        _getSystemColumnProvider: function() {
            //Adding a toggle for 'system' columns if user is an admin

            return JIRA.Issues.ColumnConfigModel.create(
                "system",
                "System",
                {
                    url: _.lambda(AJS.contextPath() + '/rest/api/2/settings/columns'),
                    defaultColumns: function(){
                        //Load columns from our REST endpoint
                        return jQuery.ajax(this.url()).promise();
                    },
                    shouldRefreshSearchOnActivation: function() {
                        //Always refresh the search on activation
                        return true;
                    },
                    shouldCloseOnActivation: function() {
                        //Never close the column picker on activation
                        return false;
                    },
                    shouldLoadDefaultsOnActivation: function() {
                        //Always load the default columns
                        return true;
                    },
                    shouldRevertOnHide: function() {
                        return false;
                    }
                }
            );
        },

        _getUserColumnProvider: function() {
            this.userColumns = JIRA.Issues.ColumnConfigModel.create("user",
                "My Defaults",
                {
                    url: _.lambda(AJS.contextPath() + '/rest/api/2/user/columns')
                }
            );
            return this.userColumns;
        }
    });

    JIRA.Issues.ColumnPicker.create = function (options) {
       return new JIRA.Issues.ColumnPicker(null, options);
    };
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/IssueTableView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.IssueTableView");

    /**
     * The issue table rendered in <tt>JIRA.Issues.FullScreenLayout</tt>.
     */
    JIRA.Issues.IssueTableView = JIRA.Issues.BaseView.extend({
        _closeSystemModeMessage: function() {
            if (this.currentMessage) {
                this.currentMessage.close();
                this.currentMessage = null;
            }
        },

        _showSystemModeMessage: function() {
            if (this.currentMessage) return; // Message already there, not need to display a new one

            var flag = require("jira/flag");
            var $msg = flag.showMsg('', "You are on System Mode. The column changes might affect all users. \u003ca href=# class=exit\u003eExit System Mode\u003c/a\u003e.", {
                type: 'warning',
                close: 'never'
            });

            AJS.$($msg).find(".exit").click(_.bind(function(e) {
                e.preventDefault();
                this.columnConfig.setCurrentColumnConfig("user");
                this._closeSystemModeMessage();
            }, this));

            this.currentMessage = $msg;
        },

        syncSystemModeMessage: function() {
            var isSystemMode = this.columnConfig.isSystemMode();
            if (isSystemMode) {
                this._showSystemModeMessage();
            } else {
                this._closeSystemModeMessage();
            }
        },

        /**
         * @param {object} options
         * @param {JIRA.Issues.SearchModule} options.search The application's <tt>JIRA.Issues.SearchModule</tt> instance.
         * @param {JIRA.Issues.SearchResults} options.searchResults The application's <tt>JIRA.Issues.SearchResults</tt> instance.
         */
        initialize: function(options) {
            this.columnConfig = options.columnConfig;
            this.columnConfig.on("change:columnConfig", this.syncSystemModeMessage, this);
            JIRA.Issues.onVerticalResize(_.bind(this.adjustColumnConfigHeight, this));
        },

        /**
         * Prepare to be removed, unbinding all event handlers, etc.
         */
        deactivate: function() {
            JIRA.Issues.offVerticalResize(this.adjustColumnConfigHeight);
        },

        /**
         * Render the issue table after a search completes.
         * <p/>
         * Called when an operation in <tt>searchPromise</tt> completes.
         *
         * @param {object} el The search payload.
         * @private
         */
        _onSearchDone: function(el) {
            this.columnConfig.setElement(el.find(".column-picker-trigger-container")).render();
        },

        adjustColumnConfigHeight: function() {
            this.columnConfig.adjustHeight();
        }
    });

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-table', location = 'content/js/components/table/HeaderOperationsView.js' */
(function(){
    "use strict";

    /**
     * Handles adding an ajax-backed dialog to the tools menu
     */
    JIRA.Issues.IssueTableHeaderOperationsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            _.bindAll(this,
                "_onSearchSuccess",
                "_updateFilterPageResources");

            _.extend(this, options);
            this.initTools();
            this.initViews();
            this.initShare();

            this._results = this.search.getResults();
            this._results.onNewPayload(this._onSearchSuccess);
        },

        initViews: function() {
            var searchPageModule = this.searchPageModule;
            searchPageModule.on("change", this._updateFilterPageResources);
            this._updateFilterPageResources();

            new JIRA.Issues.Tipsy({
                el: this.$el.find(".header-views"),
                showCondition: ":not(.active)"
            });

            var spinnerTimeout = this._spinnerTimeoutKeeper(".header-views");

            AJS.Dropdown.create({
                styleClass: 'header-views-menu aui-style-default',
                trigger: AJS.$(".header-views", this.$el),
                ajaxOptions: function() {
                    var data = {jql: searchPageModule.getEffectiveJql()};
                    var filter = searchPageModule.getFilter();

                    if (filter && !filter.getIsSystem()) {
                        data.filterId = filter.getId();
                        if (searchPageModule.isDirty()) {
                            data.jql = searchPageModule.getJql();
                            data.modified = true;
                        }
                    }
                    spinnerTimeout.start();

                    return {
                        url: AJS.contextPath() + "/rest/issueNav/1/issueNav/operations/views",
                        type: "POST",
                        headers: JIRA.Issues.XsrfTokenHeader,
                        data: data,
                        dataType: "json",
                        cache: false,
                        formatSuccess: function(data) {
                            spinnerTimeout.end();
                            return AJS.$(JIRA.Templates.IssueNavTable.views({
                                sections: data,
                                contextPath: AJS.contextPath()
                            }));
                        }
                    };
                }
            });
        },

        initTools: function () {
            var instance = this;
            var searchPageModule = this.searchPageModule;

            // override use-cols click to use user columns
            AJS.$("body").delegate("#use-cols", "click", function(e) {
                e.preventDefault();
                instance.searchPageModule.columnConfig.setCurrentColumnConfig("user");
                instance.searchPageModule.columnConfig.refreshSearchWithColumns();
            });

            // override use-filter-cols click to use filter columns
            AJS.$("body").delegate("#use-filter-cols", "click", function(e) {
                e.preventDefault();
                instance.searchPageModule.columnConfig.setCurrentColumnConfig("filter");
                instance.searchPageModule.columnConfig.refreshSearchWithColumns();
            });

            new JIRA.Issues.Tipsy({
                el: this.$el.find(".header-tools"),
                showCondition: ":not(.active)",
                tipsy: {
                    gravity: "ne"
                }
            });
            var spinnerTimeout = this._spinnerTimeoutKeeper(".header-tools");

            AJS.Dropdown.create({
                styleClass: 'header-tools-menu',
                trigger: AJS.$(".header-tools", instance.$el),
                ajaxOptions: function() {
                    var data;
                    var filter = searchPageModule.getFilter();

                    data = {
                        jql: searchPageModule.getEffectiveJql(),
                        searchResultsTotal: instance._results.getTotal(),
                        searchResultsPages: instance._results.getNumberOfPages(),
                        useColumns: instance.searchPageModule.columnConfig.getCurrentColumnConfig().getName() !== "user",
                        skipColumns: searchPageModule.getActiveLayout().id === "split-view" //Skip columns for split-view
                    };

                    if (filter && !filter.getIsSystem()) {
                        data.filterId = filter.getId();
                        if (searchPageModule.isDirty()) {
                            data.jql = searchPageModule.getJql();
                        }
                    }

                    spinnerTimeout.start();

                    return {
                        url: AJS.contextPath() + "/rest/issueNav/1/issueNav/operations/tools",
                        type: "POST",
                        headers: JIRA.Issues.XsrfTokenHeader,
                        data: data,
                        dataType: "json",
                        cache: false,
                        formatSuccess: function(data) {
                            spinnerTimeout.end();
                            if(data && data.length === 0) {
                                return AJS.$('<div class="menu-empty-content"></span>' + "No Available Option(s)" + '<div>');
                            } else {
                                return AJS.$(JIRA.Templates.IssueNavTable.tools({
                                    groups: data,
                                    contextPath: AJS.contextPath()
                                }));
                            }
                        }
                    };
                }
            });
        },

        initShare: function() {
            //Init the tipsy tooltip for the share button
            new JIRA.Issues.Tipsy({
                el: this.$el.find(".issuenav-share"),
                showCondition: ":not(.active)"
            });
        },

        _onSearchSuccess: function() {
            //JRADEV-18219 Only hide header-tools. header-views should always be visible, even for searches with 0 results
            AJS.$(".header-tools").toggleClass('hidden', this.search.getResults().getDisplayableTotal() === 0);
        },

        _updateFilterPageResources: function() {
            // These hidden input params are used by javascript in com.atlassian.jira.gadgets:searchrequestview-charts
            // to load custom dialogs for chart / dashboard view menu items
            // The '.operations-view-data .parameters' element updates AJS.params, which is a legacy bus for passing
            // variables around the page
            var $fieldset = this.$el.find('.operations-view-data > fieldset');
            var searchPageModule = this.searchPageModule;

            $fieldset.empty();

            if (searchPageModule.getFilter() && !searchPageModule.isDirty()) {
                AJS.$('<input type="hidden" id="filterId" />').val(searchPageModule.getFilter().getId()).appendTo($fieldset);
                AJS.$('<input type="hidden" id="jql" />').val("").appendTo($fieldset);
            }
            else {
                AJS.$('<input type="hidden" id="filterId" />').val("");
                AJS.$('<input type="hidden" id="jql" />').val(searchPageModule.getJql()).appendTo($fieldset);
            }

            // The gadgets and share plugins (possibly others) get the current
            // filter/JQL from this metadata. Both plugins ignore filter-jql if
            // filter-id is set, so we only set the latter for modified filters.
            var filter = searchPageModule.getFilter();
            var filterID = filter && filter.getId();

            if (filterID && !filter.getIsSystem() && !searchPageModule.isDirty()) {
                AJS.Meta.set("filter-id", filterID);
                AJS.Meta.set("filter-jql", undefined);
            } else {
                AJS.Meta.set("filter-id", undefined);
                AJS.Meta.set("filter-jql", searchPageModule.getEffectiveJql());
            }
        },

        /**
         * Utility timeout keeper container for starting and ending the spinner icon on dropdown menu
         */
        _spinnerTimeoutKeeper: function(element) {
            var spinnerTimeout;

            return {
                start: function() {
                    if (spinnerTimeout) {
                        spinnerTimeout = clearTimeout(spinnerTimeout);
                    }
                    spinnerTimeout = setTimeout(function() {
                        spinnerTimeout = undefined;
                        AJS.$(element).addClass("spinner");
                    }, 1000);
                },

                end: function() {
                    spinnerTimeout = clearTimeout(spinnerTimeout);
                    AJS.$(element).removeClass("spinner");
                }
            };
        }
    });
}());
;
;
/* module-key = 'jira.webresources:jqlautocomplete', location = '/includes/jira/autocomplete/JQLAutoComplete.js' */
define('jira/jql/jql-grammar', function() {
    "use strict";

    /** @exports jira/jql/jql-grammar */
    var grammar = {};

    /** @type {JqlObject[]} */
    grammar.jql_order_by = [
        {value: "ORDER BY", displayName: "ORDER BY"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_operators = [
        {value: "=", displayName: "="},
        {value: "!=", displayName: "!="},
        {value: "~", displayName: "~"},
        {value: "<=", displayName: "&lt;="},
        {value: ">=", displayName: "&gt;="},
        {value: ">", displayName: "&gt;"},
        {value: "<", displayName: "&lt;"},
        {value: "!~", displayName: "!~"},
        {value: "is not", displayName: "is not"},
        {value: "is", displayName: "is"},
        {value: "not in", displayName: "not in"},
        {value: "in", displayName: "in"},
        {value: "was", displayName: "was"},
        {value: "was not", displayName: "was not"},
        {value: "was in", displayName: "was in"},
        {value: "was not in", displayName: "was not in"},
        {value: "changed", displayName: "changed"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_logical_operators = [
        {value: "AND", displayName: "AND"},
        {value: "OR", displayName: "OR"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_logical_operators_and_order_by = grammar.jql_logical_operators.concat(grammar.jql_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_order_by_direction = [
        {value: "ASC", displayName: "ASC"},
        {value: "DESC", displayName: "DESC"}
    ];
    /** @type {JqlObject[]} */
    grammar.empty_operand = [
        {value: "EMPTY", displayName: "EMPTY", types: ["java.lang.Object"]}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_not_logical_operator = [
        {value: "NOT", displayName: "NOT"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates = [
        {value: "AFTER", displayName: "AFTER", type: "java.util.Date", supportsList: "false"},
        {value: "BEFORE", displayName: "BEFORE", type: "java.util.Date", supportsList: "false"},
        {value: "BY", displayName: "BY", type: "com.atlassian.crowd.embedded.api.User", supportsList: "false", auto: "true"},
        {value: "DURING", displayName: "DURING", type: "java.util.Date", supportsList: "true"} ,
        {value: "ON", displayName: "ON", type: "java.util.Date", supportsList: "false"}
    ];
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates = grammar.jql_was_predicates.concat([
        {value: "FROM", displayName: "FROM", type: "java.lang.String", supportsList: "true", auto: "true"},
        {value: "TO", displayName: "TO", type: "java.lang.String", supportsList: "true", auto: "true"}
    ]);
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates_and_order_by = grammar.jql_was_predicates.concat(grammar.jql_logical_operators_and_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_was_predicates_and_logical_operators = grammar.jql_was_predicates.concat(grammar.jql_logical_operators);
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates_and_order_by = grammar.jql_changed_predicates.concat(grammar.jql_logical_operators_and_order_by);
    /** @type {JqlObject[]} */
    grammar.jql_changed_predicates_and_logical_operators = grammar.jql_changed_predicates.concat(grammar.jql_logical_operators);

    grammar.REGEXP_ANDS = /^AND\s/i;
    grammar.REGEXP_ORS = /^OR\s/i;
    grammar.REGEXP_NOTS = /^NOT\s/i;
    grammar.REGEXP_SNOT = /^\s+not/i;
    grammar.REGEXP_SIN = /^\s+in/i;
    grammar.REGEXP_SNOT_IN = /^\s+(not\s+in|not|in)/i;
    grammar.REGEXP_COMMA_DELIMITER = /^\s*,/;
    grammar.REGEXP_ASCENDING = /^\s+asc/i;
    grammar.REGEXP_DESCENDING = /^\s+desc/i;
    grammar.REGEXP_ORDER_BY = /^order\s+by/i;
    grammar.REGEXP_WHITESPACE = /^\s/;
    grammar.REGEXP_UNICODE = /^u[a-fA-F0-9]{4}/;
    grammar.REGEXP_FIELD_NAME = /^\s-\scf\[\d\d\d\d\d\]/;
    grammar.REGEXP_NEW_LINE = /[\r\n]/;
    grammar.REGEXP_NUMBER = /\d/;
    grammar.REGEXP_TOKEN_CHAR = /[^=!~<>(),\s&|\]]/;
    grammar.REGEXP_SPECIAL_CHAR = /[{}*\/%+$#@?;\][]/;
    grammar.REGEXP_SPACE_OR_ELSE = /[\s(]/;
    grammar.REGEXP_CHARS_TO_ESCAPE = /[^trn"'\\\s]/;
    grammar.REGEXP_NOTSTART = /^NO?$/i;
    grammar.REGEXP_INSTART = /^IN?$/i;
    grammar.REGEXP_PREDICATE = /^(after|before|by|during|from|on|to)/i;

    return grammar;
});

define('jira/autocomplete/jql-autocomplete', [
    'jira/autocomplete/autocomplete',
    'jira/jql/jql-grammar',
    'jira/jql/util',
    'jira/jql/operator-util',
    'jira/util/data/meta',
    'jira/util/objects',
    'jquery'
], function(
    AutoComplete,
    grammar,
    Util,
    OperatorUtil,
    Meta,
    Objects,
    jQuery
) {
    /*jshint bitwise:true, curly:true, eqeqeq:false, eqnull:true, forin:true, noarg:true, noempty:true, nonew:true, undef:true, indent:4, browser:true, jquery:true */

    /**
     * @typedef {Object} JqlObject
     * @property {String} value - raw string value for the JQL piece.
     * @property {String} displayName - essentially the HTML escaped equivalent of the {@link JqlObject#value}.
     */

    /**
     * @typedef {JqlObject} JqlFunctionName
     * @property isList - "true" or "false"
     * @property {String[]} types - Java class(es) this function object can be type cast to (or was cast from?)
     */

    /**
     * @typedef {JqlObject} JqlFieldName
     * @property {String} cfid - typically of the format cf[12345]
     * @property {String[]} operators - list of valid operators that can be used with field operand (e.g., "=", "in", "is", "is not", etc.)
     * @property {String[]} types - Java class(es) this function object can be type cast to (or was cast from?)
     * @property auto - "true" or "false"
     * @property orderable - "true" or "false"
     * @property searchable - "true" or "false"
     */

    /**
     * Makes an input field capable of offering suggestions for JQL syntax and values one might fill in for fields in JQL.
     *
     * @exports jira/autocomplete/jql-autocomplete
     * @class JQLAutoComplete
     * @extends AutoComplete
     * @param options
     * @param {JQLAutoComplete.MyParser} options.parser - the parser to use for parsing JQL
     * @param {JqlFunctionName[]} options.jqlFunctionNames - Array of of JQL function names
     * @param {JqlFieldName[]} options.jqlFieldNames - Array of JQL fields
     * @param {String} options.autoCompleteUrl - REST endpoint where value suggestions will come from
     * @param {String} options.errorID - ID of the DOM element to output JQL error messages to
     * @returns {Object}
     */
    var JQLAutoComplete = function(options) {

        /** @lends JQLAutoComplete.prototype */
        var that = Objects.begetObject(AutoComplete);

        var parser = options.parser;
        var result;
        var jql_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue) {
            // We only want the searchable fields
            return arrValue.searchable;
        });
        var jql_order_by_field_names = jQuery.grep(options.jqlFieldNames, function(arrValue) {
            // We only want the orderable fields
            return arrValue.orderable;
        });
        var jql_function_names = options.jqlFunctionNames;
        var PARSE_INDICATOR = jQuery("#" + options.errorID);
        var suggestionCount = 0;
        var jqlcolumnnum = jQuery("#jqlcolumnnum");
        var jqlrownum = jQuery("#jqlrownum");
        var autoCompleteUrl = options.autoCompleteUrl || contextPath + "/rest/api/2/jql/autocompletedata/suggestions";

        that.textToSuggestionCursorPosition = function() {
            return that.field.selectionRange().textBefore;
        };


        that.pushSuggestionsOnHtmlStack = function(suggestions, suggestionNodes, htmlParts, listItemIdentifier, mayNeedParenthesis) {
            var length = Math.min(15, suggestions.length);
            for (var i = 0; i < length; i++) {
                var actualValueSug;
                var displayNameSug;
                // We may have an object with displayName and value OR it may just be a string
                if (suggestions[i].value) {
                    var resultSug = suggestions[i];
                    if (result && mayNeedParenthesis) {
                        // This is a hack that adds an initial ( when the value is the first completed in a list
                        // We only do this for suggestions and not moreSuggestions since we know that this is
                        // the position that the values will take, moreSuggestions will be function suggestions
                        actualValueSug = ((result.getNeedsOpenParen()) ? "(" : "") + resultSug.value;
                    }
                    else {
                        actualValueSug = resultSug.value;
                    }
                    displayNameSug = resultSug.displayName;
                }
                else {
                    displayNameSug = suggestions[i];
                    actualValueSug = displayNameSug;
                }
                suggestionNodes.push(actualValueSug);
                htmlParts.push(
                    '<li id="',
                    listItemIdentifier,
                    i,
                    '">',
                    displayNameSug,
                    '</li>'
                );
            }
        };

        /**
         * Order of rendering:
         * 1. Operator suggestions
         * 2. "normal" suggestions
         * 3. More suggestions
         *
         * @param {JqlObject[]} suggestions
         * @param {JqlObject[]} moreSuggestions
         * @param {JqlObject[]} operatorSuggestions
         * @returns {Array}
         */
        that.renderSuggestions = function(suggestions, moreSuggestions, operatorSuggestions) {
            var suggestionNodes = [];

            if (suggestions instanceof Array) {
                if (suggestions.length < 1 && (moreSuggestions && moreSuggestions.length < 1) && (operatorSuggestions && operatorSuggestions.length < 1)) {
                    return suggestionNodes;
                }

                var htmlParts = ['<ul>'];
                if (operatorSuggestions && operatorSuggestions.length > 0) {
                    that.pushSuggestionsOnHtmlStack(operatorSuggestions, suggestionNodes, htmlParts, "jql_operator_suggest_", false);
                }
                that.pushSuggestionsOnHtmlStack(suggestions, suggestionNodes, htmlParts, "jql_value_suggest_", true);
                if (moreSuggestions && moreSuggestions.length > 0) {
                    that.pushSuggestionsOnHtmlStack(moreSuggestions, suggestionNodes, htmlParts, "jql_function_suggest_", false);
                }
                htmlParts.push('</ul>');

                var syntaxHelpLink = jQuery('<a class="syntax-help" target="_jiraHelp"></a>')
                    .attr('title', Meta.get('advanced-search-help-title'))
                    .attr('href', Meta.get('advanced-search-help-url'))
                    .text("Syntax Help");
                var syntaxHelpContainer = jQuery('<div class="syntax-help-container">').append(syntaxHelpLink);

                that.responseContainer
                    .html(htmlParts.join(''))
                    .append(syntaxHelpContainer)
                    .find('li').each(function(i) {
                        suggestionNodes[i] = [jQuery(this), suggestionNodes[i]];
                    });

                that.addSuggestionControls(suggestionNodes);
            }

            return suggestionNodes;
        };

        that.completeField = function(value) {
            var start = that.getReplacementStartIndex(result, value);

            var end = that.getReplacementEndIndex(result, start);

            that.replaceValue(start, end, value);

            // Parse the whole thing again with the full string so we can set the parse/not parse indicator correctly, possibly a third parse, this is starting to get crazy
            var newToken = parser.parse(that.field.val());
            that.updateParseIndicator(newToken);
        };

        that.prepareOperandSuggestions = function(canAutoComplete, fieldName, functionSuggestions, operatorSuggestions, suggestedValue) {
            if (canAutoComplete) {
                var currentSuggestionCount = suggestionCount;
                var fieldValue = (suggestedValue == null) ? ( (result.getLastOperand() === null) ? "" : Util.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
                var fieldNameValueKey = fieldName + ":" + fieldValue;
                var data = {fieldName: Util.stripEscapeCharacters(fieldName)};
                if (result.getLastOperand() !== null || suggestedValue !== null) {
                    data.fieldValue = fieldValue;
                }
                var includeEmpty = OperatorUtil.isWasOperator(result.getLastOperator());
                if (!that.getSavedResponse(fieldNameValueKey)) {
                    // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    that.delay(function() {
                        that._makeRequest({
                            url: autoCompleteUrl,
                            dataType: "json",
                            data: data,
                            success: function(response) {
                                var results;
                                if (response !== null && response.results !== null) {
                                    results = response.results;
                                }
                                else {
                                    results = [];
                                }
                                // Cache the results
                                //append empty
                                if (includeEmpty) {
                                    var suggestion = data.fieldValue;
                                    results = that.appendEmpty(suggestion, results);
                                }
                                that.saveResponse(fieldNameValueKey, results);
                                that.renderSuggestionsForOperands(fieldValue, results, functionSuggestions, operatorSuggestions, currentSuggestionCount);
                            },
                            error: function() {
                                that.renderSuggestionsForOperands(fieldValue, [], functionSuggestions, operatorSuggestions, currentSuggestionCount);
                            }
                        });
                    }, that.queryDelay);
                }
                else {
                    that.renderSuggestionsForOperands(fieldValue, that.getSavedResponse(fieldNameValueKey), functionSuggestions, operatorSuggestions, currentSuggestionCount);
                }
            }
            else {
                // We should at least render the function suggestions
                that.renderSuggestionsForOperands(Util.stripEscapeCharacters(result.getLastOperand()), [], functionSuggestions, operatorSuggestions, suggestionCount);
            }
        };

        that.preparePredicateSuggestions = function(predicateName, suggestedValue) {
            var currentSuggestionCount = suggestionCount;
            if (typeof suggestedValue === "undefined") {
                suggestedValue = null;
            }
            var functionSuggestions = that.slimListForPredicates(suggestedValue, jql_function_names, predicateName);
            that.boldMatchingString(suggestedValue, functionSuggestions);
            var predicateValue = (suggestedValue == null) ? ( (result.getLastOperand() === null) ? "" : Util.stripEscapeCharacters(result.getLastOperand())) : suggestedValue;
            var predicateNameValueKey = predicateName + ":" + predicateValue;
            var data = {predicateName: Util.stripEscapeCharacters(predicateName)};
            if (result.getLastOperand() !== null || suggestedValue !== null) {
                data.predicateValue = predicateValue;
            }
            if (result.getLastFieldName() !== null) {
                data.fieldName = result.getLastFieldName();
                predicateNameValueKey = result.getLastFieldName() + ":" + predicateNameValueKey;
            }
            if (that.predicateSupportsAutoComplete(predicateName)) {
                if (!that.getSavedResponse(predicateNameValueKey)) {
                    // We only delay the AJAX request, if it comes back and we have already suggested something else then the results will be dropped because of suggestionCount
                    that.dropdownController.dropdown.removeClass("dropdown-ready");
                    that.delay(function() {
                        that._makeRequest({
                            url: autoCompleteUrl,
                            dataType: "json",
                            data: data,
                            success: function(response) {
                                var results;
                                if (response !== null && response.results !== null) {
                                    results = response.results;
                                }
                                else {
                                    results = [];
                                }
                                // Cache the results
                                //append empty
                                var suggestion = data.predicateValue;
                                results = that.appendEmpty(suggestion, results);
                                that.saveResponse(predicateNameValueKey, results);
                                that.renderSuggestions(results, functionSuggestions);
                            },
                            error: function() {
                                that.renderSuggestionsForOperands(predicateValue, []);
                            }
                        });
                    }, that.queryDelay);
                }
                else {
                    that.renderSuggestions(that.getSavedResponse(predicateNameValueKey), functionSuggestions);
                }
            }
            else {
                // simply render functions
                that.renderSuggestions([], functionSuggestions);
            }
        };

        that.incompleteOperator = function() {
            var tokens = result.getTokens();
            if (tokens == null || tokens.length < 2) {
                return "";
            }
            else {
                tokens = that.textToSuggestionCursorPosition().split(" ");
                if (tokens.length > 2) {
                    return tokens[tokens.length - 1];
                }
            }
            return "";
        };

        that.incompletePredicateValue = function() {
            var tokens = result.getTokens();
            if (tokens == null || tokens.length < 3) {
                return "";
            }
            else {
                tokens = that.textToSuggestionCursorPosition().split(/[\s(,]+/);
                if (tokens.length > 3) {
                    return tokens[tokens.length - 1];
                }
            }
            return "";
        };

        that.appendEmpty = function(suggestion, results) {
            var empty_list = that.slimListForMapResults(suggestion, grammar.empty_operand, true);
            if (suggestion != null) {
                that.boldMatchingString(suggestion, empty_list);
            }
            if (results.length < 15) {
                results = results.concat(empty_list);
            }
            else {
                results[14] = empty_list[0];
            }
            return results;
        };

        that.dispatcher = function(val) {

            var selectionRange = jQuery(that.field).selectionRange();
            var parseValue = val.substring(0, selectionRange.start);

            var value;
            var functionSuggestions;

            var token = parser.parse(parseValue);

            result = token.getResult();
            // We will always make a suggestion from here so lets increment the count
            suggestionCount++;
            // In this case we suggest operators
            if (result.getNeedsField()) {
                that.renderSuggestionsFromMap(Util.stripEscapeCharacters(result.getLastFieldName()), jql_field_names, grammar.jql_not_logical_operator, true);
            }
            // for was queries you msay need either an operator or operand
            else if (result.getNeedsOperatorOrOperand()) {
                functionSuggestions = (OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) ? grammar.empty_operand : jql_function_names;

                token.calcLastOperandStartIndex();
                var parsedOperator = token.getParsedOperator();
                var operatorSuggestions = that.getSuggestionsForOperators(parsedOperator, grammar.jql_operators);

                if (operatorSuggestions && operatorSuggestions.length > 0) {
                    var operandSuggestion = that.incompleteOperator();
                    that.prepareOperandSuggestions(true, result.getLastFieldName(), functionSuggestions, operatorSuggestions, operandSuggestion);
                }
            }
            else if (result.getNeedsOperator()) {
                that.renderSuggestionsForOperators(result.getLastOperator(), grammar.jql_operators);
            }
            else if (result.getNeedsPredicateOperand()) {
                var predicate = result.getLastWasPredicate();
                that.preparePredicateSuggestions(predicate, Util.stripEscapeCharacters(result.getLastOperand()));
            }
            else if (result.getNeedsLogicalOperator()) {
                if (result.getNeedsWasPredicate()) {
                    if (result.getNeedsOrderBy()) {
                        value = (result.getLastOrderBy() === null) ? result.getLastWasPredicate() : result.getLastOrderBy();
                        if (result.getLastOperator() === 'was') {
                            that.renderSuggestionsFromMap(value, grammar.jql_was_predicates_and_order_by, false);
                        }
                        else {
                            that.renderSuggestionsFromMap(value, grammar.jql_changed_predicates_and_order_by, false);
                        }
                    }
                    else {
                        if (result.getLastOperator() === 'was') {
                            that.renderSuggestionsFromMap(result.getLastWasPredicate(), grammar.jql_was_predicates_and_logical_operators, false);
                        }
                        else {
                            that.renderSuggestionsFromMap(result.getLastWasPredicate(), grammar.jql_changed_predicates_and_logical_operators, false);
                        }
                    }

                }
                else {
                    if (result.getNeedsOrderBy()) {
                        value = (result.getLastOrderBy() === null) ? result.getLastLogicalOperator() : result.getLastOrderBy();
                        that.renderSuggestionsFromMap(value, grammar.jql_logical_operators_and_order_by, false);
                    }
                    else {
                        that.renderSuggestionsFromMap(result.getLastLogicalOperator(), grammar.jql_logical_operators, false);
                    }
                }
            }
            else if (result.getNeedsOrderByField()) {
                that.renderSuggestionsFromMap(Util.stripEscapeCharacters(result.getLastOrderByFieldName()), jql_order_by_field_names, true);
            }
            else if (result.getNeedsOrderByDirection()) {
                that.renderSuggestionsFromMap(result.getLastOrderByDirection(), grammar.jql_order_by_direction, false);
            }
            else if (result.getNeedsOperand()) {
                var fieldName = result.getLastFieldName();

                var canAutoComplete = false;
                // If we know that we are only suggesting empty then we do not need to suggest values
                if (!OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) {
                    for (var i = 0; i < jql_field_names.length; i++) {
                        if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                            (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                            canAutoComplete = jql_field_names[i].auto;
                            break;
                        }
                    }
                }

                functionSuggestions = (OperatorUtil.isEmptyOnlyOperator(result.getLastOperator())) ? grammar.empty_operand : jql_function_names;
                that.prepareOperandSuggestions(canAutoComplete, fieldName, functionSuggestions, {});
            }
            else if (result.getNeedsOrderBy()) {
                that.renderSuggestionsFromMap(result.getLastOrderBy(), grammar.jql_logical_operators_and_order_by, false);
            }
            else {
                that.dropdownController.hideDropdown();
            }

            // Need to update the parse/not parse indicator
            that.parse(val);
        };

        that.parse = function(val) {
            var newToken = parser.parse(val);
            that.updateParseIndicator(newToken);
            that.updateColumnLineCount();
            return newToken.getResult();
        };

        that.renderSuggestionsFromMap = function(stringVal, list, otherSuggestions, showFull) {
            if (!otherSuggestions) {
                otherSuggestions = {};
            }
            var suggestions = that.slimListForMapResults(stringVal, list, showFull);
            var relevantOtherSuggestions = that.slimListForMapResults(stringVal, otherSuggestions, showFull);
            that.boldMatchingString(stringVal, relevantOtherSuggestions);
            that.boldMatchingString(stringVal, suggestions);

            that.renderSuggestions(suggestions, relevantOtherSuggestions);
            if (suggestions.length === 0 && relevantOtherSuggestions.length === 0) {
                that.dropdownController.hideDropdown();
            }
        };

        that.getSuggestionsForOperators = function(stringVal, list) {
            var suggestions = that.slimListForMapResults(stringVal, list, false);

            var fieldName = result.getLastFieldName();
            // Find the current field, if we know about it and get the supported operators
            var supportedOperators;
            for (var i = 0; i < jql_field_names.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                    (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                    supportedOperators = jql_field_names[i].operators;
                    break;
                }
            }

            // Now lets run through the remaining list and if we can identify the field we can see if that field
            // supports which operators
            if (supportedOperators) {
                suggestions = jQuery.grep(suggestions, function(arrValue) {
                    return jQuery.inArray(arrValue.value, supportedOperators) > -1;
                });
            }
            that.boldMatchingString(stringVal, suggestions);
            return suggestions;
        };

        that.renderSuggestionsForOperators = function(stringVal, list) {
            var suggestions = that.getSuggestionsForOperators(stringVal, list);
            that.renderSuggestions(suggestions);
            if (suggestions.length === 0) {
                that.dropdownController.hideDropdown();
            }
        };

        that.renderSuggestionsForOperands = function(stringVal, ajaxSuggestions, functions, operatorSuggestions, providedSuggestionCount) {
            // Only render the suggestions if we are the current suggestion
            if (providedSuggestionCount === suggestionCount) {
                // Don't need to slim the ajaxSuggestions since they came from the server slimmed down
                var functionsSuggestions = that.slimListForFunctionResults(stringVal, functions, result.getLastOperator());
                that.boldMatchingString(stringVal, functionsSuggestions);
                that.renderSuggestions(ajaxSuggestions, functionsSuggestions, operatorSuggestions);

                if (ajaxSuggestions.length === 0 && functionsSuggestions.length === 0 && operatorSuggestions.length === 0) {
                    that.dropdownController.hideDropdown();
                }
            }
        };

        // This bolds the beginning portion of the matching string and converts the list to be value/displayName. This
        // assumes that all strings in the list have already been confirmed to match the incomming stringVal
        that.boldMatchingString = function(stringVal, list) {
            if (stringVal == null || list.length === 0) {
                return;
            }

            var boldLength = stringVal.length;
            // Run through all the characters looking for html escape characters so we can include their extra length in
            // the bold length
            for (var j = 0, n = boldLength; j < n; j++) {
                switch (stringVal.charAt(j)) {
                    case "<":
                    case ">":
                        // We have one character representing this already, lets add the other 3 for &lt; or &gt;
                        boldLength += 3;
                        break;
                    case "&":
                        // We have one character representing this already, lets add the other 4 for &amp;
                        boldLength += 4;
                        break;
                    case '"':
                        // We have one character representing this already, lets add the other 5 for &quot;
                        boldLength += 5;
                        break;
                }
            }

            for (var i = 0; i < list.length; i++) {
                if (list[i].displayName) {
                    var origVal = list[i].displayName;
                    // Create a new copy of the object so we don't mess up the original list
                    list[i] = {value: list[i].value, displayName: "<b>" + origVal.substring(0, boldLength) + "</b>" + origVal.substring(boldLength)};
                }
                else {
                    // Add a displayName so we don't mess up the value
                    list[i] = {value: list[i], displayName: "<b>" + list[i].substring(0, boldLength) + "</b>" + list[i].substring(boldLength)};
                }
            }
        };

        that.getReplacementStartIndex = function(result, value) {
                var jQueryReference = jQuery(that.field);
                var start;
                if (result.getNeedsField()) {
                    start = result.getLastFieldNameStartIndex();
                }
                else if (result.getNeedsOperatorOrOperand()) {
                    // was presents difficulties - it may be followed by either an operand or an operator
                    if (result.getNeedsOperator() && OperatorUtil.isWasOperator(value)) {
                        start = result.getLastOperatorStartIndex();
                    }
                    else {
                        start = result.getLastOperandStartIndex();
                    }
                }
                else if (result.getNeedsOperand()) {
                    start = result.getLastOperandStartIndex();
                }
                else if (result.getNeedsOperator()) {
                    start = result.getLastOperatorStartIndex();
                }
                else if (result.getNeedsOrderByField()) {
                    start = result.getLastOrderByFieldNameStartIndex();
                }
                else if (result.getNeedsOrderByDirection()) {
                    start = result.getLastOrderByDirectionStartIndex();
                }
                else if (result.getNeedsPredicateOperand()) {
                    start = result.getLastOperandStartIndex();
                }
                else if (result.getNeedsLogicalOperator()) {
                    if (result.getLastLogicalOperatorStartIndex() !== null && result.getLastLogicalOperatorStartIndex() !== 0) {
                        start = result.getLastLogicalOperatorStartIndex();
                    }
                    else {
                        if (result.getLastOrderBy() !== null && result.getLastOrderByStartIndex() !== 0) {
                            start = result.getLastOrderByStartIndex();
                        }
                        else if (result.getLastWasPredicate() != null && result.getLastWasPredicateStartIndex() !== 0) {
                            start = result.getLastWasPredicateStartIndex();
                        }
                        else if (result.getMustBeOperatorOrPredicate() === true) {
                            start = jQueryReference.selectionRange().start;
                        }
                        else {
                            start = jQueryReference.selectionRange().start - 1;
                        }
                    }
                }
                else if (result.getNeedsWasPredicate()) {
                    start = result.getLastWasPredicateStartIndex();
                }
                else if (result.getNeedsOrderBy()) {
                    start = result.getLastOrderByStartIndex();
                }
                else {
                    start = jQueryReference.selectionRange().start - 1;
                }
                // sanity check
                return start != null ? start : jQueryReference.selectionRange().start;
            };

        that.getReplacementEndIndex = function(result, start) {
            var jQueryReference = jQuery(that.field);
            var selectionRange = jQueryReference.selectionRange();
            var end = null;
            // We only need to do a second parse if we have no highlighted selection AND we are not at the end of the input string
            // But we also must check that cursor is now in the middle or end of the word. (3 condition)
            // otherwise we just use the selectionEnd
            if (selectionRange.start === selectionRange.end && selectionRange.end !== that.field.val().length && start < selectionRange.start) {
                // Lets get the token number from the first parse, this is the token we are currently on
                var currentTokenIdx = result.getTokens().length - 1;

                // Parse it again, but this time the full string so we know what the full token is that we are trying to replace
                // with the selected completion
                var token = parser.parse(that.field.val());
                if (!token.getParseError()) {
                    // The user has not highlighted text so lets assume we are completing to the end of the current token
                    // Ask the newly parsed result for the complete token we are in the middle of
                    var fullTokenValue = token.getResult().getTokens()[currentTokenIdx];
                    // This is a special case, we don't want to replace the '(' or ')' instead we want to add inside
                    if (fullTokenValue !== null && fullTokenValue !== '(' && fullTokenValue !== ')') {
                        var fullTextVal = that.field.val();
                        // Lets get the start position in the string
                        var remainingString = fullTextVal.substring(start, fullTextVal.length);
                        // We know that we are going to see the fullTokenValue next, but there may be some whitespace between
                        // here and there, lets make sure we ditch the whitespace as well.
                        var remainingStringArr = remainingString.split("");
                        var whitespaceCount = 0;
                        for (var i = 0; i < remainingStringArr.length; i++) {
                            if (grammar.REGEXP_WHITESPACE.test(remainingStringArr[i])) {
                                whitespaceCount++;
                            }
                            else {
                                // Stop as soon as we no longer see whitespace
                                break;
                            }
                        }
                        end = start + fullTokenValue.length + whitespaceCount;
                    }
                }
            }

            if (end === null) {
                end = selectionRange.end;
            }
            // As the start position could have been incremented to account for spaces in operators
            // e.g. was not in, it is feasible that end may be less than start so a quick check is in order.
            // If start is less than end pad with a space (one is sufficient)
            if (end < start) {
                that.replaceValue(start, end, " ");
                end = start;
            }
            return end;
        };

        that.replaceValue = function(start, end, newValue) {
            var jQueryReference = jQuery(that.field);
            // Lets reset the selection range to include the characters that the user has already typed
            jQueryReference.selectionRange(start, end);
            // Lets replace the value with the autocomplete selected value
            //The following if clause is needed to provide correct undo behavior in JQL text field
            //Webkit family doesn't put jQuery.selection to undo stack, so we are getting an ugly undo
            //On the other hand non-webkit browser don't insert the text through document.execCommand.
            //But they work correct with selection and undo.
            if ($.browser.webkit) {
                document.execCommand("insertText", false, newValue);
            } else {
                jQueryReference.selection(newValue);
            }
            // Lets stop the replaced bit from being highlighted
            var newEnd = jQueryReference.selectionRange().end;
            jQueryReference.selectionRange(newEnd, newEnd);
        };

        that.slimListForMapResults = function(stringVal, list, showFull) {
            var escString = Util.htmlEscape(stringVal);
            var slimedList = jQuery.grep(list, function(arrValue) {
                return Util.startsWithIgnoreCaseNullsMeanAll(escString, arrValue.displayName);
            });

            if (!showFull) {
                // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
                // with this prefix.
                if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(escString, slimedList[0].displayName)) {
                    return {};
                }
            }
            return slimedList;
        };

        that.slimListForFunctionResults = function(stringVal, list, operator) {
            var fieldName = result.getLastFieldName();
            // Find the current field, if we know about it and get the supported types
            var supportedTypes;
            for (var i = 0; i < jql_field_names.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(jql_field_names[i].value), fieldName) ||
                    (jql_field_names[i].cfid && Util.equalsIgnoreCase(jql_field_names[i].cfid, fieldName))) {
                    supportedTypes = jql_field_names[i].types;
                    break;
                }
            }

            var slimedList = jQuery.grep(list, function(arrValue) {
                // For functions we only want to show the is list ones with list operators and vice versa
                if ((arrValue.isList && !OperatorUtil.isListSupportingOperator(operator)) ||
                    (!arrValue.isList && OperatorUtil.isListSupportingOperator(operator))) {
                    return false;
                }
                if (supportedTypes) {
                    // Need to check for Object since this means we always fit
                    var supportsFunction = jQuery.inArray("java.lang.Object", arrValue.types) > -1 || jQuery.inArray("java.lang.Object", supportedTypes) > -1;
                    for (var i = 0; i < supportedTypes.length && !supportsFunction; i++) {
                        supportsFunction = jQuery.inArray(supportedTypes[i], arrValue.types) !== -1;
                    }
                    if (!supportsFunction) {
                        return false;
                    }
                }
                else {
                    // Can't find the field so we know that no functions will work with it
                    return false;
                }
                return Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName);
            });

            // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
            // with this prefix.
            if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName)) {
                return {};
            }
            return slimedList;
        };

        that.slimListForPredicates = function(stringVal, list, predicate) {
            var supportedType;
            var supportsList;
            for (var i = 0; i < grammar.jql_changed_predicates.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(grammar.jql_changed_predicates[i].value), predicate)) {
                    supportedType = grammar.jql_changed_predicates[i].type;
                    supportsList = grammar.jql_changed_predicates[i].supportsList;
                    break;
                }
            }

            var slimedList = jQuery.grep(list, function(arrValue) {
                // For functions we only want to show the is list ones with list operators and vice versa

                if (typeof arrValue.isList !== "undefined") {
                    if ((arrValue.isList && !!supportsList) || (!arrValue.isList && supportsList)) {
                        return false;
                    }
                }
                var supportsFunction = jQuery.inArray(supportedType, arrValue.types) !== -1;
                return supportsFunction ? Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.value) || Util.startsWithIgnoreCaseNullsMeanAll(stringVal, arrValue.displayName) : false;
            });

            // We only want to show the value when the user has fully typed it in IF there are more than one suggestion
            // with this prefix.
            if (slimedList.length === 1 && !Util.startsWithNotEqualsIgnoreCaseNullMeansAll(stringVal, slimedList[0].displayName)) {
                return {};
            }
            return slimedList;
        };

        that.predicateSupportsAutoComplete = function(predicate) {
            var auto;
            for (var i = 0; i < grammar.jql_changed_predicates.length; i++) {
                if (Util.equalsIgnoreCase(result.getUnquotedString(grammar.jql_changed_predicates[i].value), predicate)) {
                    auto = grammar.jql_changed_predicates[i].auto;
                    break;
                }
            }
            return auto;

        };

        /**
         * Gets cached response from <em>requested</em> object
         * @param {String} val
         * @returns {Object}
         */
        that.getSavedResponse = function(val) {
            if (!this.requested) {
                this.requested = {};
            }
            return this.requested[val];
        };

        /**
         * Saves response to <em>requested</em> object
         * @param {String} val
         * @param {Object} response
         */
        that.saveResponse = function(val, response) {
            if (typeof val === "string" && typeof response === "object") {
                if (!this.requested) {
                    this.requested = {};
                }
                this.requested[val] = response;
            }
        };

        that.startsWithIgnoreCase = function(startStr, str) {
            if (str === null || startStr === null || str.length < startStr.length) {
                return false;
            }
            else {
                return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            }
        };

        that.updateParseIndicator = function(token) {
            if (token.getParseError()) {
                PARSE_INDICATOR.attr("title", token.getResult().getParseErrorMsg()).removeClass("jqlgood").addClass("jqlerror");
            }
            else {
                PARSE_INDICATOR.attr("title", "").removeClass("jqlerror").addClass("jqlgood");
            }
        };

        that.updateColumnLineCount = function() {
            var jQueryReference = jQuery(that.field);
            var totalCharCountToCursor = 0;

            if (that.field[0] === document.activeElement) {
                var selectionRange = jQueryReference.selectionRange();
                totalCharCountToCursor = selectionRange.start;
            }
            else {
                totalCharCountToCursor = that.field[0].value.length;
            }
            var rowCount = 1;
            var colCount = 1;

            var fieldValue = that.field.val();

            for (var i = 0; i < totalCharCountToCursor; i++) {
                if (grammar.REGEXP_NEW_LINE.test(fieldValue.charAt(i))) {
                    rowCount++;
                    colCount = 1;
                }
                else {
                    colCount++;
                }
            }

            // Update our counts for where our cursor is at the moment
            jqlcolumnnum.text(colCount);
            jqlrownum.text(rowCount);
        };

        that.init(options);

        return that;
    };

    return JQLAutoComplete;
});

define('jira/jql/util', [
    'jira/jql/jql-grammar'
], function(
    grammar
) {
    "use strict";

    /** @exports jira/jql/util */
    var JQLAutoCompleteUtil = {};

    JQLAutoCompleteUtil.htmlEscape = function(stringVal) {
        if (stringVal == null) {
            return null;
        }
        var escapedVal = "";
        var strArr = stringVal.split("");
        // Run through all the characters looking for html escape characters so we can include their extra length in
        // the bold length
        for (var j = 0; j < strArr.length; j++) {
            if (strArr[j] === "<") {
                escapedVal += "&lt;";
            }
            else if (strArr[j] === ">") {
                escapedVal += "&gt;";
            }
            else if (strArr[j] === "&") {
                // We have one character representing this already, lets add the other 4 for &amp;
                escapedVal += "&amp;";
            }
            else if (strArr[j] === "\"") {
                // We have one character representing this already, lets add the other 5 for &quot;
                escapedVal += "&quot;";
            }
            else {
                escapedVal += strArr[j];
            }
        }
        return escapedVal;
    };

    JQLAutoCompleteUtil.stripEscapeCharacters = function(val) {

        if (val == null) {
            return val;
        }
        var newVal = "";
        var strArr = val.split("");
        for (var i = 0; i < strArr.length; i++) {
            if (strArr[i] === '\\') {
                // If we are a unicode string then we just consume it like normal
                if (!grammar.REGEXP_UNICODE.test(val.substring(i, val.length))) {
                    // Just chew past the escape and use the next char, the parser has already made sure this is cool
                    i++;
                    if (i >= val.length) {
                        break;
                    }
                }
            }
            newVal += strArr[i];
        }
        return newVal;
    };

    JQLAutoCompleteUtil.equalsIgnoreCase = function(str1, str2) {
        if (str1 === null && str2 === null) {
            return true;
        }
        else if (str1 === null || str1 === null) {
            return false;
        }
        else {
            return str1.toLowerCase() === str2.toLowerCase();
        }
    };

    JQLAutoCompleteUtil.startsWithIgnoreCaseNullsMeanAll = function(startStr, str) {
        // In this case we want all elements of the list included
        if (str === null || startStr === null) {
            return true;
        }
        if (str.length < startStr.length) {
            return false;
        }
        else {
            return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
        }
    };

    JQLAutoCompleteUtil.startsWithNotEqualsIgnoreCaseNullMeansAll = function(startStr, str) {
        // In this case we want all elements of the list included
        if (str === null || startStr === null) {
            return true;
        }
        if (str.length < startStr.length) {
            return false;
        }
        else {
            var subStrEquals = startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
            if (subStrEquals) {
                // HACK!! This is a hack so that the custom field display values will not show up as a suggestion when they
                // are completely typed in.
                var equalsString = null;
                if (grammar.REGEXP_FIELD_NAME.test(str.substr(startStr.length, str.length))) {
                    equalsString = str.substr(0, startStr.length);
                }
                else {
                    equalsString = str;
                }
                return startStr.toLowerCase() != equalsString.toLowerCase();
            }
            return false;
        }
    };

    return JQLAutoCompleteUtil;
});

define('jira/jql/operator-util', function() {
    "use strict";

    /** @exports jira/jql/operator-util */
    var that = {};

    that.isListSupportingOperator = function(operator) {
        return operator === 'in' || operator === 'not in' || operator === 'was not in' || operator === 'was in';
    };

    that.isEmptyOnlyOperator = function(operator) {
        return operator === 'is' || operator === 'is not';
    };

    that.isWasOperator = function(operator) {
        return operator === 'was' || operator === 'was in' || operator === 'was not in' || operator === 'was not';
    };

    that.isChangedOperator = function(operator) {
        return operator === 'changed';
    };

    that.isHistoryOperator = function(operator) {
        return that.isWasOperator(operator) || that.isChangedOperator(operator);
    };

    return that;
});

define('jira/jql/jql-parser', [
    'jira/jql/jql-grammar',
    'jira/jql/jql-parse-token',
    'jira/jql/operator-util',
    'jquery'
], function(
    grammar,
    Token,
    OperatorUtil,
    jQuery
) {
    /*jshint bitwise:true, curly:true, eqeqeq:false, eqnull:true, forin:true, noarg:true, noempty:true, nonew:true, undef:true, indent:4 */

    /**
     * @exports jira/jql/jql-parser
     * @class JQLAutoComplete.MyParser
     * @param {String[]} jqlReservedWords - list of words that have special meaning in the JQL language
     */
    return function(jqlReservedWords) {

        var jql_reserved_words = jqlReservedWords;

        return /** @lends JQLAutoComplete.MyParser.prototype */ {
            parse: function(input) {
                var token = Token();

                token.init(input);
                this.jql(token);
//            token.toString();
                return token;
            },

            orderByClause: function(token) {
                var remainingString = token.remainingString();
                // Lets consume the 'order' token
                var matchArray = remainingString.match(grammar.REGEXP_ORDER_BY);

                if (matchArray) {
                    var orderByString = remainingString.substring(0, matchArray[0].length);
                    token.consumeCharacters(orderByString.length);
                    token.getResult().setLastOrderBy(orderByString, token);

                    if (!token.isComplete()) {
                        // We must have some space in order to parse an order by fields
                        remainingString = token.remainingString();
                        if (grammar.REGEXP_WHITESPACE.test(remainingString)) {
                            this.chewWhitespace(token);
                            // Look for order by fields
                            this.orderByFields(token);
                        }
                        else {
                            token.getResult().resetLogicalOperators();
                            token.setParseError();
                        }
                    }
                    else {
                        token.getResult().resetLogicalOperators();
                        token.setParseError();
                    }
                }
                else {
                    // Consume the remaining string
                    token.consumeCharacters(remainingString.length);
                    token.getResult().setLastOrderBy(remainingString, token);
                    token.setParseError();
                }
            },

            orderByFields: function(token) {
                // Look for fields followed by 'asc' or 'desc' or commas
                this.orderByField(token);
                this.chewWhitespace(token);
                if (token.isComplete()) {
                    // We always need to check to see if we need to put in a place-holder for the order by direction
                    if (!token.getResult().getNeedsOrderByField()) {
                        token.getResult().setLastOrderByDirection("", token);
                        // This is not a parse error, it is just a token place holder so we will complete correctly
                    }
                }
                else {
                    // Look for a comma
                    var remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase(",", remainingString)) {
                        token.consumeCharacter();
                        // Lets recurse back looking for more order by fields
                        this.orderByFields(token);
                        this.chewWhitespace(token);
                    }
                    else {
                        remainingString = token.remainingString();
                        if (remainingString !== null) {
                            token.consumeCharacters(remainingString.length);
                        }
                        token.getResult().setNeedsOrderByDirection();
                        token.getResult().setLastOrderByDirection(remainingString, token);
                        token.setParseError();
                    }
                }
            },

            orderByField: function(token) {
                this.chewWhitespace(token);
                var fieldName = this.fieldName(token);
                if (fieldName.length !== 0) {
                    token.getResult().setLastOrderByFieldName(fieldName, token);

                    // If we see a comma then we don't have an order by direction
                    var remainingString = token.remainingString();

                    if (!token.isComplete() && !grammar.REGEXP_COMMA_DELIMITER.test(remainingString)) {
                        // Better look for a direction, but it is optional so no big deal if we do not find it
                        // We need a space between the order by field name and the direction
                        if (grammar.REGEXP_ASCENDING.test(remainingString)) {
                            this.chewWhitespace(token);
                            // consume and move on
                            token.consumeCharacters(3);
                            token.getResult().setLastOrderByDirection("asc", token);
                            token.getResult().setNeedsOrderByComma();
                        }
                        else if (grammar.REGEXP_DESCENDING.test(remainingString)) {
                            this.chewWhitespace(token);
                            // consume and move on
                            token.consumeCharacters(4);
                            token.getResult().setLastOrderByDirection("desc", token);
                            token.getResult().setNeedsOrderByComma();
                        }
                        else {
                            token.getResult().setNeedsOrderByDirection();
                        }
                    }
                    else {
                        token.getResult().setNeedsOrderByField();
                        this.chewWhitespace(token);
                    }
                }
                else {
                    token.getResult().setLastOrderByFieldName("", token);
                    token.getResult().setNeedsOrderByField();
                    token.setParseError();
                }
            },

            jql: function(token) {
                this.orClause(token);
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase("ord", remainingString)) {
                    this.orderByClause(token);
                }
            },

            orClause: function(token) {

                while (!token.isComplete() && !this.startsWithIgnoreCase(")", token.remainingString())) {
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase("ord", remainingString)) {
                        // lets give control back to the jql function so we can end up in the orderByClause
                        break;
                    }
                    if (token.getResult().getMustBeOperatorOrPredicate()) {
                        token.getResult().resetLastPredicates();
                    }
                    else {
                        token.getResult().resetLogicalOperators();
                        this.andClause(token);
                    }
                    if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null) {
                        if (token.getResult().getNeedsWasPredicate()) {
                            this.predicateClause(token);
                        }
                        // we may as well exit early if the predicate clause has been handled
                        // and the token is complete
                        if (token.isComplete()) {
                            return;
                        }
                        // Look for an OR clause
                        remainingString = token.remainingString();
                        if (this.startsWithIgnoreCase("ord", remainingString)) {
                            // lets give control back to the jql function so we can end up in the orderByClause
                            break;
                        }
                        else if (remainingString !== null && (grammar.REGEXP_ORS.test(remainingString) || this.startsWithIgnoreCase("|", remainingString) || this.startsWithIgnoreCase("||", remainingString))) {
                            if (this.startsWithIgnoreCase("||", remainingString)) {
                                token.getResult().setLastLogicalOperator("||", token.getTokenStringIdx());
                                token.consumeCharacters(2);
                            }
                            else if (grammar.REGEXP_ORS.test(remainingString)) {
                                token.getResult().setLastLogicalOperator("OR", token.getTokenStringIdx());
                                token.consumeCharacters(3);
                            }
                            else {
                                token.getResult().setLastLogicalOperator("|", token.getTokenStringIdx());
                                token.consumeCharacters(1);
                            }

                            token.getResult().resetTerminalClause();
                            if (token.isComplete()) {
                                token.setParseError();
                            }
                            token.getResult().setNeedsField();
                        }
                        // This block of code is very confusing. The reason it is here is that when we are in a nested
                        // block of '('s it is the terminalClause that handles the parens and it calls off to this orClause.
                        // The orClause needs to ignore the close paren so that the terminalClause can handle it, BUT only
                        // when we are currently in a set of parens. So, ff the remaining character is a close paren and
                        // we are not in parens then we are NOT in error, otherwise we are
                        else if (!this.startsWithIgnoreCase(")", remainingString) || !token.getInParens()) {
                            this.chewWhitespace(token);
                            var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                            // let's tokenise this to simplify space handling
                            var tokens;
                            if (remainingString != null) {
                                tokens = remainingString.split(" ");
                                token.getResult().setLastLogicalOperator(tokens[0], errorIdx);
                                token.getResult().setLastWasPredicate(tokens[0], token);
                                token.getResult().setNeedsLogicalOperator(token);
                            }

                            // may need to go around again to check for predicate
                            if (token.getResult().getLastWasOperator() == null) {
                                token.setParseError();
                            }
                            else {
                                if (tokens != null) {
                                    // JRADEV-6053 fails after and
                                    if (grammar.REGEXP_PREDICATE.test(tokens[0])) {
                                        token.getResult().setLastLogicalOperator(null);
                                        // JRADEV-7204 deleting back to predicate still leaves suggestions
                                        // in place, check this condition and reset
                                        token.getResult().resetNeedsPredicateOperand();
                                    }
                                    else {
                                        if (grammar.REGEXP_ANDS.test(remainingString)) {
                                            token.consumeCharacters(4);
                                            token.getResult().resetTerminalClause();
                                            token.getResult().setNeedsField();
                                        }
                                        if (token.isComplete() || tokens.length === 1) {
                                            token.setParseError();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            andClause: function(token) {
                this.chewWhitespace(token);
                this.notClause(token);
                if (!token.isComplete() && token.getResult().getLastLogicalOperator() === null) {
                    // Look for an AND clause
                    this.chewWhitespace(token);

                    var remainingString = token.remainingString();
                    if (remainingString !== null && (grammar.REGEXP_ANDS.test(remainingString) || this.startsWithIgnoreCase("&", remainingString) || this.startsWithIgnoreCase("&&", remainingString))) {
                        if (this.startsWithIgnoreCase("&&", remainingString)) {
                            token.getResult().setLastLogicalOperator("&&", token.getTokenStringIdx());
                            token.consumeCharacters(2);
                        }
                        else if (this.startsWithIgnoreCase("&", remainingString)) {
                            token.getResult().setLastLogicalOperator("&", token.getTokenStringIdx());
                            token.consumeCharacters(1);
                        }
                        else {
                            token.getResult().setLastLogicalOperator("AND", token.getTokenStringIdx());
                            token.consumeCharacters(4);
                        }
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }

                        token.getResult().setNeedsField();
                    }
                    else {
                        token.getResult().setNeedsLogicalOperator(token);
                        // This is a special case for when we are about to place a logical operator into an existing string
                        // so that we will have a null place-holder token for the logical operator we expect.
                        if (token.isComplete()) {
                            token.getResult().setLastLogicalOperator(null, token.getMaxTokenStringIdx());
                        }
                    }
                }
            },

            notClause: function(token) {
                this.chewWhitespace(token);
                if (!token.isComplete()) {
                    // Look for a NOT clause
                    this.chewWhitespace(token);
                    var remainingString = token.remainingString();
                    if (remainingString !== null && (grammar.REGEXP_NOTS.test(remainingString) || this.startsWithIgnoreCase("!", remainingString))) {
                        // This is a bit of a hack that makes it so that you do not get a suggestion for a field until
                        // after you have typed a space after the NOT
                        token.getResult().needsField = false;
                        if (this.startsWithIgnoreCase("!", remainingString)) {
                            token.getResult().setLastLogicalOperator("!", token.getTokenStringIdx());
                            token.consumeCharacters(1);
                        }
                        else {
                            token.getResult().setLastLogicalOperator("NOT", token.getTokenStringIdx());
                            token.consumeCharacters(4);
                        }
                        token.getResult().resetTerminalClause();
                        if (token.isComplete()) {
                            token.setParseError();
                        }

                        token.getResult().setNeedsField();
                    }
                    else {
                        this.terminalClause(token);
                    }
                }
                else {
                    // Let the terminal clause set all the error conditions and needs
                    this.terminalClause(token);
                    token.setParseError();
                }
            },

            predicateClause: function(token) {
                this.chewWhitespace(token);
                if (!token.isComplete()) {
                    var remainingString = token.remainingString();
                    var tokens = remainingString.split(/[\s(]+/);
                    if (remainingString !== null) {
                        token.getResult().setMustBeOperatorOrPredicate(false);
                        // if the string starts with logical operator - return control to the
                        // not clause, however check if this is the last token, and if it is set the parse error flag
                        if (this.startsWithLogicalOperator(remainingString)) {
                            if (tokens.length === 1) {
                                token.getResult().setLastWasPredicate(tokens[0], token);
                                token.setParseError();
                                return;
                            }
                            return;
                        }
                        token.getResult().resetNeedsPredicateOperand();
                        token.consumeCharacters(tokens[0].length);
                        token.getResult().setLastWasPredicate(tokens[0], token);
                        // if there is only 1 token then there is no whitespace, so get out of Dodge
                        if (tokens.length === 1) {
                            token.setParseError();
                            return;
                        }
                        if (this.wasPredicateComplete(tokens[0])) {
                            token.getResult().setNeedsPredicateOperand();
                            token.getResult().setLastOperand(null, token);
                            this.predicateOperand(token);
                        }
                        else {
                            token.setParseError();
                        }
                    }
                }
                else {
                    // Let the terminal clause set all the error conditions and needs
                    token.setParseError();
                }

            },

            predicateOperand: function(token) {
                this.chewWhitespace(token);
                var predicateOperand = this.collectPredicateOperands(token);
                if (predicateOperand == null || predicateOperand == "") { // eslint-disable-line eqeqeq
                    token.getResult().setLastOperandStartIndex(token.getTokenStringIdx());
                    token.setParseError();
                }
                // need a workaround to ensure you reset the needsPredicateOperand
                // easiest way is to check if you have entered a space after the
                // operand - meaning you want to go on parsing
                if (token.remainingString() != null) {
                    token.getResult().resetNeedsPredicateOperand();
                    token.getResult().resetLastPredicates();
                    token.getResult().setMustBeOperatorOrPredicate(true);
                    token.getResult().setNeedsLogicalOperator(token);
                    this.chewWhitespace(token);
                }

            },

            collectPredicateOperands: function(token) {
                // If we have and in or not in operator then we need either a function or an open paren
                if (token.getResult().getLastWasPredicate() === 'DURING') {
                    token.getResult().setNeedsOpenParen(true);
                }

                var predicateOperand = this.listOperand(token, true);
                if (predicateOperand.length === 0) {
                    predicateOperand = this.functionOperand(token);
                    if (predicateOperand.length === 0) {
                        predicateOperand = this.singleValueOperand(token);
                    }
                    else {
                        // We were handled by a function so we no longer need the open paren
                        token.getResult().setNeedsOpenParen(false);
                    }
                }
                else {
                    // We were handled by a list so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }
                return token.getResult().getUnquotedString(predicateOperand);
            },

            terminalClause: function(token) {
                // Lets always reset the last field variables
                token.getResult().resetTerminalClause();
                this.chewWhitespace(token);

                var remainingString = token.remainingString();
                // If we see a ( then we need to hand off to the or clause again
                if (this.startsWithIgnoreCase("(", remainingString)) {
                    token.getResult().addToken('(');
                    token.setInParens();
                    token.consumeCharacter();
                    this.orClause(token);
                    this.chewWhitespace(token);
                    remainingString = token.remainingString();
                    if (this.startsWithIgnoreCase(")", remainingString)) {
                        token.getResult().addToken(')');
                        token.consumeCharacter();
                        token.setOutOfParens();
                        if (token.isComplete()) {
                            // We don't want to suggest a logical operator to the user if the query parses
                            token.getResult().resetLogicalOperators();
                            token.getResult().resetLastPredicates();
                        }
                    }
                    else {
                        token.setParseError();
                    }
                }
                else {
                    this.field(token);
                    if (!token.isComplete()) {
                        this.oper(token);
                        if (!token.isComplete()) {
                            if (token.getResult().getLastWasOperator() === 'changed') {
                                token.getResult().setNeedsLogicalOperator(token);
                                return;
                            }
                            this.operand(token);

                            // This will only happen when we have seen a list operand that is properly closed
                            if (token.getResult().getOperandComplete()) {
                                // JRADEV-6372 Autocomplete does not parse after was in (or indeed was not in)
                                var lastWasOperator = token.getResult().getLastWasOperator();
                                token.getResult().setNeedsNothing();
                                if (lastWasOperator) {
                                    token.getResult().setLastWasOperator(lastWasOperator);
                                }
                            }
                            else if (token.isComplete() && !token.getResult().getNeedsListComma()) {
                                // This is not a parse error since we have found everything we were looking for
                                token.getResult().setNeedsOperand();
                            }
                        }
                        else {
                            //if (token.getResult().get that.ge token.getResult().setNeedsOperator();
                            if (token.getResult().getLastOperator() === "was" || token.getResult().getLastOperator() === "was not") {
                                token.getResult().setNeedsOperandOrOperator();
                            }
                            else if (token.getResult().getLastWasOperator() === 'changed') {
                                // JRADEV-7179 Need to make sure that there is a space before calling for an autocomplete
                                var currentChar = token.currentCharacter();
                                if (currentChar !== null && grammar.REGEXP_SPACE_OR_ELSE.test(currentChar)) {
                                    token.getResult().setNeedsLogicalOperator(token);
                                }
                                else {
                                    token.getResult().resetLogicalOperators();
                                    token.getResult().setNeedsOrderBy(false);
                                }
                                return;
                            }
                            else {
                                token.getResult().setNeedsOperator();
                            }
                            token.setParseError();
                        }
                    }
                    else {
                        token.getResult().setNeedsField();
                        token.setParseError();
                    }
                }
            },

            field: function(token) {
                var fieldName = this.fieldName(token);
                if (fieldName.length !== 0) {
                    token.getResult().setLastFieldName(fieldName, token);
                }
                else if (token.getResult().getLastFieldName() === null) {
                    var remainingString = token.remainingString();
                    token.getResult().setNeedsField();
                    token.getResult().setLastFieldName(remainingString, token);
                    token.setParseError();
                }
            },

            fieldName: function(token) {
                this.chewWhitespace(token);

                // Field is either a string or cf[12345]
                var remainingString = token.remainingString();
                if (this.startsWithIgnoreCase("cf", remainingString)) {
                    var origIdx = token.getTokenStringIdx();
                    var origString = token.remainingString();
                    token.consumeCharacters(2);
                    this.chewWhitespace(token);
                    remainingString = token.remainingString();
                    // Now we must find a [ or the show is off
                    if (this.startsWithIgnoreCase("[", remainingString)) {
                        token.consumeCharacter();
                        // We must find a number in here until we encounter a ]
                        remainingString = token.remainingString();
                        var custFieldId = this.numberValue(token);
                        if (custFieldId.length !== 0) {
                            // Lets find our closing ]
                            this.chewWhitespace(token);
                            remainingString = token.remainingString();
                            if (this.startsWithIgnoreCase("]", remainingString)) {
                                token.consumeCharacter();
                                return origString.substring(0, token.getTokenStringIdx() - origIdx);
                            }
                        }
                    }
                    token.setParseError();
                    return origString;
                }
                else if (this.startsWithIgnoreCase("issue.property", remainingString)) {
                    return this.entityPropertyName("issue.property", token);
                }
                else {
                    return this.fieldOrFunctionName(token);
                }
            },
            entityPropertyName: function(propertyPrefix, token) {
                token.consumeCharacters(propertyPrefix.length);
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                // Now we must find a [ or the show is off
                if (this.startsWithIgnoreCase("[", remainingString)) {
                    token.consumeCharacter();
                    // Now the string is propertyKey

                    var propertyKeys = [this.stringValue(token)];

                    while (!token.parseError && this.startsWithIgnoreCase('.', token.remainingString())) {
                        token.consumeCharacter();
                        propertyKeys[propertyKeys.length] = this.stringValue(token);
                    }
                    if (propertyKeys.length !== 0 && propertyKeys[0].length !== 0 && !this.startsWithIgnoreCase('.', propertyKeys[0]) /*we don't want to allow .key as keys*/) {
                        // Lets find our closing ]
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();
                        if (this.startsWithIgnoreCase("]", remainingString)) {
                            token.consumeCharacter();
                            //now we expect property path the key after ]
                            var propertyPaths = [this.stringValue(token)];

                            while (!token.parseError && this.startsWithIgnoreCase('.', token.remainingString())) {
                                token.consumeCharacter();
                                propertyPaths[propertyPaths.length] = this.stringValue(token);
                            }
                            return propertyPrefix + '[' + propertyKeys.join('.') + ']' + propertyPaths.join('.');
                        }
                    }
                }
                token.setParseError();
                return "";
            },
            oper: function(token) {
                this.chewWhitespace(token);
                var remainingString = token.remainingString();
                var operator = this.getLongestOperatorMatch(remainingString, grammar.jql_operators);
                if (operator !== null) {
                    // We found an operator, record it and consume the right amount of characters
                    token.getResult().setLastOperator(operator, token.getTokenStringIdx());
                    if (OperatorUtil.isWasOperator(operator) || OperatorUtil.isChangedOperator(operator)) {
                        token.getResult().setLastWasOperator(operator);
                    }
                    token.consumeCharacters(operator.length);
                    // If we are one of the word operators we need to enforce a space here
                    if (operator === "in" || operator === "is" || operator === "is not" || operator === "not in" || operator === "was" || operator === "was not" || operator === "was in" || operator === "was not in") {
                        // We need a space or else
                        var currentChar = token.currentCharacter();
                        if (currentChar !== null && !grammar.REGEXP_SPACE_OR_ELSE.test(currentChar)) {
                            token.setParseError();
                        }
                    }
                    // was may be followed by not, so if it ihas a n or a no then the parser is still
                    // in error

                    if (operator === "was") {
                        token.getResult().setNeedsOperandOrOperator();
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();

                        if (remainingString != null && (grammar.REGEXP_NOTSTART.test(remainingString) || grammar.REGEXP_INSTART.test(remainingString))) {
                            token.setParseError();
                        }
                    }
                    else if (operator === "was not") {
                        token.getResult().setNeedsOperandOrOperator();
                        this.chewWhitespace(token);
                        remainingString = token.remainingString();

                        if (remainingString != null && (grammar.REGEXP_INSTART.test(remainingString))) {
                            token.setParseError();
                        }
                    }
                    else if (operator === "changed") {
                        token.getResult().setNeedsLogicalOperator(token);
                    }
                    else {
                        token.getResult().setNeedsOperand();
                    }
                }
                else if (token.getResult().getLastOperator() === null) {
                    var errorIdx = (remainingString === null) ? token.getMaxTokenStringIdx() : token.getMaxTokenStringIdx() - remainingString.length;
                    token.getResult().setLastOperator(remainingString, errorIdx);
                    token.getResult().setNeedsOperator();
                    token.setParseError();
                }
            },

            operand: function(token) {
                this.chewWhitespace(token);

                // If we have and in or not in operator then we need either a function or an open paren
                if (token.getResult().getLastOperator() === 'in' || token.getResult().getLastOperator() === 'not in' || token.getResult().getLastOperator() === 'was not in' || token.getResult().getLastOperator() === 'was in') {
                    token.getResult().setNeedsOpenParen(true);
                }

                var operand = this.listOperand(token, true);
                if (operand.length === 0) {
                    operand = this.functionOperand(token);
                    if (operand.length === 0) {
                        operand = this.singleValueOperand(token);
                    }
                    else {
                        // We were handled by a function so we no longer need the open paren
                        token.getResult().setNeedsOpenParen(false);
                    }
                }
                else {
                    // We were handled by a list so we no longer need the open paren
                    token.getResult().setNeedsOpenParen(false);
                }

                if (operand === null || operand.length === 0) {
                    var remainingString = token.remainingString();
                    token.getResult().setLastOperand(remainingString, token);
                    token.getResult().setNeedsOperand();
                    token.setParseError();
                }
                if (operand.length !== 0) {
                    return operand;
                }
                return "";
            },

            singleValueOperand: function(token) {
                var operand = this.stringValue(token);
                if (operand.length !== 0) {
                    token.getResult().setLastOperand(operand, token);
                    // Lets exclude empty and null, even though it is reserved
                    if (operand.toLowerCase() !== "empty" && operand.toLowerCase() !== "null" && this.isReservedWord(operand.toLowerCase())) {
                        // These are reserved words
                        token.setParseError();
                    }
                    return operand;
                }
                return "";
            },

            functionOperand: function(token) {
                var startIdx = token.getTokenStringIdx();
                var functionName = this.fieldOrFunctionName(token);
                // There can be whitespace between function name and arguments
                this.chewWhitespace(token);
                var listArguments = this.listOperand(token, false);
                if (functionName.length !== 0 && listArguments.length !== 0) {
                    var operand = functionName + listArguments;
                    // read in the whole value until we reach a close )
                    token.getResult().setLastOperand(operand, token);
                    return operand;
                }
                else {
                    // back track
                    token.backTrackToIdx(startIdx);
                    return "";
                }
            },

            listOperand: function(token, treatAsOperands) {
                if (token.currentCharacter() === '(') {
                    token.consumeCharacter();
                    var listValue = this.collectListValues(token, treatAsOperands);
                    var operandVal = "(" + listValue;

                    this.chewWhitespace(token);
                    if (token.currentCharacter() === ')') {
                        token.consumeCharacter();
                        operandVal += ")";
                        if (operandVal === "()" && treatAsOperands) {
                            // Special case of an empty list which is still valid
                            token.getResult().setLastOperand(operandVal, token);
                        }
                        if (treatAsOperands) {
                            token.getResult().setOperandComplete();
                            token.getResult().resetNeedsPredicateOperand();
                        }
                    }
                    else {
                        token.setParseError();
                    }
                    return operandVal;
                }
                else {
                    return "";
                }
            },

            collectListValues: function(token, treatAsOperands) {
                if (treatAsOperands) {
                    token.getResult().setNeedsOperand();
                }
                this.chewWhitespace(token);

                // grab the contents of the list, they should be singleValueOperands separated by commas, we only
                // need to keep track of the last encountered operand.
                var currentOperand = (treatAsOperands) ? this.operand(token) : this.stringValue(token);

                if (currentOperand.length !== 0) {
                    // If there is whitespace then lets remember we need a comma
                    if (this.chewWhitespace(token) && treatAsOperands) {
                        token.getResult().setNeedsListComma();
                    }
                    if (token.currentCharacter() === ',') {
                        // Consume the comma and recurse so we can collect the other values
                        token.consumeCharacter();
                        var nextValue = this.collectListValues(token, treatAsOperands);
                        if (nextValue.length === 0) {
                            token.setParseError();
                        }
                        return currentOperand + ", " + nextValue;
                    }
                    else {
                        return currentOperand;
                    }
                }
                else {
                    return "";
                }
            },

            startsWithIgnoreCase: function(startStr, str) {
                if (str === null || startStr === null || str.length < startStr.length) {
                    return false;
                }
                else {
                    return startStr.toLowerCase() == str.substr(0, startStr.length).toLowerCase();
                }
            },

            startsWithLogicalOperator: function(str) {
                if (str === null) {
                    return false;
                }
                else {
                    return this.startsWithOr(str) || this.startsWithAnd(str) || this.startsWithNot(str) || this.startsWithBraces(str);
                }
            },

            startsWithOr: function(str) {
                return this.startsWithIgnoreCase("|", str) || this.startsWithIgnoreCase("||", str) ||
                    this.startsWithIgnoreCase("or", str);
            },

            startsWithAnd: function(str) {
                return this.startsWithIgnoreCase("&", str) || this.startsWithIgnoreCase("&&", str) ||
                    this.startsWithIgnoreCase("and", str);
            },

            startsWithNot: function(str) {
                return this.startsWithIgnoreCase("!", str) ||
                    this.startsWithIgnoreCase("not", str);
            },

            startsWithBraces: function(str) {
                return this.startsWithIgnoreCase("(", str) ||
                    this.startsWithIgnoreCase(")", str);
            },

            chewWhitespace: function(token) {
                var foundWhiteSpace = false;
                var currentChar = token.currentCharacter();
                while (currentChar !== null && grammar.REGEXP_WHITESPACE.test(currentChar)) {
                    token.consumeCharacter();
                    currentChar = token.currentCharacter();
                    foundWhiteSpace = true;
                }
                return foundWhiteSpace;
            },

            getLongestOperatorMatch: function(value, listOfValues) {
                var longestMatch = null;
                var matchArray;
                // These first three cases are special since they might have more to them
                if (this.startsWithIgnoreCase("is", value)) {
                    // Look ahead for NOT, if we don't find it next then we must just be is
                    matchArray = value.substring(2).match(grammar.REGEXP_SNOT);

                    if (matchArray) {
                        longestMatch = value.substring(0, matchArray[0].length + 2);
                    }
                    else {
                        longestMatch = "is";
                    }
                }
                if (this.startsWithIgnoreCase("was", value)) {
                    // Look ahead for NOT or IN , if we don't find it next then we must just be was
                    matchArray = value.substring(3).match(grammar.REGEXP_SNOT_IN);

                    if (matchArray) {
                        longestMatch = value.substring(0, matchArray[0].length + 3);
                    }
                    else {
                        longestMatch = "was";
                    }
                }
                else if (this.startsWithIgnoreCase("not", value)) {
                    // Look ahead for IN, if we don't find it next then we are not an operator
                    var matchArrayNot = value.substring(3).match(grammar.REGEXP_SIN);

                    if (matchArrayNot) {
                        longestMatch = value.substring(0, matchArrayNot[0].length + 3);
                    }
                }
                else {
                    for (var i = 0; i < listOfValues.length; i++) {
                        if (this.startsWithIgnoreCase(listOfValues[i].value, value)) {
                            // We found a match
                            if (longestMatch === null || grammar.jql_operators[i].value.length > longestMatch) {
                                longestMatch = grammar.jql_operators[i].value;
                            }
                        }
                    }
                }
                return longestMatch;
            },

            getValueMinusExtraWhitespace: function(value) {
                if (value === null) {
                    return null;
                }
                var newValue = "";
                var firstWhitespace = true;
                var valueArr = value.split("");
                for (var i = 0; i < valueArr.length; i++) {
                    var currentChar = valueArr[i];
                    if (grammar.REGEXP_WHITESPACE.test(currentChar)) {
                        // We want to ignore extra whitespace, keeping only the first
                        if (firstWhitespace) {
                            firstWhitespace = false;
                            newValue = newValue + currentChar;
                        }
                    }
                    else {
                        // If we encounter a non-whitespace then we want to reset our firstWhitespace test
                        firstWhitespace = true;
                        newValue = newValue + currentChar;
                    }
                }
                return newValue;
            },

            fieldOrFunctionName: function(token) {
                var stringValue = this.stringValue(token);
                // Field or function names can not be the empty string
                if (stringValue === "\"\"" || stringValue === "''") {
                    token.setParseError();
                }
                if (this.isReservedWord(stringValue.toLowerCase())) {
                    // These are reserved words
                    token.setParseError();
                }
                return stringValue;
            },

            isReservedWord: function(word) {
                return jQuery.inArray(word, jql_reserved_words) !== -1;
            },

            stringValue: function(token) {
                var stringValue = "";

                var inQuote = false;
                var inSingleQuote = false;
                var currentChar = token.currentCharacter();
                while (currentChar !== null && (inQuote || inSingleQuote || grammar.REGEXP_TOKEN_CHAR.test(currentChar))) {
                    // Read the escape character into the string
                    stringValue = stringValue + currentChar;
                    token.consumeCharacter();
                    // Handle the escape character
                    if (currentChar === '\\') {
                        // Just consume the next char as well
                        currentChar = token.currentCharacter();
                        if (currentChar === null) {
                            token.setParseError();
                            break;
                        }
                        // These are the only valid characters to escape
                        else if (grammar.REGEXP_CHARS_TO_ESCAPE.test(currentChar)) {
                            // Check for unicode escapes
                            var remainingString = token.remainingString();
                            if (!grammar.REGEXP_UNICODE.test(remainingString)) {
                                token.setParseError();
                                break;
                            }
                        }

                        stringValue = stringValue + currentChar;
                        token.consumeCharacter();
                    }
                    // Check for illegal characters and kill the whole parse
                    else if (grammar.REGEXP_SPECIAL_CHAR.test(currentChar) && !(inQuote || inSingleQuote)) {
                        token.setParseError();
                        break;
                    }
                    // We need to keep track if we are in a quote or not
                    else if (currentChar === '"' && !inSingleQuote) {
                        inQuote = !inQuote;
                    }
                    else if (currentChar === "'" && !inQuote) {
                        inSingleQuote = !inSingleQuote;
                    }
                    currentChar = token.currentCharacter();
                }
                // We should never get left in a quote or single quote
                if (token.isComplete() && (inQuote || inSingleQuote)) {
                    token.setParseError();
                }
                return stringValue;
            },

            numberValue: function(token) {
                var numberVal = "";

                this.chewWhitespace(token);
                var currentChar = token.currentCharacter();
                while (currentChar !== null) {
                    if (grammar.REGEXP_NUMBER.test(currentChar)) {
                        numberVal = numberVal + currentChar;
                        token.consumeCharacter();
                    }
                    else {
                        // found not a number time to return
                        break;
                    }
                    currentChar = token.currentCharacter();
                }
                return numberVal;
            },

            wasPredicateComplete: function(predicate) {
                var foundPredicate = false;
                var arLen = grammar.jql_changed_predicates.length;
                for (var i = 0; i < arLen; ++i) {
                    if (predicate.toLowerCase() == grammar.jql_changed_predicates[i].value.toLowerCase()) {
                        foundPredicate = true;
                        break;
                    }

                }
                return foundPredicate;
            }

        };
    };
});

define('jira/jql/jql-parse-result', function() {
    "use strict";

    /**
     * @exports jira/jql/jql-parse-result
     * @class JQLAutoComplete.ParseResult
     */
    return function() {

        var tokens = [];
        var tokenIdx = 0;

        return /** @lends JQLAutoComplete.ParseResult.prototype */ {

            getTokens: function() {
                return tokens;
            },

            addToken: function(token) {
                tokens[tokenIdx++] = token;
            },

            setLastFieldName: function(lastFieldName, token) {
                this.fieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
                // Get rid of quotes if we need to
                this.lastFieldName = this.getUnquotedString(lastFieldName);
                tokens[tokenIdx++] = lastFieldName;
            },

            getLastFieldName: function() {
                return this.lastFieldName;
            },

            getLastFieldNameStartIndex: function() {
                return this.fieldNameStartIndex;
            },

            setLastOrderByFieldName: function(lastFieldName, token) {
                this.orderByFieldNameStartIndex = (lastFieldName === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastFieldName.length);
                // Get rid of quotes if we need to
                this.lastOrderByFieldName = this.getUnquotedString(lastFieldName);
                this.lastOrderByDirection = null;
                tokens[tokenIdx++] = lastFieldName;
            },

            getLastOrderByFieldName: function() {
                return this.lastOrderByFieldName;
            },

            getLastOrderByFieldNameStartIndex: function() {
                return this.orderByFieldNameStartIndex;
            },

            setLastOrderByDirection: function(lastDirection, token) {
                this.orderByDirectionStartIndex = (lastDirection === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastDirection.length);
                this.lastOrderByDirection = lastDirection;
                tokens[tokenIdx++] = lastDirection;
            },

            getLastOrderByDirection: function() {
                return this.lastOrderByDirection;
            },

            getLastOrderByDirectionStartIndex: function() {
                return this.orderByDirectionStartIndex;
            },

            setNeedsField: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = true;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
                this.needsWasPredicate = false;
                this.lastWasOperator = null;
            },

            getNeedsField: function() {
                return this.needsField;
            },

            setNeedsOrderByField: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = true;
                this.needsOrderByDirection = false;
                this.lastOrderByDirection = null;
                this.needsListComma = false;
            },

            getNeedsOrderByField: function() {
                return this.needsOrderByField;
            },

            setNeedsOrderByDirection: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = true;
                this.needsListComma = false;
            },

            getNeedsOrderByDirection: function() {
                return this.needsOrderByDirection;
            },

            setNeedsOrderByComma: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            setNeedsListComma: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = true;
            },

            getNeedsListComma: function() {
                return this.needsListComma;
            },

            setLastOperator: function(lastOperator, startIndex) {
                this.lastOperator = lastOperator;
                this.operatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastOperator;
            },

            setLastWasOperator: function(lastWasOperator) {
                this.lastWasOperator = lastWasOperator;
            },

            getLastWasOperator: function() {
                return this.lastWasOperator;
            },

            getLastOperator: function() {
                return this.lastOperator;
            },

            getLastOperatorStartIndex: function() {
                return this.operatorStartIndex;
            },

            setLastOperand: function(lastOperand, token) {
                this.operandStartIndex = (lastOperand === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOperand.length);
                // Get rid of quotes if we need to
                this.lastOperand = this.getUnquotedString(lastOperand);
                tokens[tokenIdx++] = lastOperand;
            },

            getLastOperand: function() {
                return this.lastOperand;
            },

            setNeedsOperand: function() {
                this.needsField = false;
                this.needsOperator = false;
                this.needsLogicalOperator = false;
                this.needsOperand = true;
                this.needsOrderBy = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            setNeedsOperandOrOperator: function() {
                this.needsField = false;
                this.needsOperator = true;
                this.needsLogicalOperator = false;
                this.needsOperand = true;
                this.needsOrderBy = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            getNeedsOperand: function() {
                return this.needsOperand;
            },

            setNeedsPredicateOperand: function() {
                this.needsPredicateOperand = true;
            },

            resetNeedsPredicateOperand: function() {
                this.needsPredicateOperand = false;
                this.needsOperand = false;
            },

            getNeedsPredicateOperand: function() {
                return this.needsPredicateOperand;
            },

            getLastOperandStartIndex: function() {
                return this.operandStartIndex;
            },

            setLastOperandStartIndex: function(index) {
                this.operandStartIndex = index;
            },

            setLastLogicalOperator: function(lastLogicalOperator, startIndex) {
                this.lastLogicalOperator = lastLogicalOperator;
                this.logicalOperatorStartIndex = startIndex;
                tokens[tokenIdx++] = lastLogicalOperator;
            },

            setNeedsOperator: function() {
                this.needsField = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsOperator = true;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
            },

            getNeedsOperatorOrOperand: function() {
                return this.needsOperator && this.needsOperand;
            },

            getNeedsOperator: function() {
                return this.needsOperator;
            },

            getLastLogicalOperator: function() {
                return this.lastLogicalOperator;
            },

            getLastLogicalOperatorStartIndex: function() {
                return this.logicalOperatorStartIndex;
            },

            setNeedsLogicalOperator: function(token) {
                this.needsLogicalOperator = true;
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsListComma = false;
                // Every time we need a logical operator we also could need an order by as long as we are not in parens
                this.needsOrderBy = !token.getInParens();
                // Every time a logical operator is needed you may need a predicate, but only if the last clause
                // was a was clause
                if (this.lastWasOperator != null) {
                    this.needsWasPredicate = true;
                }
            },

            setNeedsOpenParen: function(value) {
                this.needsOpenParen = value;
            },

            getNeedsOpenParen: function() {
                return this.needsOpenParen;
            },

            getNeedsLogicalOperator: function() {
                return this.needsLogicalOperator;
            },

            setNeedsOrderBy: function(value) {
                this.needsOrderBy = value;
            },

            getNeedsOrderBy: function() {
                return this.needsOrderBy;
            },

            getNeedsWasPredicate: function() {
                return this.needsWasPredicate;
            },

            setLastWasPredicate: function(lastWasPredicate, token) {
                this.wasPredicateStartIndex = (lastWasPredicate === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastWasPredicate.length);
                this.lastWasPredicate = lastWasPredicate;
                tokens[tokenIdx++] = lastWasPredicate;
            },

            getLastWasPredicate: function() {
                return this.lastWasPredicate;
            },

            resetLastPredicates: function() {
                this.lastLogicalOperator = null;
                this.lastWasPredicate = null;
                this.lastOperand = null;
                this.wasPredicateStartIndex = null;
                this.operandStartIndex = null;
            },

            getLastWasPredicateStartIndex: function() {
                return this.wasPredicateStartIndex;
            },

            setLastOrderBy: function(lastOrderBy, token) {
                this.orderByStartIndex = (lastOrderBy === null) ? token.getMaxTokenStringIdx() : (token.getTokenStringIdx() - lastOrderBy.length);
                this.lastOrderBy = lastOrderBy;
                tokens[tokenIdx++] = lastOrderBy;
            },

            getLastOrderBy: function() {
                return this.lastOrderBy;
            },

            getLastOrderByStartIndex: function() {
                return this.orderByStartIndex;
            },

            resetLogicalOperators: function() {
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.needsLogicalOperator = null;
            },

            getUnquotedString: function(value) {
                // We only remove the last quote if it is NOT preceeded by an escape character
                var secondToLastNotEsacape = value != null && value.length >= 3 && value.charAt(value.length - 2) !== '\\';

                if (value != null && value.charAt(0) === '"') {
                    value = value.substring(1, value.length);

                    if (value.charAt(value.length - 1) === '"' && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }
                else if (value != null && value.charAt(0) === "'") {
                    value = value.substring(1, value.length);

                    if (value.charAt(value.length - 1) === "'" && secondToLastNotEsacape) {
                        value = value.substring(0, value.length - 1);
                    }
                }

                return value;
            },

            setParseError: function(message) {
                this.parseError = true;
                this.parseErrorMsg = message;
            },

            getParseError: function() {
                return this.parseError;
            },

            getParseErrorMsg: function() {
                return this.parseErrorMsg;
            },

            setNeedsNothing: function() {
                this.needsOperator = false;
                this.needsOperand = false;
                this.needsLogicalOperator = false;
                this.needsOrderBy = false;
                this.needsField = false;
                this.needsOrderByField = false;
                this.needsOrderByDirection = false;
                this.needsOpenParen = false;
                this.needsListComma = false;
                this.needsWasPredicate = null;
                this.needsPredicateOperand = null;
                this.mustBeOperatorOrPredicate = null;
                this.lastWasOperator = null;
            },

            setOperandComplete: function() {
                this.operandComplete = true;
            },

            getOperandComplete: function() {
                return this.operandComplete;
            },

            setMustBeOperatorOrPredicate: function(state) {
                this.mustBeOperatorOrPredicate = state;
            },

            getMustBeOperatorOrPredicate: function() {
                return this.mustBeOperatorOrPredicate;
            },

            resetTerminalClause: function() {
                this.lastFieldName = null;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.operandComplete = null;
                this.needsOpenParen = null;
                this.needsListComma = false;
                this.mustBeOperatorOrPredicate = null;
            },

            /** @private */
            init: function() {
                this.lastFieldName = null;
                this.fieldNameStartIndex = null;
                this.needsField = null;
                this.lastOperator = null;
                this.operatorStartIndex = null;
                this.needsOperator = null;
                this.lastOperand = null;
                this.operandStartIndex = null;
                this.needsOperand = null;
                this.lastLogicalOperator = null;
                this.logicalOperatorStartIndex = null;
                this.lastOrderByFieldName = null;
                this.lastOrderByFieldNameStartIndex = null;
                this.lastOrderByDirection = null;
                this.lastOrderByDirectionStartIndex = null;
                this.orderByStartIndex = null;
                this.lastOrderBy = null;
                this.needsOrderBy = null;
                this.needsOrderByField = null;
                this.needsOrderByDirection = null;
                this.operandComplete = null;
                this.needsOpenParen = null;
                this.needsListComma = null;
                this.wasPredicateStartIndex = null;
                this.lastWasPredicate = null;
                this.needsWasPredicate = null;
                this.needsPredicateOperand = null;
                this.mustBeOperatorOrPredicate = null;
                this.lastWasOperator = null;
            }
        };
    };
});

define('jira/jql/jql-parse-token', [
    'jira/jql/jql-parse-result'
], function(
    ParseResult
) {
    "use strict";

    /**
     * @exports jira/jql/jql-parse-token
     * @class JQLAutoComplete.Token
     */
    return function() {
        return /** @lends JQLAutoComplete.Token.prototype */ {

            init: function(tokenString) {
                this.tokenStringIdx = 0;
                this.tokenString = tokenString;
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result = ParseResult();
                this.result.init();
                this.inParens = 0;
            },

            consumeCharacter: function() {
                this.tokenStringIdx++;
            },

            consumeCharacters: function(numChars) {
                this.tokenStringIdx = this.tokenStringIdx + numChars;
            },

            backTrackToIdx: function(backTrackIdx) {
                this.tokenStringIdx = backTrackIdx;
                // Lets clear any parse errors that might have occurred as well
                this.parseError = false;
                this.parseErrorMsg = null;
                this.result.parseError = false;
                this.result.parseErrorMsg = null;
            },

            getTokenStringIdx: function() {
                return this.tokenStringIdx;
            },

            currentCharacter: function() {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.charAt(this.tokenStringIdx);
            },

            remainingString: function() {
                if (this.tokenStringIdx >= this.tokenString.length) {
                    return null;
                }
                return this.tokenString.substr(this.tokenStringIdx, this.tokenString.length);
            },

            getMaxTokenStringIdx: function() {
                return this.tokenString.length;
            },

            isComplete: function() {
                if (this.parseError) {
                    return true;
                }
                return this.tokenStringIdx >= this.tokenString.length;
            },

            setInParens: function() {
                this.inParens++;
            },

            setOutOfParens: function() {
                // Lets never go into negative here
                if (this.inParens !== 0) {
                    this.inParens--;
                }
            },

            getInParens: function() {
                return this.inParens !== 0;
            },

            setParseError: function() {
                this.parseError = true;
                var preFixIdx = ((this.tokenStringIdx - 9) < 0) ? 0 : this.tokenStringIdx - 9;
                var errorPrefix = this.tokenString.substring(preFixIdx, this.tokenStringIdx - 1);
                this.result.setParseError("..." + errorPrefix + "^" + this.tokenString.substring(this.tokenStringIdx, this.tokenString.length));
            },

            getParseError: function() {
                return this.parseError;
            },

            calcLastOperandStartIndex: function() {
                var result = this.getResult();
                var operator = result.getLastOperator();
                if (operator.length > 0) {
                    var numSpaces = operator.length - (operator.replace(/\s+/g, '')).length;
                    result.setLastOperandStartIndex(result.getLastOperatorStartIndex() + operator.length + numSpaces + 1);
                }
            },

            getParsedOperator: function() {
                var result = this.getResult();
                return (result.getLastOperator().length > 0) ? this.tokenString.substr(result.getLastOperatorStartIndex()) : null;
            },

            getResult: function() {
                return this.result;
            }

        };

    };
});

/** Preserve legacy namespace
 @deprecated jira.widget.autocomplete.JQL */
AJS.namespace("jira.widget.autocomplete.JQL", null, require('jira/autocomplete/jql-autocomplete'));
AJS.namespace("JIRA.JQLAutoComplete", null, require('jira/autocomplete/jql-autocomplete'));
AJS.namespace("JIRA.JQLAutoComplete.MyParser", null, require('jira/jql/jql-parser'));
AJS.namespace("JIRA.JQLAutoComplete.ParseResult", null, require('jira/jql/jql-parse-result'));
AJS.namespace("JIRA.JQLAutoComplete.Token", null, require('jira/jql/jql-parse-token'));
;
;
/* module-key = 'jira.webresources:jqlautocomplete', location = '/includes/jira/autocomplete/initJQLAutoComplete.js' */
;(function() {
    "use strict";

    var JQLAutoComplete = require('jira/autocomplete/jql-autocomplete');
    var JQLParser = require('jira/jql/jql-parser');
    var Forms = require('jira/util/forms');
    var jQuery = require('jquery');

    jQuery(function() {

        jQuery(".jql-autocomplete-params").each(function() {
            var params = {};

            jQuery(this).find("input").each(function() {
                var $this = jQuery(this);
                params[$this.attr("id")] = $this.val();
            });

            var jqlFieldNames = JSON.parse(jQuery("#jqlFieldz").text());
            var jqlFunctionNames = JSON.parse(jQuery("#jqlFunctionNamez").text());
            var jqlReservedWords = JSON.parse(jQuery("#jqlReservedWordz").text());

            var jqlAutoComplete = JQLAutoComplete({
                fieldID: 'jqltext',
                parser: JQLParser(jqlReservedWords),
                queryDelay: 0.65,
                jqlFieldNames: jqlFieldNames,
                jqlFunctionNames: jqlFunctionNames,
                minQueryLength: 0,
                allowArrowCarousel: true,
                autoSelectFirst: false,
                errorID: 'jqlerrormsg'
            });

            var jQueryRef = jQuery('#jqltext');

            jQueryRef.unbind("keypress", Forms.submitOnEnter).keypress(
                function(e) {
                    if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                        if (e.keyCode === 13 && !e.ctrlKey && !e.shiftKey) {
                            jQuery('#jqlform').submit();
                            return false;
                        } else {
                            return true;
                        }
                    }
                });
            jqlAutoComplete.buildResponseContainer();
            jqlAutoComplete.parse(jQueryRef.text());
            jqlAutoComplete.updateColumnLineCount();

            jQueryRef.click(function() {
                jqlAutoComplete.dropdownController.hideDropdown();
            });
        });
    });
})();
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'util/utils.js' */
(function() {
    "use strict";

    var FunctionalUtils = require("jira/components/util/functionalutils");

    _.mixin({
        lambda: FunctionalUtils.lambda,
        isNotBlank: FunctionalUtils.isNotBlank
    });

    if (!JIRA.Issues) {
        JIRA.Issues = {};
    }

    /**
     * Adds the class 'checkboxmultiselect-container' to the parent form-body div of a sparker.
     * This removes the implicit padding from the container as all other types of searchers
     * have padding by default.
     */
    JIRA.bind(JIRA.Events.CHECKBOXMULITSELECT_READY, function(e, $select) {
        $select.closest(".form-body").addClass("checkboxmultiselect-container");
    });
}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/util.soy' */
// This file was automatically generated from util.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.Issues.ComponentUtil.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.Issues == 'undefined') { JIRA.Templates.Issues = {}; }
if (typeof JIRA.Templates.Issues.ComponentUtil == 'undefined') { JIRA.Templates.Issues.ComponentUtil = {}; }


JIRA.Templates.Issues.ComponentUtil.throbber = function(opt_data, opt_ignored) {
  return '<div class="icon throbber" />';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.throbber.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.throbber';
}


JIRA.Templates.Issues.ComponentUtil.simpleLink = function(opt_data, opt_ignored) {
  return '<a' + ((opt_data.link.id) ? ' id="' + soy.$$escapeHtml(opt_data.link.id) + '"' : '') + 'href="' + ((opt_data.link.href) ? soy.$$escapeHtml(opt_data.link.href) : '#') + '"' + ((opt_data.link.styleClass || opt_data.additionalStyleClass) ? 'class="' + soy.$$escapeHtml(opt_data.link.styleClass) + ((opt_data.additionalStyleClass) ? ' ' + soy.$$escapeHtml(opt_data.additionalStyleClass) : '') + '"' : '') + ((opt_data.link.title) ? 'title="' + soy.$$escapeHtml(opt_data.link.title) + '"' : '') + '><span>' + soy.$$escapeHtml(opt_data.link.label) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.simpleLink.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.simpleLink';
}


JIRA.Templates.Issues.ComponentUtil.issueNotFound = function(opt_data, opt_ignored) {
  return '' + soy.$$filterNoAutoescape(AJS.format("issues.components.query.search.selected.issue.nonexistent.html",opt_data.issueAnchor));
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.issueNotFound.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.issueNotFound';
}


JIRA.Templates.Issues.ComponentUtil.issueAnchor = function(opt_data, opt_ignored) {
  return '<a class="issue-key" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.issueKey) + '"> ' + soy.$$escapeHtml(opt_data.issueKey) + ' </a>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.issueAnchor.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.issueAnchor';
}


JIRA.Templates.Issues.ComponentUtil.buildMessage = function(opt_data, opt_ignored) {
  var output = '';
  if (opt_data.messages.length == 1) {
    output += soy.$$escapeHtml(opt_data.messages[0]);
  } else {
    output += '<ul>';
    var messageList52 = opt_data.messages;
    var messageListLen52 = messageList52.length;
    for (var messageIndex52 = 0; messageIndex52 < messageListLen52; messageIndex52++) {
      var messageData52 = messageList52[messageIndex52];
      output += '<li>' + soy.$$escapeHtml(messageData52) + '</li>';
    }
    output += '</ul>';
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.buildMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.buildMessage';
}


JIRA.Templates.Issues.ComponentUtil.auiMessage = function(opt_data, opt_ignored) {
  return '' + ((opt_data.messages.length > 0) ? '<div class="aui-message ' + soy.$$escapeHtml(opt_data.typeClass) + '"><span class="aui-icon icon-' + soy.$$escapeHtml(opt_data.typeClass) + '"></span>' + JIRA.Templates.Issues.ComponentUtil.buildMessage(opt_data) + '</div>' : '');
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.auiMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.auiMessage';
}


JIRA.Templates.Issues.ComponentUtil.errorMessage = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'error', messages: opt_data.messages ? opt_data.messages : [opt_data.msg]});
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.errorMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.errorMessage';
}


JIRA.Templates.Issues.ComponentUtil.warningMessage = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'warning', messages: opt_data.messages ? opt_data.messages : [opt_data.msg]});
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.warningMessage.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.warningMessage';
}


JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog = function(opt_data, opt_ignored) {
  return '<div class="aui-dialog-content"><div class="form-body"><h2 class="dialog-title">' + soy.$$escapeHtml("Session Expired") + '</h2>' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'warning', messages: ["It looks like your session has timed out, or you have been logged out of JIRA. You will need to log back in to continue."]}) + '</div><div class="buttons-container form-footer"><div class="buttons"><a accesskey="' + soy.$$escapeHtml("s") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to submit this form","s",opt_data.modifierKey)) + '" class="aui-button submit" href="' + soy.$$escapeHtml("/jira") + '/login.jsp?os_destination=' + soy.$$escapeHtml(opt_data.redirect) + '">' + soy.$$escapeHtml("Log in again") + '</a><a accesskey="' + soy.$$escapeHtml("`") + '" title="' + soy.$$escapeHtml(AJS.format("Press {1}+{0} to cancel","`",opt_data.modifierKey)) + '" class="aui-button aui-button-link cancel">' + soy.$$escapeHtml("Ignore") + '</a></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog.soyTemplateName = 'JIRA.Templates.Issues.ComponentUtil.anonymousErrorDialog';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SingleSelectMixin.js' */
define("jira/components/query/mixin/singleselect", function() {
    "use strict";

    /**
     * Mixin that provides single selection on a collection.
     * Requires that the object being mixed into provides "getSelected" and "setSelected" methods. These can be created by having a "selected" attribute or otherwise.
     */
    return {

        /**
         * collection: item in selection
         */
        namedAttributes: ["collection"],

        /**
         * Selects the model with the given id. No validation is done; if the id is invalid, this.selected will be undefined.
         * @param id if of model to select.
         */
        selectById: function(id) {
            this.setSelected(this.getCollection().get(id));
        },

        /**
         * Selects the model and the given index.
         * @param index index of model to select
         */
        selectAt: function(index) {
            this.setSelected(this.getCollection().at(index));
        },

        /**
         * Clears selection
         */
        clearSelection: function() {
            this.setSelected();
        },

        /**
         * Selects the next element, or the first if none is selected.
         */
        next: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.first());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        },

        /**
         * Selects the previous element, or the last if none is selected.
         */
        prev: function() {
            var selected = this.getSelected();
            var col = this.getCollection();

            if (!selected) {
                if (col.length > 0) {
                    this.setSelected(col.last());
                }
            }
            else {
                var index = col.indexOf(selected);
                var nextIndex = (index + col.length - 1) % col.length;
                this.setSelected(col.at(nextIndex));
            }
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query-basic.soy' */
// This file was automatically generated from query-basic.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQueryBasic.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQueryBasic == 'undefined') { JIRA.Templates.IssueNavQueryBasic = {}; }


JIRA.Templates.IssueNavQueryBasic.basicQueryView = function(opt_data, opt_ignored) {
  return '<div class="search-field-container">' + ((opt_data.hasOrderBy) ? '<div class="list-ordering-container"><div class="list-ordering"></div></div>' : '') + '<div class="search-criteria-container"><div class="search-criteria"><ul class="criteria-list"><li class="text-query hidden"><div class="text-query-container"><input class="search-entry text ajs-dirty-warning-exempt" id="searcher-query" type="text" name="text" placeholder="' + soy.$$escapeHtmlAttribute("Contains text") + '" /></div></li><li class="criteria-actions"></li>' + ((opt_data.hasSearchButton) ? '<li><button class="aui-button aui-button-subtle search-button" type="button" title="' + soy.$$escapeHtmlAttribute("Search for issues") + '"><span class="aui-icon aui-icon-small aui-iconfont-search">' + soy.$$escapeHtml("Search") + '</span></button></li>' : '') + '</ul></div><div class="search-criteria-extended"><ul class="criteria-list"></ul></div></div></div><div class="search-options-container"><div class="mode-switcher"></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.basicQueryView.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.basicQueryView';
}


JIRA.Templates.IssueNavQueryBasic.criteriaButton = function(opt_data, opt_ignored) {
  return '<button type="button" data-id="' + soy.$$escapeHtmlAttribute(opt_data.id) + '" class="criteria-selector aui-button aui-button-subtle drop-arrow" /><a href="#" class="remove-filter" title="' + soy.$$escapeHtmlAttribute("Remove criterion") + '" tabindex="-1"><span class="aui-icon aui-icon-small aui-iconfont-remove"></span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.criteriaButton.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.criteriaButton';
}


JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent = function(opt_data, opt_ignored) {
  return '<div class="criteria-wrap">' + ((opt_data.extended || ! opt_data.viewHtml) ? '<span class="fieldLabel">' + soy.$$escapeHtml(opt_data.name) + ':</span> ' : '') + ((opt_data.viewHtml) ? soy.$$filterNoAutoescape(opt_data.viewHtml) : soy.$$escapeHtml("All")) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.criteriaButtonContent';
}


JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent = function(opt_data, opt_ignored) {
  return '<form id="issue-filter" action="#" class="searchfilter aui top-label aui-popup-content"><div class="form-body"></div>' + ((opt_data.displayBackButton) ? '<a href="#" class="back">' + soy.$$escapeHtml("Back") + '</a>' : '') + ((opt_data.displayUpdateCancel) ? '<div class="buttons-container form-footer"><div class="buttons"><input type="submit" name="filter" class="aui-button filter" value="' + soy.$$escapeHtmlAttribute("Update") + '" /><a href="#" class="aui-button aui-button-link cancel-update">' + soy.$$escapeHtml("Close") + '</a></div></div>' : '') + '</form>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.lozengeDropdownContent';
}


JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit = function(opt_data, opt_ignored) {
  return '<div class="searcher-no-edit-content">' + JIRA.Templates.Issues.ComponentUtil.auiMessage({typeClass: 'info', messages: [AJS.format("To search by {0} please switch to advanced.",opt_data.fieldName)]}) + '</div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.lozengeDropdownCannotEdit';
}


JIRA.Templates.IssueNavQueryBasic.clauseButtonView = function(opt_data, opt_ignored) {
  return '<button type="button" class="add-criteria aui-button ' + ((opt_data.isSubtle) ? 'aui-button-subtle' : '') + ' drop-arrow" title="' + soy.$$escapeHtmlAttribute("Add more fields to search with") + '">' + soy.$$escapeHtml("More") + '</button>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.clauseButtonView.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.clauseButtonView';
}


JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent = function(opt_data, opt_ignored) {
  var output = '<div class="searcher-groups available"><ul>';
  var groupList71 = opt_data.searcherGroups;
  var groupListLen71 = groupList71.length;
  for (var groupIndex71 = 0; groupIndex71 < groupListLen71; groupIndex71++) {
    var groupData71 = groupList71[groupIndex71];
    output += '<li class="twixi-block ' + ((groupIndex71 == 0) ? 'expanded' : 'collapsed') + '" data-id="' + soy.$$escapeHtmlAttribute(groupData71.id) + '"><div class="twixi-trigger">' + soy.$$escapeHtml(groupData71.name) + '</div><ul class="twixi-content">';
    var searcherList83 = groupData71.searchers;
    var searcherListLen83 = searcherList83.length;
    for (var searcherIndex83 = 0; searcherIndex83 < searcherListLen83; searcherIndex83++) {
      var searcherData83 = searcherList83[searcherIndex83];
      output += '<li><a href="#" data-id="' + soy.$$escapeHtmlAttribute(searcherData83.id) + '" class="searcher-option" >' + soy.$$escapeHtml(searcherData83.name) + '</a></li>';
    }
    output += '</ul></li>';
  }
  output += '</ul><div class="buttons-container"><div class="buttons"><a href="#" class="aui-button aui-button-link">' + soy.$$escapeHtml("Close") + '</a></div></div></div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent.soyTemplateName = 'JIRA.Templates.IssueNavQueryBasic.searcherDropdownContent';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/TextQueryBuilder.js' */
define("jira/components/query/basic/textquerybuilder", ["require"], function(require) {
    "use strict";

    var jQuery = require("jquery");

    return {
        BACKSLASH_PATTERN: /\\/g,
        MULTIPLE_WHITESPACE_PATTERN: /\s+/g,
        QUOTE_PATTERN: /\"/g,

        DOUBLE_BACKSLASH: "\\\\",

        buildJql: function(textQuery) {
            if (!textQuery) {
                return "";
            }
            textQuery = "" + textQuery;
            textQuery = jQuery.trim(textQuery);
            textQuery = textQuery.replace(this.BACKSLASH_PATTERN, this.DOUBLE_BACKSLASH); // replace single literal backslash with two backslashes (escaped here)
            textQuery = textQuery.replace(this.MULTIPLE_WHITESPACE_PATTERN, " "); // remove multiple whitespaces
            textQuery = textQuery.replace(this.QUOTE_PATTERN, "\\\"");
            return this.createQueryClause(textQuery);
        },

        createQueryClause: function(searchTerm) {
            return 'text ~ "' + searchTerm + '"';
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/BasicQueryModule.js' */
define("jira/components/query/basic/basicquerymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var BasicQueryView = require("jira/components/query/basic/basicqueryview");
    var SearcherCollection = require("jira/components/query/basic/searchercollection");

    /**
     * Module for basic query mode
     */
    return Brace.Evented.extend({

        namedEvents: ["jqlTooComplex", "searchRequested", "basicModeCriteriaCountWhenSearching", "verticalResize"],

        initialize: function(options) {
            this._queryStateModel = options.queryStateModel;
            this.searcherCollection = new SearcherCollection([], {
                fixedLozenges: options.primaryClauses,
                queryStateModel: options.queryStateModel,
                initData: options.initialSearcherCollectionState,
                context: options.context
            });
            this.view = new BasicQueryView({
                queryStateModel: options.queryStateModel,
                searcherCollection: this.searcherCollection
            })
                .onVerticalResize(this.triggerVerticalResize, this)
                .onSearchRequested(this.triggerSearchRequested, this);

            this.searcherCollection.onSearchRequested(_.bind(function(jql) {
                this.triggerBasicModeCriteriaCountWhenSearching({
                    count: this.searcherCollection.getAllSelectedCriteriaCount()
                });
                var jqlWithOrderBy = this._attachOrderByClause(jql);
                this.triggerSearchRequested(jqlWithOrderBy);
            }, this));

            this.searcherCollection.onJqlTooComplex(_.bind(function(jql) {
                this.triggerJqlTooComplex(jql);
            }, this));
        },

        hasErrors: function() {
            return this.searcherCollection.any(function(searcherModel) {
                return searcherModel.hasErrorInEditHtml();
            });
        },

        /**
         * Remove all searchers and clear the text query.
         */
        clear: function() {
            this.searcherCollection.clear();
        },

        queryChanged: function() {
            this.searcherCollection.restoreFromQuery(this._queryStateModel.getJql());
        },

        queryReset: function(jql) {
            this.searcherCollection.setInteractive(false);
            return this.searcherCollection.restoreFromQuery(jql, true).always(_.bind(function() {
                this.searcherCollection.setInteractive(true);
            }, this));
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this.searcherCollection.searchersReady();
        },

        createView: function() {
            return this.view;
        },

        getSelectedCriteria: function() {
            return this.searcherCollection.getAllSelectedCriteria();
        },

        _attachOrderByClause: function(jql) {
            var orderByRegex = /\bORDER\s+BY\b.*$/i;
            var existingOrderByClause = orderByRegex.exec(this._queryStateModel.getJql());
            if (existingOrderByClause && orderByRegex.exec(jql) === null) {
                jql = jql ? jql + ' ' + existingOrderByClause[0] : existingOrderByClause[0];
            }
            return jql;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CriteriaView.js' */
define("jira/components/query/basic/criteriaview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var Tipsy = require("jira/issues/tipsy");

    return Brace.View.extend({

        tagName: 'li',

        template: IssueNavQueryBasic.criteriaButton,
        contentTemplate: IssueNavQueryBasic.criteriaButtonContent,

        events: {
            'click': 'hideTipsy',
            'click .criteria-selector': '_onClickCriteriaSelector',
            'click .remove-filter': '_onClickRemoveCriteria',
            'mousedown .remove-filter': '_preventFocusWhileDisabled',
            'keydown': '_onKeydown'
        },

        initialize: function(options) {
            this.extended = options.extended; // Indicates that a valid criteria can be removed from the UI
            this.searcherCollection = options.searcherCollection;
            this.searcherCollection.onCollectionChanged(this.update, this);
            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged, this);
            this.searcherCollection.bind('change:isSelected', this._onCriteriaSelectionChanged, this);

            SearcherDialog.instance.onHide(_.bind(this._addTooltip, this));
            SearcherDialog.instance.onShow(_.bind(this._onCriteriaDialogShow, this));
        },

        /**
         * Initial render, should only be called once
         */
        render: function() {
            this.$el.html(this.template({
                id: this.model.getId()
            }));
            this.$el.attr('data-id', this.model.getId());
            if (this.extended) {
                this.$el.addClass('extended-searcher');
            }
            this.update();
            this.prepareForDisplay();
        },

        /**
         * Prepare the view before it is displayed: hook up event handlers, etc.
         */
        prepareForDisplay: function() {
            this._addTooltip();
            this.delegateEvents();
        },

        hideTipsy: function() {
            if (this.tipsy) {
                this.tipsy.hide();
            }
        },

        /**
         * Update view to reflect model changes
         */
        update: function() {

            var noSearchers = this.searcherCollection.length === 0; // Searchers have not loaded, but render them anyway default 'All' value
            var searcher = this._getSearcher();
            var validSearcher = this._isValidSearcher();
            var hidden = (!noSearchers && !searcher) || (searcher && !searcher.getIsShown()); // Searchers have loaded, but this searcher is not present
            var disabled = noSearchers || !validSearcher;
            var $button = this.$('button');
            var $cross = this.$('.remove-filter');

            this.$el.toggleClass('hidden', hidden);

            $button
                .attr('aria-disabled', disabled ? 'true' : null)
                .html(this.contentTemplate({
                    name: searcher && searcher.getName() || this.model.getName(),
                    viewHtml: searcher && searcher.getViewHtml(),
                    extended: this.extended
                }));

            // Validity
            this.$el
                .toggleClass('invalid-searcher', !validSearcher)
                .toggleClass('partial-invalid-searcher', (validSearcher && $button.find(".invalid_sel").length !== 0));

            $cross.toggleClass('hidden', !(!validSearcher || !!this.extended));

            return this;
        },

        /**
         * Destroys and cleans up the criteria view.
         * As the name implies, this is a destructive operation, and the View should not be used afterwards (construct a new one if needed).
         * Meant for use with extended criteria - primary criteria should only be hidden, not destroyed.
         */
        destroy: function() {
            this.hideTipsy();
            this.$el.remove();
        },

        _getSearcher: function() {
            return this.searcherCollection.get(this.model.getId());
        },

        /**
         * Searcher validity: returns true if there is no searcher, or searcher is valid
         */
        _isValidSearcher: function() {
            var searcher = this._getSearcher();
            return !searcher || (searcher.getValidSearcher() !== false); // Assume getValidSearcher()===undefined means valid searcher
        },

        /**
         * Value validity: returns true if there is an invalid value for the searcher
         */
        _containsInvalidValue: function(searcher) {
            return (jQuery(searcher.getViewHtml()).find('.invalid_sel').length > 0);
        },

        _showDialog: function() {
            if (this.searcherCollection.isInteractive() && this._getSearcher() && this._isValidSearcher()) {
                SearcherDialog.instance.show(this._getSearcher());
            }
        },

        /**
         * Clear the searcher jql for this criteria
         *
         * direction is optional, and supplied when removing a criteria by
         * Backspace or Delete keys, which have an implicit direction associated with them.
         * The direction is passed along with the beforeCriteriaRemoved event so BasicQueryView can choose
         * an appropriate element to focus.
         *
         * If supplied, direction is either -1 (back) or 1 (forward)
         */
        _removeCriteria: function(direction) {
            var removable = this.extended || !this._isValidSearcher();
            if (this.searcherCollection.isInteractive() && removable) {
                this.searcherCollection.triggerBeforeCriteriaRemoved(this.model.getId(), direction);
                /*
                 Need to defer otherwise InlineLayer will hide. This happens because the inline dialog chooses to close
                 if the target element clicked is not a child element of the InlineLayer. Because we switch the content in the
                 dialog, the back link is no longer in the InlineLayer therefor not a child element.  To rectify the problem
                 we delay the toggling of content.
                 */
                _.defer(_.bind(function() {
                    this.searcherCollection.clearClause(this.model.getId());
                }, this));
            }
        },

        /**
         * @return the text to show in the searcher's tooltip.
         * @private
         */
        _getTooltipText: function() {
            var searcherModel = this.searcherCollection.get(this.model.getId());
            var tooltipText;

            if (!this._isValidSearcher()) {
                tooltipText = "This criteria is not valid for the project and/or issue type";
            } else if (this._containsInvalidValue(searcherModel)) {
                tooltipText = "This criteria contains invalid value(s)";
            } else {
                tooltipText = searcherModel.getTooltipText();
            }

            return searcherModel && tooltipText || "";
        },

        /**
         * Add a tooltip to the searcher.
         * <p/>
         * This method can safely be called multiple times.
         *
         * @private
         */
        _addTooltip: function() {
            this.tipsy = new Tipsy({
                el: this.$el,
                showCondition: this.searcherCollection.isInteractive,
                tipsy: {
                    title: _.bind(this._getTooltipText, this)
                }
            });
        },

        _handleInteractiveChanged: function(interactive) {
            this.$("button, .remove-filter").attr("aria-disabled", (interactive) ? null : "true");
        },

        _onClickCriteriaSelector: function(event) {
            if (this.searcherCollection.isInteractive() && this._getSearcher() && this._isValidSearcher()) {
                SearcherDialog.instance.toggle(this._getSearcher());
            }
            event.preventDefault();
        },

        _onClickRemoveCriteria: function(event) {
            this._removeCriteria();
            event.preventDefault();
        },

        _onKeydown: function(event) {
            switch (event.which) {
                case jQuery.ui.keyCode.DOWN:
                    this._showDialog();
                    break;
                case jQuery.ui.keyCode.ESCAPE:
                    this.$('button:focus').blur();
                    break;
                case jQuery.ui.keyCode.BACKSPACE:
                    this._removeCriteria(-1);
                    break;
                case jQuery.ui.keyCode.DELETE:
                    this._removeCriteria(1);
                    break;
                default:
                    return;
            }
            event.preventDefault();
        },

        /**
         * Remove the searcher's tooltip if its dialog is showing.
         * <p/>
         * Called when jira/components/query/basic/searcherdialog is shown.
         *
         * @private
         */
        _onCriteriaDialogShow: function() {
            var currentSearcher = SearcherDialog.instance.getCurrentSearcher();
            if (currentSearcher === this._getSearcher()) {
                if (this.tipsy) {
                    this.tipsy.remove();
                }
            }
        },

        _preventFocusWhileDisabled: function(event) {
            if (jQuery(event.target).closest("[aria-disabled=true]").length > 0) {
                event.preventDefault();
            }
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherModel.js' */
define("jira/components/query/basic/searchermodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var DisplayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;
    var contextPath = AJS.contextPath();

    return Brace.Model.extend({
        /**
         * id: searcher id
         * name: The name of the clause
         * viewHtml: html to display in the criteria selector button, or the text to display in the input for the text searcher.
         * editHtml: html to display in the edit dropdown
         * groupId: group id
         * groupName: group name
         * isSelected: whether or not the searcher has been selected as a criteria for a search
         * jql: jql representation of the clause
         * position: The searcher's position in the extended criteria view.
         * validSearcher: is entire searcher valid for current search context
         * lastViewed: the time the searcher was last viewed in milliseconds
         */
        namedAttributes: [
            "id",
            "name",
            "isShown",
            "viewHtml",
            "editHtml",
            "groupId",
            "groupName",
            "initParams",
            "isSelected",
            "jql",
            "position",
            "serializedParams",
            "validSearcher",
            "key",
            "lastViewed"
        ],

        /**
         * readyForDisplay: edit html has been retrieved and is ready to be displayed
         */
        namedEvents: ["readyForDisplay"],

        initialize: function() {
            // Extract the "baseline" params from the edit HTML.
            this._onEditHtmlUpdated();
            this.bind("change:editHtml", this._onEditHtmlUpdated, this);
        },

        parse: function(json) {
            if (json.viewHtml) {
                json.viewHtml = this._cleanViewHtml(json.viewHtml);
            }
            return json;
        },

        /**
         * "Cleans" view HTML returned from the server for display.
         *
         * @param viewHtml The original view HTML.
         * @return the cleaned view HTML.
         * @private
         */
        _cleanViewHtml: function(viewHtml) {
            var $container = jQuery("<div/>").appendCatchExceptions(viewHtml);
            $container.find(".fieldLabel").remove();

            // Remove links, leaving their HTML content.
            $container.find("a").replaceWith(function() {
                return jQuery(this).html();
            });

            // Most searchers only have one "searcherValue" even if multiple values
            // are selected. For those with multiple, insert dashes between them.
            $container.find(".searcherValue").slice(0, -1).each(function() {
                jQuery(this).after('-');
            });

            // Remove titles so they don't conflict with our tooltips.
            $container.find("*").removeAttr("title");
            return $container.html();
        },

        /**
         * @param {Boolean} [forceUpdate=false] Force update of the JQL, even if autoupdate is disabled
         * @returns {*}
         */
        createOrUpdateClauseWithQueryString: function(forceUpdate) {
            return this.collection.createOrUpdateClauseWithQueryString(this.id, forceUpdate);
        },

        getQueryString: function() {

            var params = {};
            // custom handling for text query
            if (this.collection.QUERY_ID === this.getId()) {
                if (this.getViewHtml()) {
                    params[this.collection.QUERY_PARAM] = this.getDisplayText(); // query string shouldn't be html-encoded
                    return jQuery.param(params);
                }
                return null;
            }

            // return jql for invalid searchers as the server doesn't return editHtml if a searcher is invalid, but it does return jql
            if ((!this.getValidSearcher() || /^\s*$/.test(this.getEditHtml())) && this.getJql()) {
                params = {};
                params[this.collection.JQL_INVALID_QUERY_PREFIX + this.getId()] = this.getJql();
                return jQuery.param(params);
            }

            return this.getSerializedParams();
        },

        /**
         * Returns just the text of the viewHtml, cleaning up whitespace.
         */
        getDisplayText: function() {
            var html = this.getViewHtml();
            var text = '';
            if (html) {
                var $container = jQuery('<div>').appendCatchExceptions(html);
                text = jQuery.trim($container.text()).replace(/[\n\r\s]+/g, ' ');
            }
            return text;
        },

        hasClause: function() {
            if (this.collection.QUERY_ID === this.getId()) {
                return !!this.getViewHtml();
            }
            else if (!this.getValidSearcher()) {
                return !!this.getJql();
            }
            else {
                return !!this.getQueryString();
            }
        },

        /**
         * Reset the searcher's state.
         */
        clearSearchState: function() {
            this.set({
                viewHtml: null,
                editHtml: null,
                jql: null,
                validSearcher: null,
                isSelected: false
            });
        },

        /**
         * Returns the current time in milliseconds. Cannot always use Date.now() because of IE8.
         */
        _now: Date.now || function() {
            return new Date().getTime();
        },

        select: function() {
            this.set({
                isSelected: true,
                position: this.collection.getNextPosition(),
                validSearcher: true,
                lastViewed: this._now()
            });
        },

        /**
         * Ensures edit html exists. Triggers readyForDisplay when editHtml has been retrieved, which may be asynchronous if the value has not been retrieved,
         * or immediate if we already have editHtml
         */
        retrieveEditHtml: function() {
            var jql = this.collection.createJql();

            // TODO: Abort a pending request if there is one.
            // Avoid race condition -- ensure last request received is also last request issued.

            /* EditHtml is always populated when we request the list of searchers from the server,
             * for all searchers that have a value. We will always have editHtml when first showing a searcher.
             * this.getEditHtml() will be null in 2 cases:
             * - when we have just added a new searcher and it has no value
             * - when we have closed a dialog and are waiting for the list of searchers (and new editHtml) to update.
             * The second case is done because we *don't* cache the editHtml DOM elements. When showing an edit dialog
             * we have to regenerate the DOM - however because the elements might have changed (eg values entered into
             * inputs) we clear this.editHtml on hide (see this.clearEditHtml) so that it will be re-requested on show.
             */

            if (this.getEditHtml()) {
                return new jQuery.Deferred().resolve(this.getEditHtml());
            }

            return SmartAjax.makeRequest({
                type: "POST",
                url: contextPath + "/secure/QueryComponentRendererEdit!Default.jspa",
                success: _.bind(this.setEditHtml, this),
                dataType: "html",
                error: DisplayFailSearchMessage,
                data: {
                    fieldId: this.getId(),
                    decorator: "none",
                    jqlContext: jql
                }
            });
        },

        /**
         * Returns true if this element has edit html and it contains an error class
         */
        hasErrorInEditHtml: function() {
            var $el = jQuery('<div>').htmlCatchExceptions(this.getEditHtml());
            if (!$el) {
                return false;
            } else {
                return $el.find(".error, .has-errors").length > 0;
            }
        },

        // See this._fetchEditHtml
        clearEditHtml: function() {
            this.setEditHtml(null);
        },

        _onEditHtmlUpdated: function() {
            this.setSerializedParams(jQuery("<form/>").appendCatchExceptions(this.getEditHtml()).serialize());
        },

        /**
         * @return the text to be shown in the searcher's tooltip.
         */
        getTooltipText: function() {
            if (this.getValidSearcher !== false) {
                var value = this.getDisplayText() || "All";
                return this.getName() + ": " + value;
            } else {
                return "This criteria is not valid for the project and/or issue type";
            }
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this.collection.searchersReady();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherCollection.js' */
define("jira/components/query/basic/searchercollection", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var Meta = require("jira/util/data/meta");
    var SearcherModel = require("jira/components/query/basic/searchermodel");
    var TextQueryBuilder = require("jira/components/query/basic/textquerybuilder");
    var FunctionalUtils = require("jira/components/util/functionalutils");
    var SmartAjax = require("jira/ajs/ajax/smart-ajax");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var ItemDescriptor = require("jira/ajs/list/item-descriptor");
    var LatestSearchStore = require("jira/components/search/latestStorage");
    var contextPath = AJS.contextPath();
    var displayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;

    var ajsEscapeHtml = AJS.escapeHtml;

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    return Brace.Collection.extend({

        model: SearcherModel,

        /**
         * searchRequested: a user action has caused us to select a new search
         *
         * collectionChanged: the collection has changed. This is fired at most once per public interface method. Clients
         * requesting changes should listen to this method to receive updates instead of add, change, remove if they
         * want only a single notification of change.
         *
         * requestUpdateFromView: requests non-auto-submit views (eg text query view) to update the form values in their model
         *
         * beforeCriteriaRemoved: a user action caused a criteria to be removed from view. Args: id, direction
         */
        namedEvents: ["searchRequested", "collectionChanged", "jqlTooComplex", "textFieldChanged", "requestUpdateFromView", "interactiveChanged", "beforeCriteriaRemoved"],

        QUERY_PARAM: "text",
        QUERY_ID: "text",

        /**
         * Prefix used to send jql for invalid searchers to the server, because we don't generate editHtml for invalid searchers
         * (but we can generate jql)
         */
        JQL_INVALID_QUERY_PREFIX: "__jql_",

        initialize: function(models, options) {
            if (models && models.length) {
                this._searcherCache = models;
            }
            this.fixedLozenges = options && options.fixedLozenges ? options.fixedLozenges : [];
            this.queryStateModel = options && options.queryStateModel;
            this.initData = options && options.initData;
            this.context = options && options.context;
            this._interactive = true;
        },

        /**
         * Converts an array of SearcherModels to an array of ItemDescriptors.
         *
         * @param {Array<JIRA.Issues.SearcherModel>} searchers
         * @return {Array<AJS.ItemDescriptor>}
         */
        _createItemDescriptors: function(searchers) {
            return _.map(searchers, function(searcher) {
                return new ItemDescriptor({
                    meta: {
                        isShown: searcher.isShown
                    },
                    label: searcher.name,
                    title: searcher.isShown ? searcher.name : searcher.name + " " + "is not applicable for the current project and/or issue type.",
                    selected: searcher.isSelected || searcher.jql,
                    value: searcher.id
                });
            });
        },

        /**
         * Construct group and item descriptors for the "add criteria" menu.
         * <p/>
         * Returns valid non-primary searchers sorted by name (case insensitive).
         *
         * @return {Array} AJS.GroupDescriptors for the "add criteria" menu.
         */
        getAddMenuGroupDescriptors: function() {
            // Retrieve all valid, non-primary searchers.
            this._updateSearcherCache();

            var primarySearcherIds = this.fixedLozengeIds().concat(this.QUERY_ID);

            var searchers = _.filter(this._searcherCache, function(searcher) {
                var isPrimary = _.contains(primarySearcherIds, searcher.id);
                var isValid = !!searcher.groupName;
                return !isPrimary && isValid;
            });

            if (searchers.length) {
                var allSearchers = new GroupDescriptor({
                    label: "All Criteria",
                    items: this._createItemDescriptors(_.sortBy(searchers, function(searcher) {
                        return searcher.name.toLowerCase();
                    }))
                });
                var recentSearchers = new GroupDescriptor({
                    label: "Recent Criteria",
                    items: this._createItemDescriptors(_.first(_.sortBy(_.filter(searchers, function(searcher) {
                        return searcher.lastViewed;
                    }), function(searcher) {
                        return -searcher.lastViewed;
                    }), Meta.getNumber("max-recent-searchers")))
                });
                return [recentSearchers, allSearchers];
            } else {
                return [];
            }
        },

        /**
         * Returns a searcher by id from either the model collection or the raw searcher cache.
         *
         * If a model is not found in the model collection it is added from the raw cache and returned.
         *
         * Assumes that a searcher being requested, if not present in the model collection, is in the raw searcher
         * collection. This is done as the raw searchers are used to generate the searcher list.
         *
         * @param id The Searcher ID
         */
        getSearcher: function(id) {
            var searcher = this.get(id);

            if (!searcher) {
                this.add(this._searcherCache[id]);
                searcher = this.get(id);
            }

            return searcher;
        },

        /**
         * Sets the jql for the model with the given id, creating one if it doesn't exist
         * @param id id of model
         * @param jql jql to set
         */
        setJql: function(id, jql) {
            this._addOrSet(id, {
                jql: jql
            });
        },

        /**
         * Returns a single jql string expressing all subclauses in this collection.
         */
        createJql: function() {
            var arr = this.pluck("jql");
            return _.filter(arr, FunctionalUtils.isNotBlank).join(" AND ") || "";
        },

        /**
         * Has the user specified any clauses?
         */
        isDirty: function() {
            return this.any(function(lozenge) {
                // clauses are ultimately defined by a jql clause
                return lozenge.getJql() !== undefined && lozenge.getJql() !== ""; // TODO the stupid text field strikes again. it has a "" state after routing
            });
        },

        /**
         * Clears entire search state
         */
        clearSearchState: function() {
            this.each(function(searcherModel) {
                searcherModel.clearSearchState();
            });
            // TODO: optimise by only requerying server if search state changes
            this._querySearchersAndValues("");
        },

        /**
         * Clear the search state for a single searcher.
         *
         * If the searcher has a clause (i.e. it could be affecting search results),
         * the search will be re-performed.
         *
         * @param id The id of searcher.
         */
        clearClause: function(id) {
            // We don't need to requery here if invalid clauses
            var searcher = this.get(id);
            var hasClause = searcher && searcher.hasClause();

            if (searcher) {
                searcher.clearSearchState();
            }

            this.triggerCollectionChanged();
            this.triggerRequestUpdateFromView();

            // We only need to refresh results if the searcher had a clause.
            if (hasClause) {
                this.triggerSearchRequested(this.createJql());
            }
        },

        getTextQuery: function() {
            var model = this.get(this.QUERY_ID);
            return model ? model.getViewHtml() : "";
        },

        /**
         * Set the interactive flag to indicate whether searchers respond to user input.
         * @param {boolean} interactive
         */
        setInteractive: function(interactive) {
            if (interactive !== this._interactive) {
                this._interactive = interactive;
                this.triggerInteractiveChanged(interactive);
            }
        },

        /**
         * Determine whether searchers respond to user input.
         * @return {boolean}
         */
        isInteractive: function() {
            return this._interactive;
        },

        handleBasicViewSubmit: function() {
            this.triggerRequestUpdateFromView();
            this.triggerSearchRequested(this.createJql());
        },

        updateTextQuery: function(textQuery) {
            if (textQuery) {
                var textQueryHtml = ajsEscapeHtml(textQuery);
                this._addOrSet(this.QUERY_ID, {
                    viewHtml: textQueryHtml,
                    editHtml: textQueryHtml,
                    jql: TextQueryBuilder.buildJql(textQuery)
                });
            }
            else {
                this.remove(this.QUERY_ID);
            }
            this.triggerTextFieldChanged();
        },

        /**
         * Creates a queryString representing all querystring members
         * @return {string}
         */
        getQueryString: function() {
            var queryStrings = [];
            this.each(function(searcherModel) {
                var qs = searcherModel.getQueryString();
                if (qs) {
                    queryStrings.push(qs);
                }
            });
            return queryStrings.join("&");
        },

        /**
         * Adds or sets parameters. If a model with the given id is found, the values in params are set. Otherwise a model is created
         * with the given id and params.
         * @param id id to of model to find.
         * @param params parameters
         * @param options
         */
        _addOrSet: function(id, params, options) {
            var model = this.get(id);
            if (model) {
                // Backbone doesn't support parse: true for set()
                if (options && options.parse && model.parse) {
                    params = model.parse(params);
                    delete options.parse;
                }
                if (params.jql) {
                    params.isSelected = true;
                }
                model.set(params, options);
            } else {
                var paramsWithId = _.clone(params);
                paramsWithId.id = id;
                paramsWithId.isSelected = !!params.jql;
                this.add(paramsWithId, options);
                model = this.get(id);
            }
            return model;
        },

        /**
         * Update the basic mode query view to represent the given jql unless the jql can't fit into the basic view.
         * IF the query is "too complex" a jqlTooComplex event is fired.
         * @param {JIRA.Issues.queryStateModel} jql
         * @param reset
         */
        restoreFromQuery: function(jql, reset) {

            // We won't have JQL if a filter is private; just show empty searchers.
            this.queryStateModel.setJql(jql);
            var contextJql = this._getJqlWithContext(jql);

            var requestData = {
                jql: contextJql || "",
                decorator: "none"
            };

            // If the request is already in the URL we don't always need to call search, but we persist the current
            // search anyway
            LatestSearchStore.save(requestData);

            // We store a json blob on the page when we first load so we don't need to go to the server.
            if (this.initData) {
                if (!this.initData.errorMessages) {
                    this._onQuerySearchersAndValues(this.initData);
                    this.initData = null;
                    return new jQuery.Deferred().resolve();
                } else {
                    // this json blob may also contain errors
                    this._handleSearcherError(requestData.jql, this.initData);
                    this.initData = null;
                    return new jQuery.Deferred().reject();
                }
            } else {
                var response = jQuery.ajax({
                    url: contextPath + "/secure/QueryComponent!Jql.jspa",
                    headers: {'X-SITEMESH-OFF': true},
                    data: requestData,
                    type: "POST"
                });

                response.success(_.bind(function(data) {
                    if (reset) {
                        this.clearExpectingUpdate(reset);
                    }
                    this._onQuerySearchersAndValues(data);
                }, this));

                response.error(_.bind(function(resp) {
                    if (reset) {
                        this.clearExpectingUpdate();
                    }
                    try {
                        var json = JSON.parse(resp.responseText);
                        if (json) {
                            this._handleSearcherError(requestData.jql, json);
                        }
                    } catch (e) {
                        /*eslint-disable no-console */
                        console.log("search response error - not JSON?");
                        /*eslint-enable no-console */
                    }

                }, this));

                response.always(function() {
                    trace("jira.search.searchers.updated");
                });

                return response;
            }

        },

        /**
         * Resets state, before we apply new values.
         */
        clearExpectingUpdate: function() {
            this.reset();
            this.updateTextQuery("");
        },

        /**
         *  Handles error when requesting searchers
         *
         * @param jql
         * @param data
         * @private
         */
        _handleSearcherError: function(jql, data) {
            if (_.include(data.errorMessages, "jqlTooComplex") || _.include(data.errorMessages, "jqlInvalid")) {
                // I know I know. A bloody setTimeout.
                // This is because when we first load the page as we are not async (we are using json blob from page) this
                // event is triggered before switchToPreferred search is called. This means that we flick to advanced but
                // then back to the preferred search (which could be basic). If the jql is too complex we need to be sure

                window.setTimeout(_.bind(function() {
                    this.triggerJqlTooComplex(jql);
                }, this), 0);
            }
        },

        searcherAffectsContext: function(id) {
            return "project" === id || 'issuetype' === id;
        },

        /**
         * Tells the clause to update from the values selected in its editHtml, creating or updating it as required.
         * This update involves an AJAX request to retrieve the jql and criteria content from the server.
         * @param id -- SearcherModel id
         * @param {Boolean} [forceUpdate=false] Force update of the JQL, even if autoupdate is disabled
         */
        createOrUpdateClauseWithQueryString: function(id, forceUpdate) {

            this.triggerRequestUpdateFromView();

            var deferred;
            if (this.searcherAffectsContext(id)) {
                // Requery all searchers and values
                deferred = this._querySearchersAndValues(this.getQueryString());
            }
            else {
                deferred = this._querySearchersByValue(id);
            }

            deferred.done(_.bind(function() {
                if ((this.queryStateModel.getBasicAutoUpdate() || forceUpdate) && !this.containsInvalidSearchers()) {
                    this.triggerSearchRequested(this.createJql());
                }
            }, this));

            return deferred;

            // TODO: could optimise by only requesting all searchers and values when context changes (ie project or issue type)
            // and requesting only valuehtml for other cases. see _querySingleValue
        },

        containsInvalidSearchers: function() {
            return this.any(function(searcherModel) {
                return searcherModel.hasErrorInEditHtml();
            });
        },

        _querySearchersByValue: function(id) {
            var model = this.get(id);
            var data = jQuery.param({
                decorator: "none",
                jqlContext: this.queryStateModel.getJql()
            });

            if (model) {
                var modelString = model.getQueryString();
                if (modelString) {
                    data = data + '&' + modelString;
                }
            }

            if (this._activeSearcherReq) {
                this._activeSearcherReq.abort();
            }

            this._activeSearcherReq = SmartAjax.makeRequest({
                type: "POST",
                data: data,
                processData: false,
                url: contextPath + "/secure/QueryComponentRendererValue!Default.jspa",
                success: _.bind(function(data) {
                    var model = this.get(id);
                    if (model) {
                        if (data[id]) {
                            data[id].groupName = model.getGroupName();
                            data[id].groupId = model.getGroupId();
                        } else {
                            // If the searcher isn't present in the response, then
                            // it currently has no value and we need to reset it.
                            data[id] = _.extend(model.toJSON(), {
                                editHtml: null,
                                jql: null,
                                viewHtml: null
                            });
                        }
                    }

                    this._setSearchersFromData(data, true);
                }, this),
                dataType: "json",
                error: function(xhr) {
                    displayFailSearchMessage(xhr);
                }
            }).always(_.bind(function() {
                this._activeSearcherReq = null;
            }, this));

            return this._activeSearcherReq;
        },

        /**
         * Returns a map by id of all searchers from the response
         * @param data response data
         */
        _parseSearcherGroups: function(data) {
            var searchers = {};
            var without = this.queryStateModel.getWithout();

            _.each(data.groups, function(group) {
                _.each(group.searchers, function(searcher) {
                    if (!_.contains(without, searcher.id)) {
                        searcher.groupId = group.type;
                        searcher.groupName = group.title;
                        searchers[searcher.id] = searcher;
                    }
                });
            });

            return searchers;
        },

        _querySearchersAndValues: function(queryString) {

            var data = "decorator=none";

            if (this._activeSearcherReq) {
                // If it is the same as the request we are currently waiting for we can just ignore.
                if (this._activeSearcherQuery === queryString) {
                    return new jQuery.Deferred().reject();
                }
                // Otherwise we will abort and issue a new request.
                this._activeSearcherReq.abort();
            }

            // store data for this request so we can use it to compare against new requests
            this._activeSearcherQuery = queryString;

            if (queryString) {
                data += "&" + queryString;
            }

            this._activeSearcherReq = jQuery.ajax({
                url: contextPath + "/secure/QueryComponent!Default.jspa",
                headers: {'X-SITEMESH-OFF': true},
                type: "POST",
                data: data,
                processData: false
            });

            this._activeSearcherReq.done(_.bind(function(data) {
                this._onQuerySearchersAndValues(data);
            }, this));

            this._activeSearcherReq.fail(_.bind(function(xhr) {
                displayFailSearchMessage(xhr);
            }, this));

            this._activeSearcherReq.always(_.bind(function() {
                this._activeSearcherReq = null;
            }, this));

            return this._activeSearcherReq;
        },

        /**
         * Remove all searchers from the collection and clear the text query.
         */
        clear: function() {
            this.reset([], {silent: true});
            this.updateTextQuery("");
            this.triggerCollectionChanged();
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            if (this._activeSearcherReq) {
                return this._activeSearcherReq;
            } else {
                return new jQuery.Deferred().resolve();
            }
        },

        _onQuerySearchersAndValues: function(data) {

            // merge searchers and values from response
            var searchers = this._parseSearcherGroups(data.searchers);
            var without = this.queryStateModel.getWithout();
            _.each(data.values, _.bind(function(value, id) {
                // compose searcher and value from response
                var searcher = searchers[id];
                if (_.contains(without, id)) {
                    value.isShown = false;
                    value.validSearcher = false;
                    value.jql = "";
                }
                if (!searcher) {
                    searchers[id] = value;
                }
                else {
                    _.extend(searcher, value);
                }

            }, this));

            var modelsToRemove = [];
            this.each(function(searcher) {
                var searcherId = searcher.id;
                if (!_.any(searchers, function(newSearcher) {
                        return newSearcher.id === searcherId;
                    })) {
                    if (searcher.getIsSelected()) {
                        searcher.setValidSearcher(false);
                    } else {
                        modelsToRemove.push(searcher);
                    }
                }
            });
            if (modelsToRemove.length) {
                this.remove(modelsToRemove);
            }

            this._setSearchersFromData(searchers);
        },

        /**
         * Updates the searcher cache to mirror the current state of the searcher collection.
         *
         * @private
         */
        _updateSearcherCache: function() {
            if (this._searcherCache) {
                this.each(_.bind(function(searcher) {
                    this._searcherCache[searcher.id] = searcher.toJSON();
                    this._searcherCache[searcher.id].id = searcher.id;
                }, this));
            }
        },

        /**
         * Sets the initial state of the searcher collection.
         *
         * Accepts a JSON object of raw searcher definitions and values and adds
         * real SearcherModels to SearcherCollection for each if they are primary or
         * they have viewHtml (i.e. in use).
         *
         * This is an optimisation to prevent every searcher model being instantiated
         * which is an incredibly slow process in IE8.
         *
         * @param searchers
         * @param update
         * @private
         */
        _setSearchersFromData: function(searchers, update) {
            _.each(searchers, _.bind(function(value, id) {
                this._addOrSet(id, {
                    groupId: value.groupId,
                    groupName: value.groupName,
                    isShown: value.isShown,
                    name: value.name,
                    viewHtml: value.viewHtml,
                    jql: value.jql,
                    editHtml: value.editHtml,
                    validSearcher: value.validSearcher,
                    key: value.key,
                    lastViewed: value.lastViewed
                }, {parse: true});
            }, this));

            if (update) {
                this._updateSearcherCache();
            } else {
                this._searcherCache = searchers;
            }

            this.triggerCollectionChanged();

            trace("jira.search.searchers.updated");
        },

        /**
         * combine the jql with the context jql. The purpose of this method is narrow down the option values in dropdownlist following the context
         * (for ex: in project, if project does not define issue type "Bug", the dropdown list should not render "Bug" option)
         * contextJql (for ex: project = "Service Desk")
         * @param jql (for ex: issuetype = "IT Help")
         * @return a complete jql in a scope. (project = "Service Desk' AND issuetype = "IT Help"_
         */
        _getJqlWithContext: function(jql) {
            var contextJql = this.context ? this.context : jql;
            if (this.context && jql) {
                contextJql = this.context + " AND " + jql;
            }
            return contextJql;
        },

        /**
         * Return a list of extended criteria.
         * - the searcher has a value
         * - the searcher is not query text or a primary clause
         */
        getVariableClauses: function() {
            var variableClauses = [];
            this.each(_.bind(function(searcherModel) {
                if (!this.isFixed(searcherModel) && searcherModel.hasClause()) {
                    variableClauses.push(searcherModel);
                }
            }, this));

            return variableClauses;
        },

        /**
         * @return {JIRA.Issues.SearcherModel[]} All selected non-prime searchers,
         *     in ascending order of position.
         */
        getSelectedCriteria: function() {
            var instance = this;
            var isSelectedCriteria = function(searcher) {
                return !instance.isFixed(searcher) &&
                    (searcher.hasClause() || searcher.getIsSelected());
            };

            return this.chain()
                .filter(isSelectedCriteria)
                .sortBy(function(searcher) {
                    return searcher.getPosition();
                })
                .value();
        },

        getAllSelectedCriteriaCount: function() {
            return this.getAllSelectedCriteria().length;
        },

        getAllSelectedCriteria: function() {
            var selectedCriteria = [];

            this.each(_.bind(function(searcherModel) {
                if (searcherModel.hasClause() || searcherModel.getIsSelected()) {
                    selectedCriteria.push(searcherModel);
                }
            }, this));

            return selectedCriteria;
        },

        isFixed: function(searcherModel) {
            return _.contains(this.fixedLozengeIds(), searcherModel.getId()) || searcherModel.getId() === this.QUERY_ID;
        },

        fixedLozengeIds: function() {
            return _.pluck(this.fixedLozenges, "id");
        },

        /**
         * Extended criteria searchers have position values that are used to
         * determine their position in ExtendedCriteriaView; they appear in
         * ascending order. This method calculates the next position value.
         *
         * @return {number} The next position value.
         */
        getNextPosition: function() {
            return this.reduce(function(memo, searcher) {
                    var max = Math.max(memo, searcher.getPosition());
                    return isNaN(max) ? memo : max;
                }, -1) + 1;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CriteriaModel.js' */
/**
 *
 * A CriteriaModel is a simple representation of a SearcherModel of the same id and name
 * so that the criterion can still be rendered before the SearcherModel has been constructed.
 * This happens in the case of primary criteria since they are rendered on page load, but their values
 * still need to be retrieved.
 *
 * To get the actual searcher values, the SearcherModel should be accessed from SearcherCollection, e.g:
 *
 *     var searcherModel = searchCollection.get(criteriaModel.getId())
 *
 */
define("jira/components/query/basic/criteriamodel", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");

    return Brace.Model.extend({
        namedAttributes: ["id", "name"]
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/CardView.js' */
define("jira/components/query/basic/cardview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");

    /**
     * View that switching between a couple of views
     */
    return Brace.View.extend({

        /**
         * viewChanged: fired when the active view is changed.
         */
        namedEvents: ["viewChanged"],

        /**
         * @param options
         * options.views: map of views by id (required)
         * options.activeView: id of view to show (optional, defaults to first in view)
         */
        initialize: function(options) {
            this.views = options.views;
            if (options.activeView) {
                this.activeView = options.activeView;
            }
            else {
                var keys = _.keys(this.views);
                if (keys.length > 0) {
                    this.activeView = keys[0];
                }
            }
        },

        /**
         * Renders the table element's contents.
         */
        render: function() {
            this._renderActiveView();
        },

        /**
         * Sets the active view. If id is the current active view, this is a no-op.
         * @param id id of view to make active
         */
        changeToView: function(id) {
            if (id === this.activeView) {
                return;
            }
            this.activeView = id;
            if (this.$el) {
                this._renderActiveView(id);
            }
            this.triggerViewChanged(id);
        },

        _renderActiveView: function() {
            var view = this.views[this.activeView];
            view.setElement(this.$el);
            view.render();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/BasicQueryView.js' */
define("jira/components/query/basic/basicqueryview", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var TextFieldView = require("jira/components/query/basic/textfieldview");
    var PrimaryCriteriaContainerView = require("jira/components/query/basic/primarycriteriacontainerview");
    var ExtendedCriteriaContainerView = require("jira/components/query/basic/extendedcriteriacontainerview");
    var ClauseButtonView = require("jira/components/query/basic/clausebuttonview");
    var Tipsy = require("jira/issues/tipsy");
    var OrderBy = require("jira/components/orderby");

    /**
     * Renders the Basic Query component.
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize", "searchRequested"],

        template: IssueNavQueryBasic.basicQueryView,

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            this.queryStateModel = options.queryStateModel;

            this.textFieldView = new TextFieldView({
                collection: this.searcherCollection
            });

            // Subview for rendering primary criteria (project, assignee, etc)
            this.primaryCriteriaContainerView = new PrimaryCriteriaContainerView({
                collection: this.searcherCollection
            });

            // Subview for rendering extended criteria
            this.extendedCriteriaContainerView = new ExtendedCriteriaContainerView({
                collection: this.searcherCollection
            }).onVerticalResize(this.triggerVerticalResize, this);

            if (this.queryStateModel.getBasicOrderBy()) {
                this.basicOrderByView = OrderBy.create();

                this.queryStateModel.on("change:jql", function() {
                    this.basicOrderByView.setJql(this.queryStateModel.getJql());
                }, this);

                this.basicOrderByView.onSort(this.triggerSearchRequested, this);
            }

            // The subview for the clear all and add additional filters.
            this.clauseButtonView = new ClauseButtonView({
                searcherCollection: this.searcherCollection,
                queryStateModel: this.queryStateModel
            });

            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged, this);
            this.searcherCollection.onBeforeCriteriaRemoved(this._handleBeforeCriteriaRemoved, this);
        },

        _handleInteractiveChanged: function(interactive) {
            this.$el.toggleClass("loading", !interactive);
        },

        _handleBeforeCriteriaRemoved: function(id, direction) {
            // If a criteria was removed with a direction, focus on the next focusable element in that direction
            if (direction) {
                this._shiftFocus(id, direction);
            }
        },

        /**
         * This render function is only called when the BasicQueryView is first initialized,
         * and also when switching from advanced to basic mode.
         *
         * All further renders are handled at the sub-view level.
         */
        render: function() {
            this.$el.html(this.template({
                hasOrderBy: this.queryStateModel.getBasicOrderBy(),
                hasSearchButton: this.queryStateModel.hasSearchButton()
            }));

            this.primaryCriteriaContainerView.setElement(this.$el.find(".search-criteria .criteria-list"));
            this.textFieldView.setElement(this.$el.find("input.search-entry"));
            this.clauseButtonView.setElement(this.$el.find(".criteria-actions"));
            this.extendedCriteriaContainerView.setElement(this.$el.find(".search-criteria-extended .criteria-list"));
            if (this.basicOrderByView) {
                this.basicOrderByView.setElement(this.$el.find(".list-ordering")).render();
                this.basicOrderByView.setJql(this.queryStateModel.getJql());
            }

            this.primaryCriteriaContainerView.render();
            this.$el.find(".text-query").removeClass("hidden");

            this.textFieldView.render();
            this.clauseButtonView.render();

            this.extendedCriteriaContainerView.render();

            this._handleInteractiveChanged(this.searcherCollection.isInteractive());
            this.triggerVerticalResize();

            new Tipsy({
                el: this.$el.find(".search-button"),
                tipsy: {
                    trigger: "hover",
                    delayIn: 300
                }
            });

            return this;
        },

        /**
         * Performs a search using the current state in the Basic Query View.
         */
        search: function() {
            this.searcherCollection.handleBasicViewSubmit();
        },

        /**
         * Put the focus on the next focusable element in the given direction (-1: back, 1: forward),
         * assuming the currently focused item is about to be removed
         */
        _shiftFocus: function(currentId, direction) {
            var $current = this.primaryCriteriaContainerView.getFocusableForCriteria(currentId);
            if (!$current.length) {
                $current = this.extendedCriteriaContainerView.getFocusableForCriteria(currentId);
            }
            var $allFocusables = this.primaryCriteriaContainerView.getFocusables()
                .add(this.extendedCriteriaContainerView.getFocusables());
            var currentIndex = $allFocusables.index($current);
            var nextIndex;
            // If the element being removed is at either end, there is only 1 element the focus can move to,
            // irrespective of direction
            if (currentIndex === 0) {
                nextIndex = 1;
            } else if (currentIndex === $allFocusables.length - 1) {
                nextIndex = $allFocusables.length - 2;
            } else {
                nextIndex = currentIndex + direction;
            }
            $allFocusables.eq(nextIndex).focus();
        },

        focus: function() {
            this.primaryCriteriaContainerView.getFocusables().first().focus();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/TextFieldView.js' */
define("jira/components/query/basic/textfieldview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");

    /**
     * Simple Query View's text search field.
     */
    return Brace.View.extend({

        namedEvents: ["searchRequested"],

        events: {
            keypress: "handleKeypress"
        },

        initialize: function() {
            _.bindAll(this,
                "_updateSearcherCollectionTextField",
                "_handleInteractiveChanged",
                "render");

            this.collection.on("remove change add", _.bind(function(model) {
                if (model.getId() === this.collection.QUERY_ID) {
                    this.render();
                }
            }, this));
            this.collection.onTextFieldChanged(this.render);
            this.collection.onRequestUpdateFromView(this._updateSearcherCollectionTextField);
            this.collection.onInteractiveChanged(this._handleInteractiveChanged);
        },

        handleKeypress: function(e) {
            if (e.keyCode === 13) {
                this.collection.handleBasicViewSubmit();
                e.preventDefault();
            }
        },

        render: function() {
            // Attempt to extract the query from the model's edit HTML. If that
            // fails, just fall back to its display value (used in tests too).
            var model = this.collection.get(this.collection.QUERY_ID);

            if (model) {
                // the html is just a raw value html encoded
                var val = model.getEditHtml();
                var decodedVal = jQuery('<div></div>').html(val || '').text();
                this.setQuery(decodedVal);
            } else {
                this.setQuery("");
            }
        },

        setQuery: function(query) {
            this.$el.val(query);
        },

        _updateSearcherCollectionTextField: function() {
            if (this.$el.is("input")) {
                var textFieldValue = jQuery.trim(this.$el.val());
                this.collection.updateTextQuery(textFieldValue);
            }
        },

        _handleInteractiveChanged: function(interactive) {
            // Disable the text input while noninteractive.
            this.$el.prop("disabled", !interactive);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/PrimaryCriteriaContainerView.js' */
define("jira/components/query/basic/primarycriteriacontainerview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var CriteriaView = require("jira/components/query/basic/criteriaview");
    var CriteriaModel = require("jira/components/query/basic/criteriamodel");

    return Brace.View.extend({

        initialize: function() {
            this._criteriaViews = _.map(this.collection.fixedLozenges, function(primary) {
                return new CriteriaView({
                    model: new CriteriaModel(primary),
                    searcherCollection: this.collection
                });
            }, this);
        },

        render: function() {
            _.each(this._criteriaViews, function(view) {
                view.render();
            });

            this.$el.prepend(_.pluck(this._criteriaViews, 'el'));
        },

        getCriteriaViews: function() {
            return this._criteriaViews;
        },

        /**
         * Returns a jQuery array of elements within this container that can be tab-focused
         */
        getFocusables: function() {
            return this.$('.criteria-selector, #searcher-query, .add-criteria, .search-button');
        },

        /**
         * Returns the focusable element for the given criteria. The element returned should be one
         * of the elements in getFocusables()
         */
        getFocusableForCriteria: function(criteriaId) {
            return this.$('.criteria-selector[data-id="' + criteriaId + '"]');
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ExtendedCriteriaContainerView.js' */
define("jira/components/query/basic/extendedcriteriacontainerview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var CriteriaView = require("jira/components/query/basic/criteriaview");
    var CriteriaModel = require("jira/components/query/basic/criteriamodel");

    /**
     * View that handles displaying a search clause and creating its associated dialog
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        initialize: function() {
            this.collection.on('change:isSelected', this._onCriteriaSelectionChanged, this);
            this.collection.on('add', this._onCriteriaSelectionChanged, this);
            this.collection.on('remove', this._removeViewForSearcher, this);
            this.collection.on('reset', this._onReset, this);

            this._criteriaViews = _.map(this.collection.getSelectedCriteria(), _.bind(function(searcherModel) {
                if (searcherModel.getPosition() == null) {
                    searcherModel.setPosition(this.collection.getNextPosition());
                }
                return this._buildCriteriaViewForSearcher(searcherModel);
            }, this));
        },

        render: function() {
            _.each(this._criteriaViews, _.bind(function(criteriaView) {
                criteriaView.render();
                this.$el.append(criteriaView.$el);
            }, this));
        },

        /**
         * Returns a jQuery array of elements within this container that can be tab-focused
         */
        getFocusables: function() {
            return this.$('.criteria-selector');
        },

        /**
         * Returns the focusable element for the given criteria. The element returned should be one
         * of the elements in getFocusables()
         */
        getFocusableForCriteria: function(criteriaId) {
            return this.$('.criteria-selector[data-id="' + criteriaId + '"]');
        },

        _buildCriteriaViewForSearcher: function(searcherModel) {
            return new CriteriaView({
                model: new CriteriaModel({
                    id: searcherModel.get('id'),
                    name: searcherModel.get('name')
                }),
                searcherCollection: this.collection,
                extended: true
            });
        },

        /**
         * Handles the adding and removing of extended criteria
         */
        _onCriteriaSelectionChanged: function(searcherModel) {
            if (searcherModel.getIsSelected() && !this.collection.isFixed(searcherModel)) {
                this._addViewForSearcher(searcherModel);
            } else {
                this._removeViewForSearcher(searcherModel);
            }
        },

        _addViewForSearcher: function(searcherModel) {
            var criteriaView = this._buildCriteriaViewForSearcher(searcherModel);
            criteriaView.render();
            this.$el.append(criteriaView.$el);
            this._criteriaViews.push(criteriaView);
            this.triggerVerticalResize();
        },

        _removeViewForSearcher: function(searcherModel) {
            this._criteriaViews = _.reject(this._criteriaViews, function(criteriaView) {
                if (criteriaView.model.getId() === searcherModel.getId()) {
                    criteriaView.destroy();
                    return true; // Reject
                }
                return false;
            });
            this.triggerVerticalResize();
        },

        _onReset: function() {
            _.each(this._criteriaViews, function(criteriaView) {
                criteriaView.destroy();
            });
            this._criteriaViews = [];
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherGroupListDialogView.js' */
define("jira/components/query/basic/searchergrouplistdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var CheckboxMultiSelectSuggestHandler = require("jira/ajs/select/suggestions/checkbox-multi-select-suggest-handler");
    var CheckboxMultiSelect = require("jira/ajs/select/checkbox-multi-select");
    var SuggestHelper = require("jira/ajs/select/suggestions/suggest-helper");
    var GroupDescriptor = require("jira/ajs/list/group-descriptor");
    var Tipsy = require("jira/issues/tipsy");
    var AJSTemplates = AJS.Templates;
    var ajsHideReason = AJS.HIDE_REASON;

    var $moreCriteriaFooter;

    /**
     * List of searchers that can be added to a search
     */
    var module = Brace.View.extend({

        template: IssueNavQueryBasic.searcherDropdownContent,

        /**
         * searcherSelected(id): a searcher has been selected. id is the id of the searcher
         * hideRequested: dialog close has been requested
         */
        namedEvents: ["searcherSelected", "hideRequested"],

        events: {
            "keydown": "_keyPressed"
        },

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            this.$el.scrollLock('.aui-list-scroll');
        },

        render: function() {

            var descriptors = this.searcherCollection.getAddMenuGroupDescriptors();
            var tooManySearchers = descriptors.length && descriptors[0].properties.items.length > module.CRITERIA_DISPLAY_LIMIT;

            var select = jQuery(AJSTemplates.queryableSelect({
                descriptors: descriptors,
                id: "criteria"
            }));

            // Even though it works, weird stuff happens if you call .html(select) since select is a jQuery object.
            this.$el.empty().append(select);

            var options = {
                element: select,
                suggestionsHandler: module.SuggestHandler,
                hideFooterButtons: true
            };

            var searchersHiddenMessage = "...excluding \u003cspan class=hidden-no\u003e\u003c/span\u003e hidden";
            var searchersHiddenDetails = "These criteria are hidden because they are not applicable to the current project and/or issue type";

            // Performance optimisation. When appending more than 100 custom fields performance suffers dramatically.
            if (tooManySearchers) {
                options.maxInlineResultsDisplayed = module.CRITERIA_DISPLAY_LIMIT;
                searchersHiddenMessage = "...excluding \u003cspan class=hidden-no\u003e\u003c/span\u003e hidden. Please enter a keyword to refine.";
                searchersHiddenDetails = "These criteria are hidden because there are either too many to display or they are not applicable to the current project and/or issue type";
            }

            new CheckboxMultiSelect(options);

            $moreCriteriaFooter = jQuery("<div class='more-criteria-footer' />").html(searchersHiddenMessage);
            this.$el.append($moreCriteriaFooter);
            new Tipsy({
                el: $moreCriteriaFooter,
                tipsy: {
                    title: function() {
                        return searchersHiddenDetails;
                    },
                    className: "tipsy-front"
                }
            });

            // this.$el is an element owned by AJS.InlineLayer and is detached from the dom each time we switch
            // from basic to advanced. Thus, we need to rebind when we render rather than use the backbone way of
            // binding.
            this.$el.unbind("selected").bind("selected", _.bind(this._searcherSelected, this));
            this.$el.unbind("unselect").bind("unselect", _.bind(this._searcherUnselected, this));

            return this.$el;
        },

        _searcherUnselected: function(e, descriptor) {
            this.searcherCollection.clearClause(descriptor.properties.value);
        },

        _searcherSelected: function(e, descriptor) {
            var searcher = this.searcherCollection.getSearcher(descriptor.properties.value);
            searcher.select();
            SearcherDialog.instance.hide();
            SearcherDialog.instance.show(searcher);
        },

        _keyPressed: function(event) {
            if (event.keyCode === jQuery.ui.keyCode.TAB) {
                var tabbableElements = jQuery(":tabbable", this.$el);

                var noTabbableElements = (tabbableElements.length === 0);
                var shiftTabbingOnFirst = (event.shiftKey && (document.activeElement === tabbableElements.first()[0]));
                var tabbingOnLast = (!event.shiftKey && (document.activeElement === tabbableElements.last()[0]));

                if (noTabbableElements || shiftTabbingOnFirst || tabbingOnLast) {
                    this.triggerHideRequested(ajsHideReason.tabbedOut);
                    event.preventDefault();
                }
            }
        }
    }, {
        CRITERIA_DISPLAY_LIMIT: 100
    });

    module.SuggestHandler = CheckboxMultiSelectSuggestHandler.extend({
        formatSuggestions: function(groups, query) {
            var numberHidden = 0;
            var selectedItems = SuggestHelper.removeDuplicates(this.model.getDisplayableSelectedDescriptors());

            // Prepend a group containing all selected items.
            groups.splice(0, 0, new GroupDescriptor({
                actionBarHtml: selectedItems.length > 1 ? this.createClearAll() : null,
                items: selectedItems,
                styleClass: "selected-group"
            }));

            _.each(groups, function(group) {
                if (query.length === 0) {
                    var items = _.filter(group.items(), function(item, index) {
                        var meta = item.meta();
                        return meta && meta.isShown && index < module.CRITERIA_DISPLAY_LIMIT;
                    });

                    numberHidden += group.items().length - items.length;
                    group.items(items);
                } else {
                    _.each(group.items(), function(item) {
                        var meta = item.meta();
                        item.disabled(!(meta && meta.isShown));
                    });
                }
            });

            _.defer(function() {
                if ($moreCriteriaFooter) {
                    if (numberHidden) {
                        $moreCriteriaFooter.show().find(".hidden-no").text(numberHidden);
                    } else {
                        $moreCriteriaFooter.hide();
                    }
                }
            });

            return groups;
        }
    });

    return module;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherEditDialogView.js' */
define("jira/components/query/basic/searchereditdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var Events = require("jira/util/events");
    var Types = require("jira/util/events/types");
    var Reasons = require("jira/util/events/reasons");
    var AJSHideReason = AJS.HIDE_REASON;

    /**
     * The view for editing the value that one criterion has.
     *
     */
    return Brace.View.extend({

        namedEvents: ["backRequested", "hideRequested"],

        autoUpdate: [".js-autoupdate-checkboxmultiselect", ".js-default-checkboxmultiselect", ".js-default-checkboxmultiselectstatuslozenge", ".js-user-checkboxmultiselect", ".js-usergroup-checkboxmultiselect", ".js-group-checkboxmultiselect", ".js-label-checkboxmultiselect"],

        events: function() {
            var events = {
                "click .cancel-update": "_onCancelClicked",
                "click": "_stopPropagation",
                "submit": "_onSubmit",
                'keydown': '_keyPressed'
            };

            if (this.queryStateModel.getBasicAutoUpdate()) {
                events["selected " + this.autoUpdate.join(',')] = "applyChanges";
                events["unselect " + this.autoUpdate.join(',')] = "applyChanges";
            }

            return events;
        },

        template: IssueNavQueryBasic.lozengeDropdownContent,

        initialize: function(options) {
            this._formData = "";
            this.queryStateModel = options.queryStateModel;
            this.$el.scrollLock('.aui-list-scroll');
        },

        renderDeferred: function() {
            var deferred = new jQuery.Deferred();
            // Ask the searcher to retrieve html (which will trigger readyForDisplay immediately if the editHtml is cached)
            this.model.retrieveEditHtml().done(_.bind(function(editHtml) {
                deferred.resolve(this.render(editHtml));
            }, this));
            return deferred.promise();
        },

        hasAutoUpdate: function(editHtml) {
            return this.queryStateModel.getBasicAutoUpdate() && jQuery(editHtml).find(this.autoUpdate.join(',')).length !== 0;
        },

        render: function(editHtml) {
            var containsEditContent = !(/^\s*$/.test(editHtml));
            var renderedContent;
            if (containsEditContent) {
                renderedContent = jQuery(this.template({
                    displayBackButton: this.displayBackButton,
                    displayUpdateCancel: !this.hasAutoUpdate(editHtml) && !jQuery(editHtml).hasClass("searchfilter-not-found")
                }));
            } else {
                renderedContent = jQuery(IssueNavQueryBasic.lozengeDropdownCannotEdit({fieldName: this.model.getName()}));
            }

            this.$el.html(renderedContent);
            this.$el.find(".form-body").appendCatchExceptions(editHtml);
            this.$el.find("form").addClass(this.model.id + "-criteria");
            this.$el.find("label:first").remove(); // Server sends back label. todo: remove label on server
            // Trigger NEW_CONTENT_ADDED as searchers may need to add js to editHtml
            Events.trigger(Types.NEW_CONTENT_ADDED, [this.$el, Reasons.criteriaPanelRefreshed]);
            this._formData = this.$el.find("form").serialize();
            this.model.setInitParams(this._formData);
            return this.$el;
        },

        _stopPropagation: function(e) {
            e.stopPropagation();
        },

        _preventDefault: function(e) {
            e.preventDefault();
        },

        /**
         * @return {Boolean}
         */
        applyFilter: function() {
            var formData = this.$el.find("form").serialize();
            // Note: We can't compare formData to this.model.getSerializedParams() since this
            // is updated by the searcher HTML request, causing hasChanged to always evaluate
            // to true. @see JRADEV-14898
            var hasChanged = (formData !== this._formData);
            this._formData = formData;
            this.model.setSerializedParams(this._formData);
            return hasChanged;
        },

        applyChanges: function() {
            if (this.applyFilter()) {
                this.model.createOrUpdateClauseWithQueryString();
            }
        },

        // For non-auto-updating searchers only. This is different to clicking on "clear" within the CheckboxMultiSelect.
        _onCancelClicked: function(e) {
            e.preventDefault();
            this.triggerHideRequested(AJSHideReason.cancelClicked);
        },

        _onSubmit: function(e) {
            e.preventDefault();
            this.triggerHideRequested(AJSHideReason.submit);
        },

        _keyPressed: function(event) {
            if (event.keyCode === jQuery.ui.keyCode.TAB) {
                var tabbableElements = jQuery(":tabbable", this.$el);

                var noTabbableElements = (tabbableElements.length === 0);
                var shiftTabbingOnFirst = (event.shiftKey && (document.activeElement === tabbableElements.first()[0]));
                var tabbingOnLast = (!event.shiftKey && (document.activeElement === tabbableElements.last()[0]));

                if (noTabbableElements || shiftTabbingOnFirst || tabbingOnLast) {
                    this.triggerHideRequested(AJSHideReason.tabbedOut);
                    event.preventDefault();
                }
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ClauseListDialogView.js' */
define("jira/components/query/basic/clauselistdialogview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");

    /**
     * List of clauses (ie searchers with a value) that have been added to the search
     */
    return Brace.View.extend({

        events: {
            "click .clauses .searcherValue": "_clauseSelected",
            "click .remove-filter": "_removeFilterRequested"
        },

        template: IssueNavQueryBasic.enabledClauses,

        namedEvents: ["clauseSelected", "hideRequested"],

        initialize: function(options) {
            this.searcherCollection = options.searcherCollection;
            // TODO: bind to valueUpdated to rerender on change?
            this.searcherCollection.onCollectionChanged(this._renderAndCheckForClose, this);
        },

        render: function() {
            this.$el.html(this.template({
                clauses: this._getClauses()
            }));
        },

        /**
         * Re-renders and checks to
         */
        _renderAndCheckForClose: function() {
            this.render();
            if (!this._getClauses().length) {
                this.triggerHideRequested();
            }
        },

        _clauseSelected: function(e) {
            e.preventDefault();
            var $target = jQuery(e.target);
            var id = $target.parents("li").first().data("id");
            this.triggerClauseSelected(id);
        },

        _removeFilterRequested: function(e) {
            e.preventDefault();

            var instance = this;

            /*
             Need to defer otherwise InlineLayer will hide This happens because the inline dialog chooses to close
             if the target element clicked is not a child element of the InlineLayer. Because we switch the content in the
             dialog, the back link is no longer in the InlineLayer therefor not a child element.  To rectify the problem
             we delay the toggling of content.
             */
            _.defer(function() {
                var $target = jQuery(e.target);
                var $listElement = $target.parents("li").first();
                var id = $listElement.data("id");

                instance.searcherCollection.clearClause(id);

                $listElement.remove();
                instance.triggerHideRequested();
            });
        },

        _getClauses: function() {
            var clauses = this.searcherCollection.getVariableClauses();
            var clausesJson = _.invoke(clauses, "toJSON");
            _.each(clausesJson, this._formatForTemplate);
            return clausesJson;
        },

        _formatForTemplate: function(clauseJson) {
            if (clauseJson.validSearcher) {
                clauseJson.invalidMessage = "";
            }
            else {
                clauseJson.invalidMessage = "This criteria is not valid for the project and/or issue type";
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/ClauseButtonView.js' */
define("jira/components/query/basic/clausebuttonview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryBasic = require("jira/components/query/templates/issuenavquerybasic");
    var SearcherGroupListDialogView = require("jira/components/query/basic/searchergrouplistdialogview");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var Tipsy = require("jira/issues/tipsy");
    var AJSLeft = AJS.LEFT;
    var AJSHideReason = AJS.HIDE_REASON;

    /**
     * View that handles "add criteria" and "clear criteria" buttons
     */


    return Brace.View.extend({

        template: IssueNavQueryBasic.clauseButtonView,

        addCriteriaButton: ".add-criteria",

        events: {
            "click .add-criteria": "_showDialog",
            "keydown .add-criteria": "_onKeydown"
        },

        initialize: function(options) {
            _.bindAll(this,
                "_handleInteractiveChanged",
                "_showOrHideClauseButtons");

            var instance = this;

            this.queryStateModel = options.queryStateModel;
            this.searcherCollection = options.searcherCollection;
            this.searcherCollection.onCollectionChanged(this._showOrHideClauseButtons);
            this.searcherCollection.onInteractiveChanged(this._handleInteractiveChanged);

            var dialog = this.dialog = new InlineLayer({
                width: "auto",
                alignment: AJSLeft,
                // Lazilly get offset target as it isn't in the DOM at this time
                offsetTarget: function() {
                    return instance.$el.find(instance.addCriteriaButton);
                },
                // Each time we open our dialog this function will be called to retrieve content
                content: function() {
                    /*eslint-disable no-use-before-define */
                    return listView.render();
                    /*eslint-enable no-use-before-define */
                }
            });

            dialog.bind(InlineLayer.EVENTS.hide, function(e, layer, reason) {
                if (reason === AJSHideReason.escPressed || reason === AJSHideReason.toggle ||
                    reason === AJSHideReason.tabbedOut) {
                    instance.$(instance.addCriteriaButton).focus();
                }
            });

            // Contents of InlineLayer
            var listView = new SearcherGroupListDialogView({
                searcherCollection: this.searcherCollection,
                dialog: dialog
            });

            // Allow the view inside of the InlineLayer to trigger hiding
            listView.onHideRequested(function(reason) {
                dialog.hide(reason);
            });

            dialog.bind(InlineLayer.EVENTS.show, function(event, $layer) {
                jQuery("#criteria-input").focus();
                // List.js also resets the scrollTop but because the dialog is still hidden at that point, the browser won't actually do any scrolling.
                // @see JRADEV-15097
                $layer.find(".aui-list-scroll").scrollTop(0);
            });
        },

        render: function() {
            this.$el.html(this.template({
                isSubtle: this.queryStateModel.hasSubtleMoreCriteria()
            }));
            this._showOrHideClauseButtons();
            this._addToolTip();
            return this.$el;
        },

        _addToolTip: function() {
            new Tipsy({
                el: this.$el.find(this.addCriteriaButton),
                showCondition: ":not(.active)"
            });
        },

        _showOrHideClauseButtons: function() {
            var addFiltersButton = this.$(this.addCriteriaButton);
            if (this.searcherCollection.getAddMenuGroupDescriptors().length > 0) {
                addFiltersButton.show();
            } else {
                addFiltersButton.hide();
            }
        },

        _showDialog: function(event) {
            if (this.searcherCollection.isInteractive()) {
                this.dialog.toggle();
            }
            event.preventDefault();
        },

        _handleInteractiveChanged: function(interactive) {
            this.$(this.addCriteriaButton).attr("aria-disabled", (interactive) ? null : "true");
        },

        _onKeydown: function(event) {
            switch (event.which) {
                case jQuery.ui.keyCode.DOWN:
                    this._showDialog(event);
                    break;
                case jQuery.ui.keyCode.ESCAPE:
                    jQuery(event.target).blur();
                    break;
                case jQuery.ui.keyCode.BACKSPACE:
                    // Prevent Backspace on the Add Criteria button from navigating back in history
                    break;
                default:
                    return;
            }
            event.preventDefault();
        }

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/basic/SearcherDialog.js' */
define("jira/components/query/basic/searcherdialog", ["require"], function() {
    "use strict";

    var SearcherEditDialogView = require("jira/components/query/basic/searchereditdialogview");
    var _ = require("jira/components/libs/underscore");
    var InlineLayer = require('jira/ajs/layer/inline-layer');
    var AJSHideReason = AJS.HIDE_REASON;
    var AJSLeft = AJS.LEFT;
    var jQuery = require("jquery");

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    /**
     * A singleton that reuses the same InlineLayer for many different criteria selectors.
     */
    var module = function() {

        return {
            initialize: function(options) {
                if (!this.instance) {
                    this.instance = initSearcherDialog(options);
                }
            }
        };

        function initSearcherDialog(options) {
            AJSHideReason.switchLozenge = "switchLozenge";

            var reasonsToFocusCriteria = [
                AJSHideReason.escPressed,
                AJSHideReason.toggle,
                AJSHideReason.cancelClicked,
                AJSHideReason.submit,
                AJSHideReason.tabbedOut
            ];

            function findLozenge(searcher) {
                return searcher ? jQuery(".criteria-selector[data-id='" + searcher.getId() + "']") : jQuery();
            }

            var promise;
            var _currentSearcher; // JIRA.Issues.SearcherModel
            var _currentView;

            var _dialog = new InlineLayer({
                width: "auto",
                alignment: AJSLeft,
                offsetTarget: function() {
                    // Don't cache the lozenge under the current implementation since it can get reblatted
                    return findLozenge(_currentSearcher);
                },
                // Uses AJS.DeferredContentRetriever.
                content: function() {
                    _currentView = new SearcherEditDialogView({
                        model: _currentSearcher,
                        queryStateModel: options.queryStateModel
                    });
                    _currentView.onHideRequested(function(reason) {
                        _dialog.hide(reason);
                    });
                    return _currentView.renderDeferred();
                }
            });

            _dialog.bind(InlineLayer.EVENTS.show, function(e, $layer) {
                var input = $layer.find(":input:not(submit):visible:first");
                input.focus();

                // List.js also resets the scrollTop but because the dialog is still hidden at that point, the browser won't actually do any scrolling.
                // @see JRADEV-15097
                $layer.find(".aui-list-scroll").scrollTop(0);
            });

            _dialog.bind(InlineLayer.EVENTS.beforeHide, function(e, layer, reason, id, originalTarget) {
                if (reason === AJSHideReason.clickOutside && originalTarget && jQuery(originalTarget).closest(".calendar").length) {
                    e.preventDefault();
                }
            });

            _dialog.bind(InlineLayer.EVENTS.hide, function(e, layer, reason) {
                var _searcher = _currentSearcher;

                if (_.contains(reasonsToFocusCriteria, reason)) {
                    findLozenge(_searcher).focus();
                }

                function doSearch() {
                    // A searcher has been submitted. Create a clause and add it to the clause collection
                    promise = _currentSearcher.createOrUpdateClauseWithQueryString(reason === AJSHideReason.submit);
                    promise.done(function() {
                        // Check for an "error" class in the searcher's editHtml.
                        // If so, leave the dialog open and rerender to the the updated editHtml.
                        // Otherwise close the dialog.
                        if (_searcher.hasErrorInEditHtml()) {
                            // Prevent displaying the error dialog if the mode has switched to advanced as a
                            // result of the click outside (i.e. on the Switch to Advanced link)
                            if (options.queryStateModel.getSearchMode() === "basic") {
                                module.instance.show(_searcher);
                            }
                        }

                        if (InlineLayer.current) {
                            // page layout might have changed as a result of updating a lozenge content (need to make sure dialog is in correct position)
                            InlineLayer.current.setPosition();
                        }
                    });

                    promise.always(function() {
                        promise = null;
                    });

                    _searcher.clearEditHtml();
                }

                if (reason === AJSHideReason.submit) {
                    // If this is a submit, always do de search
                    _currentView.applyFilter();
                    doSearch();
                } else if (reason !== AJSHideReason.cancelClicked && reason !== AJSHideReason.escPressed &&
                    reason !== AJSHideReason.tabbedOut) {
                    // If the dialog has not been cancelled, do the search only if the selector has not changed.
                    if (_currentView.applyFilter()) {
                        doSearch();
                    }
                } else {
                    trace("jira.search.searchers.hiddenWithoutUpdate");
                }

                _currentView.$el.remove();
                _currentView = null;
                _currentSearcher = null;
            });

            /**
             * JRADEV-15697 - Ensure all the dialog is closed when we switch search modes.
             */
            options.queryStateModel.on("change:searchMode", function() {
                _dialog.hide();
            });

            return {
                /**
                 * @return {SearcherModel} the searcher for which the dialog was last shown.
                 */
                getCurrentSearcher: function() {
                    return _currentSearcher;
                },

                /**
                 * Hide and show dialog
                 */
                toggle: function(searcher) {
                    if (_currentSearcher != null) {
                        if (_currentSearcher !== searcher) {
                            _dialog.hide(AJSHideReason.switchLozenge);
                            this.show(searcher);
                        } else {
                            _dialog.hide(AJSHideReason.toggle);
                        }
                    } else {
                        this.show(searcher);
                    }
                },

                _show: function(searcher) {
                    _.defer(function() {
                        _currentSearcher = searcher;
                        _dialog.show();
                        _dialog.setPosition();
                    });
                },

                /**
                 * shows dialog with correct searcher
                 * @param {JIRA.Issues.SearcherModel} searcher
                 */
                show: function(searcher) {
                    var waitingToShow;
                    if (module.waitingToShow) {
                        waitingToShow = true;
                    }

                    var instance = this;
                    module.waitingToShow = function() {
                        instance._show(searcher);
                        module.waitingToShow = null;
                    };

                    if (!waitingToShow) {
                        // Defer showing until all searchers are ready.
                        searcher.searchersReady().done(function() {
                            if (promise) {
                                promise.done(function() {
                                    module.waitingToShow();
                                });
                            } else {
                                module.waitingToShow();
                            }
                        });
                    }
                },

                /**
                 * Bind a handler to be called when the dialog is shown.
                 *
                 * @param handler The function to call when the dialog is shown.
                 */
                onShow: function(handler) {
                    _dialog.bind(InlineLayer.EVENTS.show, handler);
                },

                /**
                 * Hide the current dialog. Drrrrr!
                 */
                hide: function() {
                    _dialog.hide();
                },

                /**
                 * Bind a handler to be called when the dialog is hidden.
                 *
                 * @param handler The function to call when the dialog is hidden.
                 */
                onHide: function(handler) {
                    _dialog.bind(InlineLayer.EVENTS.hide, handler);
                }
            };
        }
    }();

    return module;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query-jql.soy' */
// This file was automatically generated from query-jql.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQueryJql.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQueryJql == 'undefined') { JIRA.Templates.IssueNavQueryJql = {}; }


JIRA.Templates.IssueNavQueryJql.jqlQueryView = function(opt_data, opt_ignored) {
  return '<div class="search-field-container"><div class="atlassian-autocomplete"><label for="advanced-search"><span id="jqlerrormsg" class="icon jqlgood"><span>' + soy.$$escapeHtml("parse") + '</span></span> <span class="jql-label">' + soy.$$escapeHtml("Query") + ' <span id="jqlcolrowcount">' + soy.$$escapeHtml("line") + ':<span id="jqlrownum">0</span>' + soy.$$escapeHtml("character") + ':<span id="jqlcolumnnum">0</span></span></span></label><textarea id="advanced-search" class="search-entry advanced-search ajs-dirty-warning-exempt" name="jql"></textarea><a class="syntax-help" href="' + soy.$$escapeHtml(opt_data.helpUrl) + '" title="' + soy.$$escapeHtml("Syntax Help") + '" target="_jirahelp" tabindex="-1"><span class="aui-icon aui-icon-small aui-iconfont-help">' + soy.$$escapeHtml("Syntax Help") + '</span></a></div></div><div class="search-options-container">' + ((opt_data.hasSearchButton) ? '<button class="aui-item aui-button aui-button-subtle search-button" type="button" title="' + soy.$$escapeHtml("Search for issues") + '"><span class="aui-icon aui-icon-small aui-iconfont-search">' + soy.$$escapeHtml("Search") + '</span></button>' : '') + '<span class="mode-switcher"></span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQueryJql.jqlQueryView.soyTemplateName = 'JIRA.Templates.IssueNavQueryJql.jqlQueryView';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlAutoCompleteView.js' */
define("jira/components/query/jql/jqlautocompleteview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var JQLParser = require("jira/jql/jql-parser");
    var JQLAutoComplete = require("jira/autocomplete/jql-autocomplete");
    var contextPath = AJS.contextPath();

    return Brace.View.extend({

        namedEvents: ["jqlValid", "jqlInvalid", "searchRequested"],

        events: {
            "focus": "_onFocus"
        },

        getJqlAutoCompleteData: function() {
            var deferred = new jQuery.Deferred();
            if (this.jqlFieldNames == null || this.jqlFunctionNames == null || this.jqlReservedWords == null) {
                var $jqlFieldNames = jQuery("#jqlFieldz");
                var $jqlFunctionNames = jQuery("#jqlFunctionNamez");
                var $jqlReservedWords = jQuery("#jqlReservedWordz");
                if ($jqlFieldNames.length > 0 && $jqlFunctionNames.length > 0 && $jqlReservedWords.length > 0) {
                    this.jqlFieldNames = JSON.parse($jqlFieldNames.text());
                    this.jqlFunctionNames = JSON.parse($jqlFunctionNames.text());
                    this.jqlReservedWords = JSON.parse($jqlReservedWords.text());
                } else {
                    jQuery.ajax({
                        url: contextPath + "/rest/querycomponent/latest/jqlAutoComplete"
                    }).done(_.bind(function(response) {
                        var jqlAutoCompleteData = JSON.parse(response);
                        this.jqlFieldNames = _.reject(JSON.parse(jqlAutoCompleteData.jqlFieldz), _.bind(function(item) {
                            return _.contains(this.model.getWithout(), item.value);
                        }, this));
                        this.jqlFunctionNames = JSON.parse(jqlAutoCompleteData.jqlFunctionNamez);
                        this.jqlReservedWords = JSON.parse(jqlAutoCompleteData.jqlReservedWordz);
                        deferred.resolve();
                    }, this));
                    return deferred.promise();
                }
            }
            return deferred.resolve().promise();
        },

        _initJQLAutoComplete: function() {
            var $advSearch = this.$el;
            var jqlAutoComplete = new JQLAutoComplete({
                fieldID: $advSearch.attr("id"),
                parser: new JQLParser(this.jqlReservedWords),
                queryDelay: 0.65,
                jqlFieldNames: this.jqlFieldNames,
                jqlFunctionNames: this.jqlFunctionNames,
                minQueryLength: 0,
                allowArrowCarousel: true,
                autoSelectFirst: false,
                errorID: 'jqlerrormsg'
            });

            var instance = this;

            $advSearch.keypress(function(event) {
                if (jqlAutoComplete.dropdownController === null || !jqlAutoComplete.dropdownController.displayed || jqlAutoComplete.selectedIndex < 0) {
                    if (event.keyCode === 13 && !event.ctrlKey && !event.shiftKey) {
                        event.preventDefault();
                        jqlAutoComplete.dropdownController.hideDropdown();
                        // Dodgy but the JQL auto complete has stopped propagation of the keypress event. And we need to let
                        // the query module know a search has been requested.
                        instance.triggerSearchRequested($advSearch.val());
                    }
                }
            });

            var oldUpdateParseIndicator = jqlAutoComplete.updateParseIndicator;
            jqlAutoComplete.updateParseIndicator = function(token) {
                oldUpdateParseIndicator.apply(this, arguments);
                if (!token.getParseError()) {
                    instance.triggerJqlValid($advSearch.val());
                } else {
                    instance.triggerJqlInvalid($advSearch.val());
                }
            };

            jqlAutoComplete.buildResponseContainer();
            jqlAutoComplete.parse($advSearch.val());
            jqlAutoComplete.updateColumnLineCount();

            $advSearch.bind('expandedOnInput', function() {
                jqlAutoComplete.positionResponseContainer();
            }).bind("updateParseIndicator", function() {
                jqlAutoComplete.parse($advSearch.val());
            }).click(function() {
                jqlAutoComplete.dropdownController.hideDropdown();
            });
        },

        _onFocus: function() {
            // The renderer may destroy the old <textarea> and insert a new one, so we'll need to
            // init JQL autocompletion anytime this property is not set.
            if (!this.model.getAutocompleteEnabled() || this.$el.data("JQLAutoComplete_init")) {
                return;
            }
            this.$el.data("JQLAutoComplete_init", true);
            this.getJqlAutoCompleteData().done(_.bind(this._initJQLAutoComplete, this));
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlQueryModule.js' */
define("jira/components/query/jql/jqlquerymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var JqlQueryView = require("jira/components/query/jql/jqlqueryview");
    var Events = require("jira/util/events");
    var Types = require("jira/util/events/types");
    var Reasons = require("jira/util/events/reasons");

    /**
     * Module for JQL query mode
     */
    return Brace.Evented.extend({

        namedEvents: ["searchRequested", "verticalResize", "searchChanged"],

        initialize: function(options) {

            this._queryStateModel = options.queryStateModel;
            this.view = new JqlQueryView({
                queryStateModel: options.queryStateModel
            })
                .onVerticalResize(this.triggerVerticalResize, this)
                .onSearchRequested(this.triggerSearchRequested, this)
                .onSearchChanged(this.triggerSearchChanged, this);

            /* Absolute hack to prevent DESK-1623 - after return to search, the jql box is thin cause issue nav is hidden when
             rendered so height calculation is wrong. We need to trigger it to recalculate height on return to search.
             I have added a method, refreshLayout to the query component which we now call from issue-nav-plugin
             SearchPageModule, however jira can be using a newer version of issue-nav-components that issue-nav-plugin
             (installed via service desk). So we need this nasty hack until the minimum version of jira service desk
             supports has the updateLayout call inside of SearchPageModule.
             */
            Events.bind(Types.NEW_CONTENT_ADDED, _.bind(function(e, el, reason) {
                if (reason === Reasons.returnToSearch) {
                    this.setQuery();
                }
            }, this));
        },

        search: function() {
            var jql = this.view.readJql();
            this.triggerSearchRequested(jql);
        },

        setQuery: function() {
            this.view.setQuery();
        },

        createView: function() {
            return this.view;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/jql/JqlQueryView.js' */
define("jira/components/query/jql/jqlqueryview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var IssueNavQueryJql = require("jira/components/query/templates/issuenavqueryjql");
    var JQLAutoCompleteView = require("jira/components/query/jql/jqlautocompleteview");
    var Meta = require("jira/util/data/meta");
    var Tipsy = require("jira/issues/tipsy");

    /**
     * Renders the JQL textarea.
     */
    return Brace.View.extend({
        template: IssueNavQueryJql.jqlQueryView,

        namedEvents: ["verticalResize", "searchRequested", "searchChanged"],

        events: {
            "expandedOnInput": "_handleExpandOnInput",
            "input": function() {
                this.trigger("searchChanged", {
                    newJql: this.readRawJql()
                });
            }
        },

        initialize: function(options) {
            this.queryStateModel = options.queryStateModel;
            this.queryStateModel.on("change:jql", this.setQuery, this);
            jQuery(document).bind('issueNavWidthChanged', _.bind(this._resizeHeight, this));

            if (JQLAutoCompleteView) {
                this.JQLAutoCompleteView = new JQLAutoCompleteView({model: this.queryStateModel});
                this.JQLAutoCompleteView.onJqlValid(function(jql) {
                    if (this.queryStateModel.getAdvancedAutoUpdate()) {
                        this.triggerSearchRequested(jql);
                    }
                }, this);
                this.JQLAutoCompleteView.onSearchRequested(this.triggerSearchRequested, this);
            }
        },

        render: function() {

            this.$el.html(this.template({
                helpUrl: Meta.get('advanced-search-help-url'),
                helpTitle: Meta.get('advanced-search-help-title'),
                hasSearchButton: this.queryStateModel.hasSearchButton()
            }));

            this.$el.addClass("loading");

            if (this.JQLAutoCompleteView) {
                this.JQLAutoCompleteView.setElement(this.$el.find(".advanced-search"));
                this.JQLAutoCompleteView.getJqlAutoCompleteData();
            }

            new Tipsy({
                el: this.$el.find(".search-button"),
                tipsy: {
                    trigger: "hover",
                    delayIn: 300
                }
            });

            this.setQuery();
            return this;
        },

        /**
         * Gets the JQL from the input field.
         *
         * The difference with readJQL() is that this method has no
         * side effects, it just returns the JQL as-is.
         *
         * @returns {string} The JQL, or empyt string if the JQL is empty
         */
        readRawJql: function() {
            var $inputField = this._getInputField();
            return $inputField.val() || "";
        },

        /**
         * Sanizites the JQL from the input field and returns it.
         *
         * Note: this function have a few side effects:
         *      * It trims the JQL
         *      * It changes the field to the trimmed JQL
         *      * It changes the height of the field
         *
         * @returns {string} the JQL
         */
        readJql: function() {
            var jql = this.readRawJql();
            var $inputField = this._getInputField();

            // Prettify input field with trimmed JQL
            var trimmedJql = jQuery.trim(jql);
            if (jql !== trimmedJql) {
                $inputField.val(trimmedJql);
            }
            this._resizeHeight();
            return trimmedJql;
        },

        _handleExpandOnInput: function() {
            this.triggerVerticalResize();
        },

        _resizeHeight: function() {
            var $input = this._getInputField();
            // Need to set the height of the input to 0 for expandOnInput to reliably expand.
            // However, expandOnInput doesn't change the height of empty inputs, so need to handle those a little differently.
            if ($input.val()) {
                $input.height(0).expandOnInput();
            } else {
                $input.expandOnInput().height(0).trigger('refreshInputHeight');
            }

        },

        setQuery: function() {
            this.$el.removeClass("loading"); // Just in case we have come here from basic, loading class might be persisted. So remove.
            this._getInputField().val(this.queryStateModel.getJql());
            this._getInputField().trigger("updateParseIndicator");
            this._resizeHeight();
        },

        focus: function() {
            this._getInputField().focus();
        },

        _getInputField: function() {
            return this.$el ? this.$el.find("textarea") : jQuery();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/query.soy' */
// This file was automatically generated from query.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.IssueNavQuery.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.IssueNavQuery == 'undefined') { JIRA.Templates.IssueNavQuery = {}; }


JIRA.Templates.IssueNavQuery.searchSwitcher = function(opt_data, opt_ignored) {
  var output = '';
  var itemList3 = opt_data.items;
  var itemListLen3 = itemList3.length;
  for (var itemIndex3 = 0; itemIndex3 < itemListLen3; itemIndex3++) {
    var itemData3 = itemList3[itemIndex3];
    output += JIRA.Templates.IssueNavQuery.searchSwitcherItem({id: itemData3.id, isActive: itemData3.id == opt_data.selectedId});
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.searchSwitcher.soyTemplateName = 'JIRA.Templates.IssueNavQuery.searchSwitcher';
}


JIRA.Templates.IssueNavQuery.searchSwitcherItem = function(opt_data, opt_ignored) {
  return '<a href="#" class="switcher-item' + soy.$$escapeHtml(opt_data.isActive ? ' active' : '') + ' " data-id=\'' + soy.$$escapeHtml(opt_data.id) + '\' title="' + ((opt_data.id == 'basic') ? soy.$$escapeHtml("Switch to advanced search using JQL") : soy.$$escapeHtml("Switch to basic search")) + '">' + ((opt_data.id == 'basic') ? soy.$$escapeHtml("Advanced") : soy.$$escapeHtml("Basic")) + '</a>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.searchSwitcherItem.soyTemplateName = 'JIRA.Templates.IssueNavQuery.searchSwitcherItem';
}


JIRA.Templates.IssueNavQuery.queryView = function(opt_data, opt_ignored) {
  return '<div class="aui-group"><div class="aui-item search-wrap"><div class="search-container"></div><div class="save-filter-controls"></div></div>' + ((opt_data.layoutSwitcher) ? '<div class="aui-item view-selector" id="layout-switcher-toggle"></div>' : '') + '</div><div class="notifications"></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.IssueNavQuery.queryView.soyTemplateName = 'JIRA.Templates.IssueNavQuery.queryView';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryModule.js' */
define("jira/components/query/querymodule", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var QueryView = require("jira/components/query/queryview");
    var SearcherDialog = require("jira/components/query/basic/searcherdialog");
    var BasicQueryModule = require("jira/components/query/basic/basicquerymodule");
    var JqlQueryModule = require("jira/components/query/jql/jqlquerymodule");

    /**
     * Module for basic query mode
     */
    return Brace.Evented.extend({

        namedEvents: [
            "jqlChanged",
            "jqlTooComplex",
            "jqlError",
            "jqlSuccess",
            "searchRequested",
            "searchChanged",
            "queryTooComplexSwitchToAdvanced",
            "changedPreferredSearchMode",
            "basicModeCriteriaCountWhenSearching",
            "verticalResize",
            "initialized"
        ],

        initialize: function(options) {
            this._queryStateModel = options.queryStateModel;
            this._queryStateModel.on("change:preferredSearchMode", _.bind(function() {
                this.triggerChangedPreferredSearchMode(this._queryStateModel.getPreferredSearchMode());
            }, this));

            SearcherDialog.initialize({
                queryStateModel: this._queryStateModel
            });
            this._jqlQueryModule = new JqlQueryModule({
                queryStateModel: this._queryStateModel
            })
            .onSearchRequested(this.handleAdvancedSearchRequested, this)
            .onVerticalResize(this.triggerVerticalResize, this)
            .onSearchChanged(this.triggerSearchChanged, this);

            this._errors = {};
            this._errors[this._queryStateModel.BASIC_SEARCH] = [];
            this._errors[this._queryStateModel.ADVANCED_SEARCH] = [];

            this._queryStateModel.on("change:searchMode", this.showSearchErrors, this);

            this._basicQueryModule = new BasicQueryModule({
                queryStateModel: this._queryStateModel,
                primaryClauses: options.primaryClauses,
                initialSearcherCollectionState: options.searchers,
                context: options.context
            })
                .onSearchRequested(this.clearSearchErrors, this)
                .onJqlTooComplex(this.handleJqlTooComplex, this)
                .onSearchRequested(this.handleSearchRequested, this)
                .onVerticalResize(this.triggerVerticalResize, this)
                .onBasicModeCriteriaCountWhenSearching(this.triggerBasicModeCriteriaCountWhenSearching, this);
        },

        // If we have rendered in the background (when hidden), our size calculations for jql box are incorrect so we need
        // away for the outside world to tell us to recalculate.
        refreshLayout: function() {
            this._jqlQueryModule.setQuery();
        },

        handleAdvancedSearchRequested: function(jql) {
            this.handleSearchRequested(jql);
            this._basicQueryModule.queryChanged();
        },

        handleSearchRequested: function(jql) {
            this._queryStateModel.setJql(jql);
            this.clearSearchErrors();
        },

        handleJqlTooComplex: function(jql) {
            if (this.getSearchMode() !== this._queryStateModel.ADVANCED_SEARCH) {
                this.triggerQueryTooComplexSwitchToAdvanced();
            }
            this.setSearchMode(this._queryStateModel.ADVANCED_SEARCH);
            this.triggerJqlTooComplex(jql);
            if (this._queryView) {
                this._queryView.switcherViewModel.disableSwitching();
            }
        },

        getJql: function() {
            return this._queryStateModel.getJql();
        },

        getSearcherCollection: function() {
            return this._basicQueryModule.searcherCollection;
        },

        /**
         * @return {boolean} whether the query module is currently in basic mode.
         * @private
         */
        isBasicMode: function() {
            return this._queryStateModel.getSearchMode() === this._queryStateModel.BASIC_SEARCH;
        },

        /**
         * Reset the query module to match the current query.
         *
         * Clears error messages, switches to the user's preferred search mode, and
         * hides the entire query view if the currently selected filter is invalid.
         *
         * If the user has requested a new search then this method will focus the search view.
         *
         * @param jql
         * @param options
         * @param options.focusQuery true if we should focus the searchers after resetting
         */
        resetToQuery: function(jql, options) {
            this.clearSearchErrors();
            return this._basicQueryModule.queryReset(jql).always(_.bind(function() {
                this._queryStateModel.switchToPreferredSearchMode();
                this._jqlQueryModule.setQuery();
                if (options && options.focusQuery === true) {
                    this._queryView.getView().focus();
                }

                this._basicQueryModule.off("searchRequested", this.publishJqlChanges);
                this._jqlQueryModule.off("searchRequested", this.publishJqlChanges);

                // subsequent search requestes are published
                this._basicQueryModule.onSearchRequested(this.publishJqlChanges, this);
                this._jqlQueryModule.onSearchRequested(this.publishJqlChanges, this);
            }, this));
        },

        publishJqlChanges: function(jql) {
            this.triggerJqlChanged(jql);
        },

        setVisible: function(value) {
            this._queryView.setVisible(value);
        },

        /**
         * Notifies this module that the underlying jql has changed and it should update itself
         */
        queryChanged: function() {
            this.clearSearchErrors();
            this._basicQueryModule.queryChanged();
        },

        onSearchSuccess: function(warnings) {
            if (this._queryView) {
                this._queryView.showWarnings(warnings);
            }
            this.triggerJqlSuccess();
        },

        /**
         * Wait any in flight updates to search collection.
         */
        searchersReady: function() {
            return this._basicQueryModule.searchersReady();
        },

        onSearchError: function(response) {
            this._errors.renderFunction = "showErrors";
            var basicModeErrors = (response.errorMessages) ? response.errorMessages.concat() : [];
            var advancedModeErrors = [];

            _.each(response.errors, function(message, type) {
                if (type === "jql") {
                    advancedModeErrors.push(message);
                } else {
                    basicModeErrors.push(message);
                }
            });

            if (this.getSearchMode() === this._queryStateModel.BASIC_SEARCH && !this._basicQueryModule.hasErrors() && advancedModeErrors.length > 0) {
                // If the search was performed in basic mode, an advanced mode error was
                // encountered, switch to advanced mode before rendering these errors.
                this.setSearchMode(this._queryStateModel.ADVANCED_SEARCH);
            }

            this._errors[this._queryStateModel.BASIC_SEARCH] = basicModeErrors;
            this._errors[this._queryStateModel.ADVANCED_SEARCH] = advancedModeErrors.concat(basicModeErrors);

            this.showSearchErrors();
            this.triggerJqlError();
        },

        /**
         * Show error messages applicable to the current search mode.
         */
        showSearchErrors: function() {
            if (this._queryView) {
                this._queryView.clearNotifications();
                var renderFunction = this._errors.renderFunction || "showErrors";
                this._queryView[renderFunction](this._errors[this.getSearchMode()]);
            }
        },

        /**
         * Remove error messages from all search modes.
         */
        clearSearchErrors: function() {
            if (this._queryView) {
                this._queryView.clearNotifications();
                this._queryView.switcherViewModel.enableSwitching();
            }
            this._errors[this._queryStateModel.BASIC_SEARCH].length = 0;
            this._errors[this._queryStateModel.ADVANCED_SEARCH].length = 0;
        },

        getSearchMode: function() {
            return this._queryStateModel.getSearchMode();
        },

        getActiveBasicModeSearchers: function() {
            return this._basicQueryModule.getSelectedCriteria();
        },

        /**
         * @param {string} searchMode -- Either "basic" or "advanced"
         * @return {boolean} -- Indicates whether or not the search mode actually changed
         */
        setSearchMode: function(searchMode) {
            if (this.getSearchMode() !== searchMode) {
                this._queryStateModel.switchToSearchMode(searchMode);
                return true;
            }
            return false;
        },

        createAndRenderView: function($el) {
            this._queryView = new QueryView({
                el: $el,
                queryStateModel: this._queryStateModel,
                basicQueryModule: this._basicQueryModule,
                jqlQueryModule: this._jqlQueryModule
            }).onVerticalResize(this.triggerVerticalResize, this);
            this._queryView.render();
        },

        isQueryValid: function() {
            return (this._errors &&
            this._errors[this._queryStateModel.BASIC_SEARCH].length === 0 &&
            this._errors[this._queryStateModel.ADVANCED_SEARCH].length === 0);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryStateModel.js' */
define("jira/components/query/querystatemodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var displayFailSearchMessage = JIRA.Issues.displayFailSearchMessage;
    var contextPath = AJS.contextPath();
    var jQuery = require("jquery");

    function trace() {
        return JIRA.trace.apply(JIRA, arguments);
    }

    /**
     * Represents current and preferred search modes (basic or jql)
     */
    return Brace.Model.extend({

        BASIC_SEARCH: "basic",
        ADVANCED_SEARCH: "advanced",

        namedAttributes: [
            "style",
            "searchMode",
            "preferredSearchMode",
            "jql",
            "without",
            "layoutSwitcher",
            "autocompleteEnabled",
            "advancedAutoUpdate",
            "basicAutoUpdate",
            "basicOrderBy"
        ],

        defaults: {
            searchMode: "basic",
            preferredSearchMode: "basic"
        },

        /**
         * Sets search mode
         * @param searchMode search mode (basic or advanced)
         */
        switchToSearchMode: function(searchMode) {
            this.setSearchMode(searchMode);
        },

        /**
         * Changes the preferred and actual search mode and saves the preferred search mode.
         */
        switchPreferredSearchMode: function(mode) {
            this.switchToSearchMode(mode);
            this.setPreferredSearchMode(mode);
            this._savePreferredSearchMode();
        },

        /**
         * Switches to whatever is the preferred search mode
         */
        switchToPreferredSearchMode: function() {
            this.switchToSearchMode(this.getPreferredSearchMode());
        },

        hasSearchButton: function() {
            return this.getStyle() !== "field";
        },

        /**
         * Should the more criteria button be subtly styled
         */
        hasSubtleMoreCriteria: function() {
            return this.getStyle() !== "field";
        },

        /**
         * Persists preferred search mode to the server
         */
        _savePreferredSearchMode: function() {
            jQuery.ajax({
                url: contextPath + "/rest/querycomponent/latest/userSearchMode", // IssueTableResource (JIRA core)
                type: 'POST',
                headers: {
                    "X-Atlassian-Token": "no-check"
                },
                data: {
                    searchMode: this.getPreferredSearchMode()
                },
                error: _.bind(function(xhr) {
                    if (displayFailSearchMessage) {
                        displayFailSearchMessage(xhr);
                    }
                }, this),
                success: function() {
                    trace("jira.search.mode.changed");
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherModel.js' */
define("jira/components/query/switchermodel", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");

    return Brace.Model.extend({

        /**
         * id: id of the switcher
         * name: switcher name (displayed in switcher view)
         * view: backbone view object
         */
        namedAttributes: ["id", "name", "view", "text"]

    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherCollection.js' */
define("jira/components/query/switchercollection", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var SwitcherModel = require("jira/components/query/switchermodel");

    return Brace.Collection.extend({
        model: SwitcherModel
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QuerySwitcherViewModel.js' */
define("jira/components/query/queryswitcherviewmodel", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var Brace = require("jira/components/libs/brace");
    var SingleSelect = require("jira/components/query/mixin/singleselect");

    /**
     * Model that represents a switcher collection with a selection for the switcher in the query view
     */
    return Brace.Model.extend({

        mixins: [SingleSelect],

        namedAttributes: ["disabled"],

        namedEvents: ["selectionChanged"],

        initialize: function(attributes, options) {
            this.queryStateModel = options.queryStateModel;
            this.queryStateModel.on("change:searchMode", _.bind(function() {
                this.triggerSelectionChanged.apply(this, arguments);
            }, this));
        },

        getSelected: function() {
            var id = this.queryStateModel.getSearchMode();
            return id ? this.getCollection().get(id) : null;
        },

        setSelected: function(selected) {
            this.queryStateModel.switchPreferredSearchMode(selected ? selected.id : null);
        },

        enableSwitching: function() {
            this.setDisabled(false);
        },

        disableSwitching: function() {
            this.setDisabled(true);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/QueryView.js' */
define("jira/components/query/queryview", ["require"], function(require) {
    "use strict";

    var Brace = require("jira/components/libs/brace");
    var IssueNavQuery = require("jira/components/query/templates/issuenavquery");
    var SwitcherCollection = require("jira/components/query/switchercollection");
    var SwitcherView = require("jira/components/query/switcherview");
    var QuerySwitcherViewModel = require("jira/components/query/queryswitcherviewmodel");
    var ComponentUtilTemplate = require("jira/components/query/templates/issues/componentutil");

    /**
     * This renders the container for either the basic query view or the advanced query view.
     *
     * @see JIRA.Issues.JqlQueryView
     * @see JIRA.Issues.BasicQueryView
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        template: IssueNavQuery.queryView,

        events: {
            "click .search-button": "search",
            "submit": "preventDefault"
        },

        initialize: function(options) {
            this.queryStateModel = options.queryStateModel;

            var switcherCollection = new SwitcherCollection([
                {
                    id: this.queryStateModel.BASIC_SEARCH,
                    name: "Basic",
                    view: options.basicQueryModule.createView()
                }, {
                    id: this.queryStateModel.ADVANCED_SEARCH,
                    name: "Advanced",
                    view: options.jqlQueryModule.createView()
                }
            ]);

            // TODO: hack for search() below, to fix
            this.jqlQueryModule = options.jqlQueryModule;

            this.switcherViewModel = new QuerySwitcherViewModel({
                collection: switcherCollection
            }, {
                queryStateModel: this.queryStateModel
            });

            this.switcherView = new SwitcherView({
                template: IssueNavQuery.searchSwitcher,
                model: this.switcherViewModel,
                containerClass: ".search-container"
            }).onVerticalResize(this.triggerVerticalResize, this);

        },

        render: function() {
            this.$el.html(this.template(this.queryStateModel.toJSON()));
            this.switcherView.setElement(this.$el).render();
            return this;
        },

        preventDefault: function(e) {
            e.preventDefault();
        },

        /**
         * Clear the notifications area (errors and warnings).
         */
        clearNotifications: function() {
            this.$(".notifications").empty();
        },

        /**
         * Performs a search with a query defined by the value of the textarea.
         *
         * This calls search on the model, only if we don't have an active saved search,
         * or if the query was changed from the current active saved search.
         *
         */
        search: function() {
            // TODO: temp hack for jql query view rework
            if (this.queryStateModel.ADVANCED_SEARCH === this.switcherViewModel.getSelected().getId()) {
                this.jqlQueryModule.search();
            }
            else {
                this.getView().search();
            }
        },

        getView: function() {
            return this.switcherViewModel.getSelected().getView();
        },

        /**
         * Display one or more errors in the notification area.
         *
         * @param {Array} errors The error(s) to be displayed.
         */
        showErrors: function(errors) {
            this.$(".notifications").append(ComponentUtilTemplate.errorMessage({messages: errors}));
        },

        /**
         * Display one or more warnings in the notification area.
         *
         * @param {Array} warnings The warning(s) to be displayed.
         */
        showWarnings: function(warnings) {
            this.$(".notifications").append(ComponentUtilTemplate.warningMessage({messages: warnings}));
        },

        /**
         * Hide or show the view (excluding error messages).
         *
         * @param isVisible Whether the view should be visible.
         */
        setVisible: function(isVisible) {
            this.$(".search-container").toggleClass('hidden', !isVisible);
            this.switcherView.setVisible(isVisible);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/SwitcherView.js' */
define("jira/components/query/switcherview", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var Brace = require("jira/components/libs/brace");
    var Tipsy = require("jira/issues/tipsy");

    /**
     * View that allows switching between querying modes
     */
    return Brace.View.extend({

        namedEvents: ["verticalResize"],

        tagName: "div",

        events: {
            "click .switcher-item": "_onSwitcherClick"
        },

        initialize: function(options) {
            this.containerClass = options.containerClass;
            this.model = options.model;
            this.template = options.template;
            this.model.onSelectionChanged(this._onSelect, this);
            this.switchEl = jQuery();
            this.model.on("change:disabled", _.bind(this._setSwitching, this));
        },

        /**
         * Render the switcher and the currently selected item.
         */
        render: function() {
            this._onSelect();
            this._render();
        },

        /**
         * Render the switcher.
         *
         * @private
         */
        _render: function() {
            var selected = this.model.getSelected();

            this.switchEl = this.$el.find(".mode-switcher");
            this.switchEl.html(this.template({
                items: this.model.getCollection().toJSON(),
                selectedId: selected && selected.id
            }));

            new Tipsy({
                el: this.$el.find(".switcher-item.active")
            });
        },

        getSwitcherTrigger: function() {
            return this.switchEl.find('.switcher-item.active');
        },

        _onSelect: function() {
            var container = this.$el.find(this.containerClass).empty();
            var selected = this.model.getSelected();
            if (selected) {
                container.attr("data-mode", selected.id);
                selected.getView().setElement(container).render();
            }

            this._render();
            this.triggerVerticalResize();
        },

        _onSwitcherClick: function(event) {
            event.preventDefault();
            if (!this.model.getDisabled()) {
                this.model.next();

                var selectedView = this.model.getSelected().getView();
                if (selectedView.focus) {
                    selectedView.focus();
                }
            }
        },

        _setSwitching: function() {
            if (this.model.getDisabled()) {
                this.disableSwitching();
            } else {
                this.enableSwitching();
            }
        },

        disableSwitching: function() {
            this.switchEl.addClass("disabled");
            this.getSwitcherTrigger().attr("original-title", "This query is too complex to display in Simple mode.");
        },

        enableSwitching: function() {
            this.switchEl.removeClass("disabled");
            var selected = this.model.getSelected();
            //if we're currently in advanced mode and we're re-enabling the switcher we need to restore the original title to indicate
            //that the link allows you to switch back to basic mode.
            if (selected && selected.id === "advanced") {
                this.getSwitcherTrigger().attr("original-title", "Switch to basic search");
            }
        },

        /**
         * Hide or show the switcher trigger.
         *
         * @param isVisible Whether the switcher should be visible.
         */
        setVisible: function(isVisible) {
            this.switchEl.toggleClass("hidden", !isVisible);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/Query.js' */
define("jira/components/query", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var jQuery = require("jquery");
    var QueryModule = require("jira/components/query/querymodule");
    var QueryStateModel = require("jira/components/query/querystatemodel");

    return function() {

        var CLAUSES = {
            project: "Project",
            issuetype: "Type",
            status: "Status",
            assignee: "Assignee",
            reporter: "Reporter",
            labels: "Labels",
            resolution: "Resolution",
            created: "Created Date",
            updated: "Updated Date",
            resolutiondate: "Resolution Date",
            description: "Description",
            duedate: "Due Date",
            comment: "Comment",
            fixfor: "Fix Version",
            version: "Affects Version",
            component: "Component"
        };

        return {

            DEFAULT_CLAUSES: ["project", "issuetype", "status", "assignee"],

            create: function(options) {

                options = _.defaults(options, {
                    primaryClauses: this.DEFAULT_CLAUSES,
                    without: [],
                    style: "generic",
                    /* This has to be true :( - If issue-nav-components is anything below 6.2, the layoutSwitcher option
                     * didn't exist when it was first consumed in 6.1. */
                    layoutSwitcher: true,
                    autocompleteEnabled: true,
                    advancedAutoUpdate: false,
                    basicOrderBy: false,
                    basicAutoUpdate: true,
                    preferredSearchMode: "basic"
                });

                options.primaryClauses = _.reject(options.primaryClauses, function(clause) {
                    return _.contains(options.without, clause.id);
                });

                _.each(options.primaryClauses, function(clause, idx) {
                    if (typeof clause === "string") {
                        if (CLAUSES[clause]) {
                            options.primaryClauses[idx] = {id: clause, name: CLAUSES[clause]};
                        } else {
                            /*eslint-disable no-console */
                            console.error("jira/components/query: You have specified clause [" + clause + "]. " +
                            "But we do not have the i18n string for it, probably a custom field. Instead use {id:" + clause + ", name: '[NAME_HERE]'}");
                            /*eslint-enable no-console */
                        }
                    }
                });

                var queryModule = new QueryModule({
                    queryStateModel: new QueryStateModel({
                        jql: options.jql,
                        without: options.without,
                        style: options.style,
                        layoutSwitcher: options.layoutSwitcher,
                        autocompleteEnabled: options.autocompleteEnabled,
                        advancedAutoUpdate: options.advancedAutoUpdate,
                        basicAutoUpdate: options.basicAutoUpdate,
                        preferredSearchMode: options.preferredSearchMode,
                        basicOrderBy: options.basicOrderBy
                    }),
                    primaryClauses: options.primaryClauses,
                    searchers: options.searchers,
                    context: options.context
                });

                jQuery(options.el).addClass("query-component " + options.style + "-styled");

                queryModule.createAndRenderView(options.el);

                if (options.jql || options.jql === "") {
                    queryModule.resetToQuery(options.jql).always(function() {
                        jQuery(options.el).addClass("ready");
                        // Consumers of this component want to know when the jql (given at construction) is represented in the ui.
                        queryModule.triggerInitialized(options.jql);
                    });
                }
                return queryModule;
            }
        };
    }();
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/query/templates/issuenavquery", function() {
    "use strict";

    return JIRA.Templates.IssueNavQuery;
});

define("jira/components/query/templates/issuenavquerybasic", function() {
   "use strict";

    return JIRA.Templates.IssueNavQueryBasic;
});

define("jira/components/query/templates/issuenavqueryjql", function() {
    "use strict";

    return JIRA.Templates.IssueNavQueryJql;
});

define("jira/components/query/templates/issues/componentutil", function() {
   "use strict";

    return JIRA.Templates.Issues.ComponentUtil;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed. Later, we can restore the
 * global reference if needed (see ../namespace.js)
 */
AJS.namespace("JIRA.Templates.IssueNavQuery", null, require("jira/components/query/templates/issuenavquery"));
AJS.namespace("JIRA.Templates.IssueNavQueryBasic", null, require("jira/components/query/templates/issuenavquerybasic"));
AJS.namespace("JIRA.Templates.IssueNavQueryJql", null, require("jira/components/query/templates/issuenavqueryjql"));
AJS.namespace("JIRA.Templates.Issues.ComponentUtil", null, require("jira/components/query/templates/issues/componentutil"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:query', location = 'query/namespace.js' */
AJS.namespace("JIRA.Components.Query", null, require("jira/components/query"));

AJS.namespace("JIRA.Issues.QueryModule", null, require("jira/components/query/querymodule"));
AJS.namespace("JIRA.Issues.QueryStateModel", null, require("jira/components/query/querystatemodel"));
AJS.namespace("JIRA.Issues.QuerySwitcherViewModel", null, require("jira/components/query/queryswitcherviewmodel"));
AJS.namespace("JIRA.Issues.QueryView", null, require("jira/components/query/queryview"));
AJS.namespace("JIRA.Issues.SwitcherCollection", null, require("jira/components/query/switchercollection"));
AJS.namespace("JIRA.Issues.SwitcherModel", null, require("jira/components/query/switchermodel"));
AJS.namespace("JIRA.Issues.SwitcherView", null, require("jira/components/query/switcherview"));

AJS.namespace("JIRA.Issues.Mixin.SingleSelect", null, require("jira/components/query/mixin/singleselect"));

AJS.namespace("JIRA.Issues.JqlQueryModule", null, require("jira/components/query/jql/jqlquerymodule"));
AJS.namespace("JIRA.Issues.JqlQueryView", null, require("jira/components/query/jql/jqlqueryview"));
AJS.namespace("JIRA.Issues.JQLAutoCompleteView", null, require("jira/components/query/jql/jqlautocompleteview"));

AJS.namespace("JIRA.Issues.BasicQueryModule", null, require("jira/components/query/basic/basicquerymodule"));
AJS.namespace("JIRA.Issues.SearcherCollection", null, require("jira/components/query/basic/searchercollection"));
AJS.namespace("JIRA.Issues.SearcherDialog", null, require("jira/components/query/basic/searcherdialog"));
AJS.namespace("JIRA.Issues.SearcherModel", null, require("jira/components/query/basic/searchermodel"));
AJS.namespace("JIRA.Issues.BasicQueryView", null, require("jira/components/query/basic/basicqueryview"));
AJS.namespace("JIRA.Issues.CardView", null, require("jira/components/query/basic/cardview"));
AJS.namespace("JIRA.Issues.ClauseButtonView", null, require("jira/components/query/basic/clausebuttonview"));
AJS.namespace("JIRA.Issues.ClauseListDialogView", null, require("jira/components/query/basic/clauselistdialogview"));
AJS.namespace("JIRA.Issues.CriteriaModel", null, require("jira/components/query/basic/criteriamodel"));
AJS.namespace("JIRA.Issues.CriteriaView", null, require("jira/components/query/basic/criteriaview"));
AJS.namespace("JIRA.Issues.ExtendedCriteriaContainerView", null, require("jira/components/query/basic/extendedcriteriacontainerview"));
AJS.namespace("JIRA.Issues.PrimaryCriteriaContainerView", null, require("jira/components/query/basic/primarycriteriacontainerview"));
AJS.namespace("JIRA.Issues.SearcherEditDialogView", null, require("jira/components/query/basic/searchereditdialogview"));
AJS.namespace("JIRA.Issues.SearcherGroupListDialogView", null, require("jira/components/query/basic/searchergrouplistdialogview"));
AJS.namespace("JIRA.Issues.TextFieldView", null, "jira/components/query/basic/textfieldview");
AJS.namespace("JIRA.Issues.TextQueryBuilder", null, "jira/components/query/basic/textquerybuilder");
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-query', location = 'content/js/search/query/SearchShifter.js' */
(function() {
    "use strict";

    /**
     * Creates a shifter group factory for search criteria.
     *
     * @param {object} options
     * @param {function} options.isBasicMode A function that returns true iff basic mode is selected.
     * @param {function} options.isFullScreenIssue A function that returns true iff a full screen issue is visible.
     * @param {JIRA.Issues.SearcherCollection} options.searcherCollection The application's searcher collection.
     * @return {function} A shifter group factory suitable to be passed to <tt>JIRA.Shifter.register</tt>.
     */
    JIRA.Issues.SearchShifter = function(options) {
        var getSuggestions;
        var onSelection;
        var shouldShow;
        var toSuggestion;

        getSuggestions = function() {
            var suggestions = options.searcherCollection.chain()
                .filter(shouldShow)
                .map(toSuggestion)
                .value();

            return function() {
                return new jQuery.Deferred().resolve(suggestions).promise();
            };
        };

        onSelection = function(id) {
            var currentSearcher = JIRA.Issues.SearcherDialog.instance.getCurrentSearcher();
            var searcher = options.searcherCollection.get(id);

            if (!searcher.getIsSelected()) {
                searcher.select();
            }

            // toggle closes the dialog if it's open, so ensure that's not the case.
            if (!currentSearcher || currentSearcher.getId() !== searcher.getId()) {
                JIRA.Issues.SearcherDialog.instance.toggle(searcher);
            }
        };

        // Determine whether the given searcher should be suggested.
        shouldShow = function(searcherModel) {
            return searcherModel.getIsShown();
        };

        // Create a shifter suggestion from a SearcherModel.
        toSuggestion = function(searcherModel) {
            return {
                label: searcherModel.getName(),
                value: searcherModel.getId()
            };
        };

        return function() {
            // Only show suggestions if we're in basic mode and the search criteria are visible.
            if (!options.isBasicMode() || options.isFullScreenIssue()) {
                return null;
            }

            return {
                getSuggestions: getSuggestions(),
                name: "Search Criteria",
                onSelection: onSelection,
                weight: 150
            };
        };
    };

}());
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:marionette-2.1.0', location = 'libs/marionette-2.1.0.js' */
define("jira/components/libs/marionette-2.1.0", [
    "atlassian/libs/factories/marionette-2.1.0",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    marionetteFactory,
    Backbone,
    _
) {
    "use strict";
    var Marionette = marionetteFactory(_, Backbone);

    /**
     * Triggers a preventable event.
     *
     * The event will include an EventObject, and the handler can call eventObject.preventDefault() to prevent the event.
     *
     * @param {string} eventName Name of the event being triggered.
     * @param {EventObject} [eventObject] EventObject used as template to construct the actual EventObject used in the event.
     *
     * @returns {EventObject} EventObject passed to the event.
     */
    function triggerPreventable(eventName, eventObject) {
        /**
         * EventObject passed to preventable events
         * @typedef {Object} EventObject
         * @property {Object} emitter Original emitter of the event.
         * @property {boolean} isPrevented Whether the event has been prevented by the event handler.
         * @property {Function} preventDefault Syntax sugar for set the `isPrevented` value.
         */
        var event = _.defaults({}, eventObject || {}, {
            isPrevented: false,
            emitter: this,
            preventDefault: function () {
                this.isPrevented = true;
            }
        });

        this.trigger(eventName, event);
        return event;
    }

    function retriggerPreventable(eventName, eventObject) {
        var groupEvent = this.triggerPreventable(eventName, eventObject);
        if (groupEvent.isPrevented) {
            eventObject.preventDefault();
        }
    }

    _.extend(Marionette.View.prototype, {
        /**
         * This method unwraps the Backbone.View.
         *
         * By default, Backbone will create a <div> and render the template inside. By calling this
         * method, you can get rid of that <div>, so the main element in your template will be the
         * root element in your template.
         */
        unwrapTemplate: function unwrapTemplate() {
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                var children = this.$el.children();
                this.$el.replaceWith(children);
                this.setElement(children);
            } else {
                // If the template is in memory
                this.setElement(this.$el.children());
            }
        },
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    _.extend(Marionette.Controller.prototype, {
        triggerPreventable: triggerPreventable,
        retriggerPreventable: retriggerPreventable
    });

    Marionette.ViewManager = Marionette.Object.extend({
        constructor: function() {
            //Make sure we initialize the 'views' map first, so descentants
            //of this class can build views in their constructor
            this.views = {};
            Marionette.Controller.apply(this, arguments);
        },

        hideView: function(viewName) {
            var view = this.views[viewName];
            if (view) {
                this.stopListening(view);
                if (!view.isDestroyed) {
                    view.destroy();
                }
                delete this.views[viewName];
            }
        },

        showView: function(viewName, factory) {
            var view = this.buildView(viewName, factory);
            view.render();
        },

        buildView: function(viewName, factory) {
            var view = this.views[viewName];
            if (!view) {
                view = factory.call(this);
                this.listenTo(view, "destroy", function() {
                    this.hideView(viewName);
                });
                this.views[viewName] = view;
            }
            return view;
        },

        getView: function(viewName) {
            return this.views[viewName];
        },

        onDestroy: function() {
            _.each(this.views, function(view, viewName) {
                this.hideView(viewName);
            }, this);
        }
    });


    return Marionette;
});
define("jira/components/lib/marionette-2.1.0", ["jira/components/libs/marionette-2.1.0"], function(M) { "use strict"; return M;});
;
;
/* module-key = 'com.atlassian.plugin.jslibs:backbone.paginator-2.0.2-factory', location = 'factories/backbone.paginator/2.0.2/backbone.paginator-2.0.2-factory.js' */
/////////// Modified by Atlassian ///////////
(function(factory){
    define('atlassian/libs/factories/backbone.paginator-2.0.2', function() {
        return function(_, Backbone) {
            var env = {
                _: _,
                Backbone: Backbone
            };
            factory.call(env);
            var PageableCollection = Backbone.PageableCollection.noConflict();
            PageableCollection.VERSION = "2.0.2";
            return PageableCollection;
        }
    });
})(function(){
/////// End of Atlassian modification ///////

    /*
     backbone.paginator 2.0.2
     http://github.com/backbone-paginator/backbone.paginator

     Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
     Licensed under the MIT @license.
     */

    (function (factory) {
/////////// Modified by Atlassian ///////////
        var root = this;
        var _ = root._;
        var Backbone = root.Backbone;
/////// End of Atlassian modification ///////

        // CommonJS
        if (typeof exports == "object") {
            module.exports = factory(require("underscore"), require("backbone"));
        }
        // AMD
        else if (typeof define == "function" && define.amd) {
            define(["underscore", "backbone"], factory);
        }
        // Browser
        else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
            var oldPageableCollection = Backbone.PageableCollection;
            var PageableCollection = factory(_,Backbone);

            /**
             __BROWSER ONLY__

             If you already have an object named `PageableCollection` attached to the
             `Backbone` module, you can use this to return a local reference to this
             Backbone.PageableCollection class and reset the name
             Backbone.PageableCollection to its previous definition.

             // The left hand side gives you a reference to this
             // Backbone.PageableCollection implementation, the right hand side
             // resets Backbone.PageableCollection to your other
             // Backbone.PageableCollection.
             var PageableCollection = Backbone.PageableCollection.noConflict();

             @static
             @member Backbone.PageableCollection
             @return {Backbone.PageableCollection}
             */
            Backbone.PageableCollection.noConflict = function () {
                Backbone.PageableCollection = oldPageableCollection;
                return PageableCollection;
            };
        }

/////////// Modified by Atlassian ///////////
    }).call(this, (function (_, Backbone)
    {
/////// End of Atlassian modification ///////

        "use strict";

        var _extend = _.extend;
        var _omit = _.omit;
        var _clone = _.clone;
        var _each = _.each;
        var _pick = _.pick;
        var _contains = _.contains;
        var _isEmpty = _.isEmpty;
        var _pairs = _.pairs;
        var _invert = _.invert;
        var _isArray = _.isArray;
        var _isFunction = _.isFunction;
        var _isObject = _.isObject;
        var _keys = _.keys;
        var _isUndefined = _.isUndefined;
        var ceil = Math.ceil;
        var floor = Math.floor;
        var max = Math.max;

        var BBColProto = Backbone.Collection.prototype;

        function finiteInt (val, name) {
            if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
                throw new TypeError("`" + name + "` must be a finite integer");
            }
            return val;
        }

        function queryStringToParams (qs) {
            var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
            var kvps = qs.split('&');
            for (var i = 0, l = kvps.length; i < l; i++) {
                var param = kvps[i];
                kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
                k = decode(k), v = decode(v), ls = params[k];
                if (_isArray(ls)) ls.push(v);
                else if (ls) params[k] = [ls, v];
                else params[k] = v;
            }
            return params;
        }

        // hack to make sure the whatever event handlers for this event is run
        // before func is, and the event handlers that func will trigger.
        function runOnceAtLastHandler (col, event, func) {
            var eventHandlers = col._events[event];
            if (eventHandlers && eventHandlers.length) {
                var lastHandler = eventHandlers[eventHandlers.length - 1];
                var oldCallback = lastHandler.callback;
                lastHandler.callback = function () {
                    try {
                        oldCallback.apply(this, arguments);
                        func();
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        lastHandler.callback = oldCallback;
                    }
                };
            }
            else func();
        }

        var PARAM_TRIM_RE = /[\s'"]/g;
        var URL_TRIM_RE = /[<>\s'"]/g;

        /**
         Drop-in replacement for Backbone.Collection. Supports server-side and
         client-side pagination and sorting. Client-side mode also support fully
         multi-directional synchronization of changes between pages.

         @class Backbone.PageableCollection
         @extends Backbone.Collection
         */
        var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

            /**
             The container object to store all pagination states.

             You can override the default state by extending this class or specifying
             them in an `options` hash to the constructor.

             @property {Object} state

             @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
             your server API uses 0-based indices. You should only override this value
             during extension, initialization or reset by the server after
             fetching. This value should be read only at other times.

             @property {number} [state.lastPage=null] The last page index. This value
             is __read only__ and it's calculated based on whether `firstPage` is 0 or
             1, during bootstrapping, fetching and resetting. Please don't change this
             value under any circumstances.

             @property {number} [state.currentPage=null] The current page index. You
             should only override this value during extension, initialization or reset
             by the server after fetching. This value should be read only at other
             times. Can be a 0-based or 1-based index, depending on whether
             `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
             on initialization.

             @property {number} [state.pageSize=25] How many records to show per
             page. This value is __read only__ after initialization, if you want to
             change the page size after initialization, you must call #setPageSize.

             @property {number} [state.totalPages=null] How many pages there are. This
             value is __read only__ and it is calculated from `totalRecords`.

             @property {number} [state.totalRecords=null] How many records there
             are. This value is __required__ under server mode. This value is optional
             for client mode as the number will be the same as the number of models
             during bootstrapping and during fetching, either supplied by the server
             in the metadata, or calculated from the size of the response.

             @property {string} [state.sortKey=null] The model attribute to use for
             sorting.

             @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
             -1 for ascending order or 1 for descending order. If 0, no client side
             sorting will be done and the order query parameter will not be sent to
             the server during a fetch.
             */
            state: {
                firstPage: 1,
                lastPage: null,
                currentPage: null,
                pageSize: 25,
                totalPages: null,
                totalRecords: null,
                sortKey: null,
                order: -1
            },

            /**
             @property {"server"|"client"|"infinite"} [mode="server"] The mode of
             operations for this collection. `"server"` paginates on the server-side,
             `"client"` paginates on the client-side and `"infinite"` paginates on the
             server-side for APIs that do not support `totalRecords`.
             */
            mode: "server",

            /**
             A translation map to convert Backbone.PageableCollection state attributes
             to the query parameters accepted by your server API.

             You can override the default state by extending this class or specifying
             them in `options.queryParams` object hash to the constructor.

             @property {Object} queryParams
             @property {string} [queryParams.currentPage="page"]
             @property {string} [queryParams.pageSize="per_page"]
             @property {string} [queryParams.totalPages="total_pages"]
             @property {string} [queryParams.totalRecords="total_entries"]
             @property {string} [queryParams.sortKey="sort_by"]
             @property {string} [queryParams.order="order"]
             @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
             map for translating a Backbone.PageableCollection#state.order constant to
             the ones your server API accepts.
             */
            queryParams: {
                currentPage: "page",
                pageSize: "per_page",
                totalPages: "total_pages",
                totalRecords: "total_entries",
                sortKey: "sort_by",
                order: "order",
                directions: {
                    "-1": "asc",
                    "1": "desc"
                }
            },

            /**
             __CLIENT MODE ONLY__

             This collection is the internal storage for the bootstrapped or fetched
             models. You can use this if you want to operate on all the pages.

             @property {Backbone.Collection} fullCollection
             */

            /**
             Given a list of models or model attributues, bootstraps the full
             collection in client mode or infinite mode, or just the page you want in
             server mode.

             If you want to initialize a collection to a different state than the
             default, you can specify them in `options.state`. Any state parameters
             supplied will be merged with the default. If you want to change the
             default mapping from #state keys to your server API's query parameter
             names, you can specifiy an object hash in `option.queryParams`. Likewise,
             any mapping provided will be merged with the default. Lastly, all
             Backbone.Collection constructor options are also accepted.

             See:

             - Backbone.PageableCollection#state
             - Backbone.PageableCollection#queryParams
             - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

             @param {Array.<Object>} [models]

             @param {Object} [options]

             @param {function(*, *): number} [options.comparator] If specified, this
             comparator is set to the current page under server mode, or the #fullCollection
             otherwise.

             @param {boolean} [options.full] If `false` and either a
             `options.comparator` or `sortKey` is defined, the comparator is attached
             to the current page. Default is `true` under client or infinite mode and
             the comparator will be attached to the #fullCollection.

             @param {Object} [options.state] The state attributes overriding the defaults.

             @param {string} [options.state.sortKey] The model attribute to use for
             sorting. If specified instead of `options.comparator`, a comparator will
             be automatically created using this value, and optionally a sorting order
             specified in `options.state.order`. The comparator is then attached to
             the new collection instance.

             @param {-1|1} [options.state.order] The order to use for sorting. Specify
             -1 for ascending order and 1 for descending order.

             @param {Object} [options.queryParam]
             */
            constructor: function (models, options) {

                BBColProto.constructor.apply(this, arguments);

                options = options || {};

                var mode = this.mode = options.mode || this.mode || PageableProto.mode;

                var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
                                options.queryParams || {});

                queryParams.directions = _extend({},
                        PageableProto.queryParams.directions,
                        this.queryParams.directions,
                                queryParams.directions || {});

                this.queryParams = queryParams;

                var state = this.state = _extend({}, PageableProto.state, this.state,
                                options.state || {});

                state.currentPage = state.currentPage == null ?
                        state.firstPage :
                        state.currentPage;

                if (!_isArray(models)) models = models ? [models] : [];
                models = models.slice();

                if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
                    state.totalRecords = models.length;
                }

                this.switchMode(mode, _extend({fetch: false,
                    resetState: false,
                    models: models}, options));

                var comparator = options.comparator;

                if (state.sortKey && !comparator) {
                    this.setSorting(state.sortKey, state.order, options);
                }

                if (mode != "server") {
                    var fullCollection = this.fullCollection;

                    if (comparator && options.full) {
                        this.comparator = null;
                        fullCollection.comparator = comparator;
                    }

                    if (options.full) fullCollection.sort();

                    // make sure the models in the current page and full collection have the
                    // same references
                    if (models && !_isEmpty(models)) {
                        this.reset(models, _extend({silent: true}, options));
                        this.getPage(state.currentPage);
                        models.splice.apply(models, [0, models.length].concat(this.models));
                    }
                }

                this._initState = _clone(this.state);
            },

            /**
             Makes a Backbone.Collection that contains all the pages.

             @private
             @param {Array.<Object|Backbone.Model>} models
             @param {Object} options Options for Backbone.Collection constructor.
             @return {Backbone.Collection}
             */
            _makeFullCollection: function (models, options) {

                var properties = ["url", "model", "sync", "comparator"];
                var thisProto = this.constructor.prototype;
                var i, length, prop;

                var proto = {};
                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (!_isUndefined(thisProto[prop])) {
                        proto[prop] = thisProto[prop];
                    }
                }

                var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

                for (i = 0, length = properties.length; i < length; i++) {
                    prop = properties[i];
                    if (this[prop] !== thisProto[prop]) {
                        fullCollection[prop] = this[prop];
                    }
                }

                return fullCollection;
            },

            /**
             Factory method that returns a Backbone event handler that responses to
             the `add`, `remove`, `reset`, and the `sort` events. The returned event
             handler will synchronize the current page collection and the full
             collection's models.

             @private

             @param {Backbone.PageableCollection} pageCol
             @param {Backbone.Collection} fullCol

             @return {function(string, Backbone.Model, Backbone.Collection, Object)}
             Collection event handler
             */
            _makeCollectionEventHandler: function (pageCol, fullCol) {

                return function collectionEventHandler (event, model, collection, options) {

                    var handlers = pageCol._handlers;
                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        pageCol.off(event, handler);
                        fullCol.off(event, handler);
                    });

                    var state = _clone(pageCol.state);
                    var firstPage = state.firstPage;
                    var currentPage = firstPage === 0 ?
                            state.currentPage :
                            state.currentPage - 1;
                    var pageSize = state.pageSize;
                    var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

                    if (event == "add") {
                        var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
                        if (collection == fullCol) {
                            fullIndex = fullCol.indexOf(model);
                            if (fullIndex >= pageStart && fullIndex < pageEnd) {
                                colToAdd = pageCol;
                                pageIndex = addAt = fullIndex - pageStart;
                            }
                        }
                        else {
                            pageIndex = pageCol.indexOf(model);
                            fullIndex = pageStart + pageIndex;
                            colToAdd = fullCol;
                            var addAt = !_isUndefined(options.at) ?
                                    options.at + pageStart :
                                    fullIndex;
                        }

                        if (!options.onRemove) {
                            ++state.totalRecords;
                            delete options.onRemove;
                        }

                        pageCol.state = pageCol._checkState(state);

                        if (colToAdd) {
                            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
                            var modelToRemove = pageIndex >= pageSize ?
                                    model :
                                            !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
                                    pageCol.at(pageSize) :
                                    null;
                            if (modelToRemove) {
                                runOnceAtLastHandler(collection, event, function () {
                                    pageCol.remove(modelToRemove, {onAdd: true});
                                });
                            }
                        }
                    }

                    // remove the model from the other collection as well
                    if (event == "remove") {
                        if (!options.onAdd) {
                            // decrement totalRecords and update totalPages and lastPage
                            if (!--state.totalRecords) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            else {
                                var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
                                state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
                                if (state.currentPage > totalPages) state.currentPage = state.lastPage;
                            }
                            pageCol.state = pageCol._checkState(state);

                            var nextModel, removedIndex = options.index;
                            if (collection == pageCol) {
                                if (nextModel = fullCol.at(pageEnd)) {
                                    runOnceAtLastHandler(pageCol, event, function () {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                else if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                                fullCol.remove(model);
                            }
                            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
                                if (nextModel = fullCol.at(pageEnd - 1)) {
                                    runOnceAtLastHandler(pageCol, event, function() {
                                        pageCol.push(nextModel, {onRemove: true});
                                    });
                                }
                                pageCol.remove(model);
                                if (!pageCol.length && state.totalRecords) {
                                    pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                                            _extend({}, options, {parse: false}));
                                }
                            }
                        }
                        else delete options.onAdd;
                    }

                    if (event == "reset") {
                        options = collection;
                        collection = model;

                        // Reset that's not a result of getPage
                        if (collection == pageCol && options.from == null &&
                                options.to == null) {
                            var head = fullCol.models.slice(0, pageStart);
                            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
                            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
                        }
                        else if (collection == fullCol) {
                            if (!(state.totalRecords = fullCol.models.length)) {
                                state.totalRecords = null;
                                state.totalPages = null;
                            }
                            if (pageCol.mode == "client") {
                                state.lastPage = state.currentPage = state.firstPage;
                            }
                            pageCol.state = pageCol._checkState(state);
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    if (event == "sort") {
                        options = collection;
                        collection = model;
                        if (collection === fullCol) {
                            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                                    _extend({}, options, {parse: false}));
                        }
                    }

                    _each(_keys(handlers), function (event) {
                        var handler = handlers[event];
                        _each([pageCol, fullCol], function (col) {
                            col.on(event, handler);
                            var callbacks = col._events[event] || [];
                            callbacks.unshift(callbacks.pop());
                        });
                    });
                };
            },

            /**
             Sanity check this collection's pagination states. Only perform checks
             when all the required pagination state values are defined and not null.
             If `totalPages` is undefined or null, it is set to `totalRecords` /
             `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
             when no error occurs.

             @private

             @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
             `firstPage` is not a finite integer.

             @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
             of bounds.

             @return {Object} Returns the `state` object if no error was found.
             */
            _checkState: function (state) {

                var mode = this.mode;
                var links = this.links;
                var totalRecords = state.totalRecords;
                var pageSize = state.pageSize;
                var currentPage = state.currentPage;
                var firstPage = state.firstPage;
                var totalPages = state.totalPages;

                if (totalRecords != null && pageSize != null && currentPage != null &&
                        firstPage != null && (mode == "infinite" ? links : true)) {

                    totalRecords = finiteInt(totalRecords, "totalRecords");
                    pageSize = finiteInt(pageSize, "pageSize");
                    currentPage = finiteInt(currentPage, "currentPage");
                    firstPage = finiteInt(firstPage, "firstPage");

                    if (pageSize < 1) {
                        throw new RangeError("`pageSize` must be >= 1");
                    }

                    totalPages = state.totalPages = ceil(totalRecords / pageSize);

                    if (firstPage < 0 || firstPage > 1) {
                        throw new RangeError("`firstPage must be 0 or 1`");
                    }

                    state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

                    if (mode == "infinite") {
                        if (!links[currentPage + '']) {
                            throw new RangeError("No link found for page " + currentPage);
                        }
                    }
                    else if (currentPage < firstPage ||
                            (totalPages > 0 &&
                                    (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
                        throw new RangeError("`currentPage` must be firstPage <= currentPage " +
                                (firstPage ? ">" : ">=") +
                                " totalPages if " + firstPage + "-based. Got " +
                                currentPage + '.');
                    }
                }

                return state;
            },

            /**
             Change the page size of this collection.

             Under most if not all circumstances, you should call this method to
             change the page size of a pageable collection because it will keep the
             pagination state sane. By default, the method will recalculate the
             current page number to one that will retain the current page's models
             when increasing the page size. When decreasing the page size, this method
             will retain the last models to the current page that will fit into the
             smaller page size.

             If `options.first` is true, changing the page size will also reset the
             current page back to the first page instead of trying to be smart.

             For server mode operations, changing the page size will trigger a #fetch
             and subsequently a `reset` event.

             For client mode operations, changing the page size will `reset` the
             current page by recalculating the current page boundary on the client
             side.

             If `options.fetch` is true, a fetch can be forced if the collection is in
             client mode.

             @param {number} pageSize The new page size to set to #state.
             @param {Object} [options] {@link #fetch} options.
             @param {boolean} [options.first=false] Reset the current page number to
             the first page if `true`.
             @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

             @throws {TypeError} If `pageSize` is not a finite integer.
             @throws {RangeError} If `pageSize` is less than 1.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            setPageSize: function (pageSize, options) {
                pageSize = finiteInt(pageSize, "pageSize");

                options = options || {first: false};

                var state = this.state;
                var totalPages = ceil(state.totalRecords / pageSize);
                var currentPage = totalPages ?
                        max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
                        state.firstPage;

                state = this.state = this._checkState(_extend({}, state, {
                    pageSize: pageSize,
                    currentPage: options.first ? state.firstPage : currentPage,
                    totalPages: totalPages
                }));

                return this.getPage(state.currentPage, _omit(options, ["first"]));
            },

            /**
             Switching between client, server and infinite mode.

             If switching from client to server mode, the #fullCollection is emptied
             first and then deleted and a fetch is immediately issued for the current
             page from the server. Pass `false` to `options.fetch` to skip fetching.

             If switching to infinite mode, and if `options.models` is given for an
             array of models, #links will be populated with a URL per page, using the
             default URL for this collection.

             If switching from server to client mode, all of the pages are immediately
             refetched. If you have too many pages, you can pass `false` to
             `options.fetch` to skip fetching.

             If switching to any mode from infinite mode, the #links will be deleted.

             @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

             @param {Object} [options]

             @param {boolean} [options.fetch=true] If `false`, no fetching is done.

             @param {boolean} [options.resetState=true] If 'false', the state is not
             reset, but checked for sanity instead.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this if `options.fetch` is `false`.
             */
            switchMode: function (mode, options) {

                if (!_contains(["server", "client", "infinite"], mode)) {
                    throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
                }

                options = options || {fetch: true, resetState: true};

                var state = this.state = options.resetState ?
                        _clone(this._initState) :
                        this._checkState(_extend({}, this.state));

                this.mode = mode;

                var self = this;
                var fullCollection = this.fullCollection;
                var handlers = this._handlers = this._handlers || {}, handler;
                if (mode != "server" && !fullCollection) {
                    fullCollection = this._makeFullCollection(options.models || [], options);
                    fullCollection.pageableCollection = this;
                    this.fullCollection = fullCollection;
                    var allHandler = this._makeCollectionEventHandler(this, fullCollection);
                    _each(["add", "remove", "reset", "sort"], function (event) {
                        handlers[event] = handler = _.bind(allHandler, {}, event);
                        self.on(event, handler);
                        fullCollection.on(event, handler);
                    });
                    fullCollection.comparator = this._fullComparator;
                }
                else if (mode == "server" && fullCollection) {
                    _each(_keys(handlers), function (event) {
                        handler = handlers[event];
                        self.off(event, handler);
                        fullCollection.off(event, handler);
                    });
                    delete this._handlers;
                    this._fullComparator = fullCollection.comparator;
                    delete this.fullCollection;
                }

                if (mode == "infinite") {
                    var links = this.links = {};
                    var firstPage = state.firstPage;
                    var totalPages = ceil(state.totalRecords / state.pageSize);
                    var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
                    for (var i = state.firstPage; i <= lastPage; i++) {
                        links[i] = this.url;
                    }
                }
                else if (this.links) delete this.links;

                return options.fetch ?
                        this.fetch(_omit(options, "fetch", "resetState")) :
                        this;
            },

            /**
             @return {boolean} `true` if this collection can page backward, `false`
             otherwise.
             */
            hasPreviousPage: function () {
                var state = this.state;
                var currentPage = state.currentPage;
                if (this.mode != "infinite") return currentPage > state.firstPage;
                return !!this.links[currentPage - 1];
            },

            /**
             @return {boolean} `true` if this collection can page forward, `false`
             otherwise.
             */
            hasNextPage: function () {
                var state = this.state;
                var currentPage = this.state.currentPage;
                if (this.mode != "infinite") return currentPage < state.lastPage;
                return !!this.links[currentPage + 1];
            },

            /**
             Fetch the first page in server mode, or reset the current page of this
             collection to the first page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getFirstPage: function (options) {
                return this.getPage("first", options);
            },

            /**
             Fetch the previous page in server mode, or reset the current page of this
             collection to the previous page in client or infinite mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPreviousPage: function (options) {
                return this.getPage("prev", options);
            },

            /**
             Fetch the next page in server mode, or reset the current page of this
             collection to the next page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getNextPage: function (options) {
                return this.getPage("next", options);
            },

            /**
             Fetch the last page in server mode, or reset the current page of this
             collection to the last page in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getLastPage: function (options) {
                return this.getPage("last", options);
            },

            /**
             Given a page index, set #state.currentPage to that index. If this
             collection is in server mode, fetch the page using the updated state,
             otherwise, reset the current page of this collection to the page
             specified by `index` in client mode. If `options.fetch` is true, a fetch
             can be forced in client mode before resetting the current page. Under
             infinite mode, if the index is less than the current page, a reset is
             done as in client mode. If the index is greater than the current page
             number, a fetch is made with the results **appended** to #fullCollection.
             The current page will then be reset after fetching.

             @param {number|string} index The page index to go to, or the page name to
             look up from #links in infinite mode.
             @param {Object} [options] {@link #fetch} options or
             [reset](http://backbonejs.org/#Collection-reset) options for client mode
             when `options.fetch` is `false`.
             @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
             client mode.

             @throws {TypeError} If `index` is not a finite integer under server or
             client mode, or does not yield a URL from #links under infinite mode.

             @throws {RangeError} If `index` is out of bounds.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPage: function (index, options) {

                var mode = this.mode, fullCollection = this.fullCollection;

                options = options || {fetch: false};

                var state = this.state,
                        firstPage = state.firstPage,
                        currentPage = state.currentPage,
                        lastPage = state.lastPage,
                        pageSize = state.pageSize;

                var pageNum = index;
                switch (index) {
                    case "first": pageNum = firstPage; break;
                    case "prev": pageNum = currentPage - 1; break;
                    case "next": pageNum = currentPage + 1; break;
                    case "last": pageNum = lastPage; break;
                    default: pageNum = finiteInt(index, "index");
                }

                this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

                options.from = currentPage, options.to = pageNum;

                var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
                var pageModels = fullCollection && fullCollection.length ?
                        fullCollection.models.slice(pageStart, pageStart + pageSize) :
                        [];
                if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
                        !options.fetch) {
                    this.reset(pageModels, _omit(options, "fetch"));
                    return this;
                }

                if (mode == "infinite") options.url = this.links[pageNum];

                return this.fetch(_omit(options, "fetch"));
            },

            /**
             Fetch the page for the provided item offset in server mode, or reset the current page of this
             collection to the page for the provided item offset in client mode.

             @param {Object} options {@link #getPage} options.

             @chainable
             @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
             from fetch or this.
             */
            getPageByOffset: function (offset, options) {
                if (offset < 0) {
                    throw new RangeError("`offset must be > 0`");
                }
                offset = finiteInt(offset);

                var page = floor(offset / this.state.pageSize);
                if (this.state.firstPage !== 0) page++;
                if (page > this.state.lastPage) page = this.state.lastPage;
                return this.getPage(page, options);
            },

            /**
             Overidden to make `getPage` compatible with Zepto.

             @param {string} method
             @param {Backbone.Model|Backbone.Collection} model
             @param {Object} [options]

             @return {XMLHttpRequest}
             */
            sync: function (method, model, options) {
                var self = this;
                if (self.mode == "infinite") {
                    var success = options.success;
                    var currentPage = self.state.currentPage;
                    options.success = function (resp, status, xhr) {
                        var links = self.links;
                        var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
                        if (newLinks.first) links[self.state.firstPage] = newLinks.first;
                        if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
                        if (newLinks.next) links[currentPage + 1] = newLinks.next;
                        if (success) success(resp, status, xhr);
                    };
                }

                return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
            },

            /**
             Parse pagination links from the server response. Only valid under
             infinite mode.

             Given a response body and a XMLHttpRequest object, extract pagination
             links from them for infinite paging.

             This default implementation parses the RFC 5988 `Link` header and extract
             3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
             method __must__ return an object hash having only the keys
             above. However, simply returning a `next` link or an empty hash if there
             are no more links should be enough for most implementations.

             @param {*} resp The deserialized response body.
             @param {Object} [options]
             @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
             response.
             @return {Object}
             */
            parseLinks: function (resp, options) {
                var links = {};
                var linkHeader = options.xhr.getResponseHeader("Link");
                if (linkHeader) {
                    var relations = ["first", "prev", "next"];
                    _each(linkHeader.split(","), function (linkValue) {
                        var linkParts = linkValue.split(";");
                        var url = linkParts[0].replace(URL_TRIM_RE, '');
                        var params = linkParts.slice(1);
                        _each(params, function (param) {
                            var paramParts = param.split("=");
                            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
                            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
                            if (key == "rel" && _contains(relations, value)) links[value] = url;
                        });
                    });
                }

                return links;
            },

            /**
             Parse server response data.

             This default implementation assumes the response data is in one of two
             structures:

             [
             {}, // Your new pagination state
             [{}, ...] // An array of JSON objects
             ]

             Or,

             [{}] // An array of JSON objects

             The first structure is the preferred form because the pagination states
             may have been updated on the server side, sending them down again allows
             this collection to update its states. If the response has a pagination
             state object, it is checked for errors.

             The second structure is the
             [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
             default.

             **Note:** this method has been further simplified since 1.1.7. While
             existing #parse implementations will continue to work, new code is
             encouraged to override #parseState and #parseRecords instead.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} the options for the ajax request

             @return {Array.<Object>} An array of model objects
             */
            parse: function (resp, options) {
                var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
                if (newState) this.state = this._checkState(_extend({}, this.state, newState));
                return this.parseRecords(resp, options);
            },

            /**
             Parse server response for server pagination state updates. Not applicable
             under infinite mode.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, a state object is
             returned by mapping the server state keys to this pageable collection
             instance's query parameter keys using `queryParams`.

             It is __NOT__ neccessary to return a full state object complete with all
             the mappings defined in #queryParams. Any state object resulted is merged
             with a copy of the current pageable collection state and checked for
             sanity before actually updating. Most of the time, simply providing a new
             `totalRecords` value is enough to trigger a full pagination state
             recalculation.

             parseState: function (resp, queryParams, state, options) {
                 return {totalRecords: resp.total_entries};
               }

             If you want to use header fields use:

             parseState: function (resp, queryParams, state, options) {
                   return {totalRecords: options.xhr.getResponseHeader("X-total")};
               }

             This method __MUST__ return a new state object instead of directly
             modifying the #state object. The behavior of directly modifying #state is
             undefined.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} queryParams A copy of #queryParams.
             @param {Object} state A copy of #state.
             @param {Object} [options] The options passed through from
             `parse`. (backbone >= 0.9.10 only)

             @return {Object} A new (partial) state object.
             */
            parseState: function (resp, queryParams, state, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

                    var newState = _clone(state);
                    var serverState = resp[0];

                    _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
                        var k = kvp[0], v = kvp[1];
                        var serverVal = serverState[v];
                        if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
                    });

                    if (serverState.order) {
                        newState.order = _invert(queryParams.directions)[serverState.order] * 1;
                    }

                    return newState;
                }
            },

            /**
             Parse server response for an array of model objects.

             This default implementation first checks whether the response has any
             state object as documented in #parse. If it exists, the array of model
             objects is assumed to be the second element, otherwise the entire
             response is returned directly.

             @param {Object} resp The deserialized response data from the server.
             @param {Object} [options] The options passed through from the
             `parse`. (backbone >= 0.9.10 only)

             @return {Array.<Object>} An array of model objects
             */
            parseRecords: function (resp, options) {
                if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
                    return resp[1];
                }

                return resp;
            },

            /**
             Fetch a page from the server in server mode, or all the pages in client
             mode. Under infinite mode, the current page is refetched by default and
             then reset.

             The query string is constructed by translating the current pagination
             state to your server API query parameter using #queryParams. The current
             page will reset after fetch.

             @param {Object} [options] Accepts all
             [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
             options.

             @return {XMLHttpRequest}
             */
            fetch: function (options) {

                options = options || {};

                var state = this._checkState(this.state);

                var mode = this.mode;

                if (mode == "infinite" && !options.url) {
                    options.url = this.links[state.currentPage];
                }

                var data = options.data || {};

                // dedup query params
                var url = options.url || this.url || "";
                if (_isFunction(url)) url = url.call(this);
                var qsi = url.indexOf('?');
                if (qsi != -1) {
                    _extend(data, queryStringToParams(url.slice(qsi + 1)));
                    url = url.slice(0, qsi);
                }

                options.url = url;
                options.data = data;

                // map params except directions
                var queryParams = this.mode == "client" ?
                        _pick(this.queryParams, "sortKey", "order") :
                        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
                                "directions");

                var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
                for (i = 0; i < kvps.length; i++) {
                    kvp = kvps[i], k = kvp[0], v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (state[k] != null && v != null) {
                        data[v] = state[k];
                    }
                }

                // fix up sorting parameters
                if (state.sortKey && state.order) {
                    var o = _isFunction(queryParams.order) ?
                            queryParams.order.call(thisCopy) :
                            queryParams.order;
                    data[o] = this.queryParams.directions[state.order + ""];
                }
                else if (!state.sortKey) delete data[queryParams.order];

                // map extra query parameters
                var extraKvps = _pairs(_omit(this.queryParams,
                        _keys(PageableProto.queryParams)));
                for (i = 0; i < extraKvps.length; i++) {
                    kvp = extraKvps[i];
                    v = kvp[1];
                    v = _isFunction(v) ? v.call(thisCopy) : v;
                    if (v != null) data[kvp[0]] = v;
                }

                if (mode != "server") {
                    var self = this, fullCol = this.fullCollection;
                    var success = options.success;
                    options.success = function (col, resp, opts) {

                        // make sure the caller's intent is obeyed
                        opts = opts || {};
                        if (_isUndefined(options.silent)) delete opts.silent;
                        else opts.silent = options.silent;

                        var models = col.models;
                        if (mode == "client") fullCol.reset(models, opts);
                        else {
                            fullCol.add(models, _extend({at: fullCol.length},
                                    _extend(opts, {parse: false})));
                            self.trigger("reset", self, opts);
                        }

                        if (success) success(col, resp, opts);
                    };

                    // silent the first reset from backbone
                    return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
                }

                return BBColProto.fetch.call(this, options);
            },

            /**
             Convenient method for making a `comparator` sorted by a model attribute
             identified by `sortKey` and ordered by `order`.

             Like a Backbone.Collection, a Backbone.PageableCollection will maintain
             the __current page__ in sorted order on the client side if a `comparator`
             is attached to it. If the collection is in client mode, you can attach a
             comparator to #fullCollection to have all the pages reflect the global
             sorting order by specifying an option `full` to `true`. You __must__ call
             `sort` manually or #fullCollection.sort after calling this method to
             force a resort.

             While you can use this method to sort the current page in server mode,
             the sorting order may not reflect the global sorting order due to the
             additions or removals of the records on the server since the last
             fetch. If you want the most updated page in a global sorting order, it is
             recommended that you set #state.sortKey and optionally #state.order, and
             then call #fetch.

             @protected

             @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

             See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
             */
            _makeComparator: function (sortKey, order, sortValue) {
                var state = this.state;

                sortKey = sortKey || state.sortKey;
                order = order || state.order;

                if (!sortKey || !order) return;

                if (!sortValue) sortValue = function (model, attr) {
                    return model.get(attr);
                };

                return function (left, right) {
                    var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
                    if (order === 1) t = l, l = r, r = t;
                    if (l === r) return 0;
                    else if (l < r) return -1;
                    return 1;
                };
            },

            /**
             Adjusts the sorting for this pageable collection.

             Given a `sortKey` and an `order`, sets `state.sortKey` and
             `state.order`. A comparator can be applied on the client side to sort in
             the order defined if `options.side` is `"client"`. By default the
             comparator is applied to the #fullCollection. Set `options.full` to
             `false` to apply a comparator to the current page under any mode. Setting
             `sortKey` to `null` removes the comparator from both the current page and
             the full collection.

             If a `sortValue` function is given, it will be passed the `(model,
             sortKey)` arguments and is used to extract a value from the model during
             comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
             used for sorting.

             @chainable

             @param {string} sortKey See `state.sortKey`.
             @param {number} [order=this.state.order] See `state.order`.
             @param {Object} [options]
             @param {"server"|"client"} [options.side] By default, `"client"` if
             `mode` is `"client"`, `"server"` otherwise.
             @param {boolean} [options.full=true]
             @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
             */
            setSorting: function (sortKey, order, options) {

                var state = this.state;

                state.sortKey = sortKey;
                state.order = order = order || state.order;

                var fullCollection = this.fullCollection;

                var delComp = false, delFullComp = false;

                if (!sortKey) delComp = delFullComp = true;

                var mode = this.mode;
                options = _extend({side: mode == "client" ? mode : "server", full: true},
                        options);

                var comparator = this._makeComparator(sortKey, order, options.sortValue);

                var full = options.full, side = options.side;

                if (side == "client") {
                    if (full) {
                        if (fullCollection) fullCollection.comparator = comparator;
                        delComp = true;
                    }
                    else {
                        this.comparator = comparator;
                        delFullComp = true;
                    }
                }
                else if (side == "server" && !full) {
                    this.comparator = comparator;
                }

                if (delComp) this.comparator = null;
                if (delFullComp && fullCollection) fullCollection.comparator = null;

                return this;
            }

        });

        var PageableProto = PageableCollection.prototype;

        return PageableCollection;

/////////// Modified by Atlassian ///////////
    }));

});
/////// End of Atlassian modification ///////
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:backbone.paginator', location = 'libs/backbone.paginator.js' */
define("jira/components/libs/backbone.paginator", [
    "atlassian/libs/factories/backbone.paginator-2.0.2",
    "jira/components/libs/backbone",
    "jira/components/libs/underscore"
], function(
    backbonePaginatorFactory,
    Backbone,
    _
) {
    "use strict";

    return backbonePaginatorFactory(_, Backbone);
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/Search.js' */
define("jira/components/search", [
    "jira/components/libs/backbone",
    "jira/components/libs/underscore",
    "jquery",
    "jira/components/search/results",
    "jira/components/search/latestStorage"
], function (
    Backbone,
    _,
    jQuery,
    Results,
    LatestSearchStore
) {
    "use strict";

    /**
     * This class contains the model for a Search. A Search is a collection of issues as a result
     * of running a JQL in the server. This entity is not meant to be used directly by any view.
     * Instead, this entity will generate a SearchResults entity that contains the stable search.
     *
     * All operations performed in this entity will result in a new set of results
     * (aka un-stable search).
     */
    return Backbone.Collection.extend({
        url: function () {
            return AJS.contextPath() + "/rest/issueNav/1/issueTable";
        },

        searchParams: {
            jql: "",
            filterId: null,
            columnConfig: "explicit",
            columns: [],
            layoutKey: "split-view",
            startIndex: 0
        },

        sync: function () {
            var args = _.toArray(arguments);
            var params = args[2];

            params.type = "POST";
            params.headers = {
                "X-Atlassian-Token": "no-check"
            };

            // Add our search data.
            params.data = {};
            _.each(_.keys(this.searchParams), function (key) {
                if (this.searchParams[key] !== null) {
                    params.data[key] = this.searchParams[key];
                }
            }, this);

            return Backbone.Collection.prototype.sync.apply(this, args);
        },

        parse: function (resp) {
            // Clean the data
            var data = resp && resp.issueTable;
            if (!data || !data.issueIds) {
                return [];
            }

            // Extract all the issues from the first search.
            return _.map(data.issueIds, function (id, index) { return {id: id, key: data.issueKeys[index]}; });
        },

        update: function(response) {
            this.set(this.parse(response));
        },

        /**
         * @param preloadedData expects an object like { jql: "..jql used..", response: {..ajax response..} }
         */
        setPreloadedData: function(preloadedData) {
            this.preloadedData = preloadedData;
        },

        parseResults: function(jql, response) {
            return new Results([], {
                issues: this.toJSON(),
                pageSize: response.issueTable.pageSize,
                totalRecordsInDB: response.issueTable.total,
                totalRecordsInSearch: this.length,
                jql: jql
            });
        },

        search: function (jql) {
            this.searchParams.jql = jql;

            var deferred = new jQuery.Deferred();

            if (this.preloadedData && this.preloadedData.jql === jql) {
                this.reset(this.preloadedData.response, { parse: true });
                deferred.resolve(this.parseResults(jql, this.preloadedData.response));
                delete this.preloadedData;
            } else {
                this.fetch({
                    reset: true,
                    success: _.bind(function (collection, response) {
                        deferred.resolve(this.parseResults(collection.searchParams.jql, response));
                    }, this),
                    error: function (collection, response) {
                        deferred.reject(response);
                    }
                });
            }

            deferred.done(function(results){
                LatestSearchStore.save({jql: results.jql});
            });

            return deferred.promise();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/SearchResult.js' */
define("jira/components/search/result", [
    "jira/components/libs/backbone"
], function (
    Backbone
) {
    "use strict";
    return Backbone.Model.extend({
        initialize: function () {
            // We need to create url function inside the initialize method because when combining
            // Backbone 1.0.0 and PageableCollection, it will pass its own URL when creating models,
            // making all the models have the same URL than the collection (duh). This has been fixed
            // in Backbone 1.1.0
            this.url = function () {
                return AJS.contextPath() + "/rest/api/2/issue/" + this.id + "?fields=summary,status,issuetype";
            };
        },

        parse: function (data) {
            // Backbone will call this method two times:
            // 1. When the SearchResults is initially created with a specific page.
            // 2. When updating an issue after a successful inline edit.

            var result = {};

            if (!data.inaccessible) {
                result.id = parseInt(data.id, 10);
                result.key = data.key;

                if (data.fields) {
                    // This comes from inline edit.
                    result.summary = data.fields.summary;
                    result.status = data.fields.status.name;
                    result.type = {
                        description: data.fields.issuetype.description,
                        iconUrl: data.fields.issuetype.iconUrl,
                        name: data.fields.issuetype.name
                    };
                } else {
                    // This comes from fetching a page
                    result.status = data.status;
                    result.summary = data.summary;
                    result.type = data.type;
                }
            } else {
                result.id = parseInt(data.id, 10);
                result.key = data.key;
                result.inaccessible = true;
            }

            return result;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:search', location = 'search/SearchResults.js' */
define("jira/components/search/results", [
    "jira/components/libs/backbone",
    "jira/components/libs/backbone.paginator",
    "jira/components/libs/underscore",
    "jquery",
    "jira/components/search/result"
], function (
    Backbone,
    PageableCollection,
    _,
    jQuery,
    Result
) {
    "use strict";

    var Results = PageableCollection.extend({
        initialize: function (models, options) {
            options = options || {};
            this.allIssues = options.issues;
            this.state.pageSize = options.pageSize;
            this.state.totalRecords = options.totalRecordsInSearch;
            this.totalRecordsInDB = options.totalRecordsInDB;
            this.allowNoSelection = options.allowNoSelection;
            this.jql = options.jql;
        },

        model: Result,

        url: function () {
            return AJS.contextPath() + "/rest/issueNav/1/issueTable/stable";
        },

        // Initial pagination states
        state: {
            firstPage: 0,
            currentPage: 0
        },

        queryParams: {
            currentPage: null,
            pageSize: null,
            totalPages: null,
            totalRecords: null,
            sortKey: null,
            directions: null
        },

        sync: function () {
            var args = _.toArray(arguments);
            var params = args[2];

            params.type = "POST";
            params.headers = {
                "X-Atlassian-Token": "no-check"
            };
            params.data.layoutKey = "split-view";
            params.data.id = this._getStableKeys();

            return PageableCollection.prototype.sync.apply(this, args);
        },

        isAtTheEndOfStableSearch: function () {
            var isLastPage = this.state.currentPage === this.state.lastPage;
            var areThereMoreIssues = this.totalRecordsInDB > this.state.totalRecords;
            return isLastPage && areThereMoreIssues;
        },

        /**
         * @param preloadedData expects an object like this: { ids: [1000,1001,10002], response: {..ajax response..}}
         */
        setPreloadedData: function(preloadedData) {
            this.preloadedData = preloadedData;
            return this;
        },

        _getStableKeys: function (startIndex) {
            var start = typeof startIndex === 'undefined' ? this._getStartIndex() : startIndex;
            return _.pluck(this.allIssues, "id").slice(start, start + this.state.pageSize);
        },

        _getStartIndex: function () {
            return this.state.pageSize * this.state.currentPage;
        },

        _loadPageAndSelect: function (pageToLoad, issueToSelect) {
            var deferred = new jQuery.Deferred();

            var options = {fetch: true, reset: true};
            this.trigger("before:loadpage", {
                pageToLoad: pageToLoad
            });
            this.getPage(pageToLoad, options)
                .done(_.bind(function () {
                    this.select(issueToSelect);
                    deferred.resolve(this.length);
                }, this))
                .fail(_.bind(function(response) {
                    deferred.reject(response);
                    this.trigger("error:loadpage", response);
                }, this));

            return deferred.promise();
        },

        fetch: function(options) {
            var promise;
            if (this.preloadedData && _.isEqual(this.preloadedData.ids, this._getStableKeys(this.state.pageSize * options.to))) {
                this.reset(this.preloadedData.response, { parse: true });
                promise = new jQuery.Deferred().resolve().promise();
                delete this.preloadedData;
            } else {
                promise = PageableCollection.prototype.fetch.call(this, options);
            }
            return promise;
        },

        jumpToPage: function (page) {
            var deferred = new jQuery.Deferred();
            this._loadPageAndSelect(page, "first")
                .done(deferred.resolve)
                .fail(deferred.reject);
            return deferred.promise();
        },

        jumpToPageForIssue: function (issueIdOrKey) {
            var deferred = new jQuery.Deferred();
            var isIssueId = (typeof issueIdOrKey === "number");
            var isIssueKey = (typeof issueIdOrKey === "string");

            // Find which page the issue belongs to
            var pageToLoad;
            var issue;
            for (var i = 0, len = this.allIssues.length; i < len && !issue; i++) {
                if (
                    (isIssueId && this.allIssues[i].id === issueIdOrKey) ||
                    (isIssueKey && this.allIssues[i].key === issueIdOrKey)
                ) {
                    issue = this.allIssues[i];
                    pageToLoad = Math.floor(i / this.state.pageSize);
                }
            }

            if (typeof pageToLoad === "number" && isFinite(pageToLoad)) {
                // Page for issue found, go to the page and select the issue
                this._loadPageAndSelect(pageToLoad, issue.id).done(deferred.resolve);
            } else if (this.allowNoSelection) {
                // Page for issue not found, but we allow having no selection
                // Load the page but do not select anything
                this._loadPageAndSelect("first", null).done(_.bind(function(){
                    this.trigger("selectIssueNotInList", new Result({
                        id: isIssueId ? issueIdOrKey : undefined,
                        key: isIssueKey ? issueIdOrKey : undefined
                    }));
                }, this)).done(deferred.resolve);
            } else {
                // Page for issue not found and we require a selection, select
                // the first issue in the first page
                this._loadPageAndSelect("first", "first").done(deferred.resolve);
            }
            return deferred.promise();
        },

        parse: function (resp, options) {
            var requestData = options.data;
            var data = resp && resp.issueTable;

            var allIssues = this.allIssues;
            _.each(data.table, function (rawIssue, index) {
                // If an issue is missing from the server, it will contain the value 'null'
                if (rawIssue === null) {
                    // We take advantage of the fact that the order of requestData and the response is the same.
                    var issueId = requestData.id[index];

                    // Search for this particular issue in the list of issues for this search.
                    var oldIssueData = _.findWhere(allIssues, {id: issueId});
                    if (oldIssueData) {
                        // Even if the issue is missing from the server, populate the required fields (id and key)
                        // so all our views, events and url management will continue to work.
                        data.table[index] = {
                            id: oldIssueData.id,
                            key: oldIssueData.key,
                            inaccessible: true
                        };
                    }
                }
            });

            return PageableCollection.prototype.parse.call(this, data);
        },

        parseState: function () {
            return {};
        },

        parseRecords: function (resp) {
            if (resp.table) {
                return resp.table;
            }
            else {
                return [];
            }
        },

        select: function (model) {
            if (typeof model === "string") {
                switch (model) {
                    case "first":
                        model = this.at(0);
                        break;
                    case "last":
                        model = this.at(this.length - 1);
                        break;
                    default:
                        model = this.findWhere({key: model});
                        break;
                }
            } else if (typeof model === "number") {
                model = this.get(model);
            }

            if (this.selected !== model) {
                this.unselect();
            }
            if (!model) {
                return;
            }
            this.selected = model;
            this.selected.trigger("select", this.selected);
        },

        unselect: function () {
            if (this.selected) {
                this.selected.trigger("unselect", this.selected);
            }
            this.selected = null;
        },

        navigate: function (step) {
            var index = this.indexOf(this.selected);
            var newIndex = index + step;
            var model = this.at(newIndex);
            if (model) {
                this.select(model);
            }
            else if (step > 0 && this.hasNextPage()) {
                this._loadPageAndSelect("next", "first");
            } else if (step < 0 && this.hasPreviousPage()) {
                this._loadPageAndSelect("prev", "last");
            }
            return {current: newIndex, total: this.length};
        },

        selectNext: function () {
            return this.navigate(1);
        },

        selectPrev: function () {
            return this.navigate(-1);
        },

        /**
         * Gets the issue based on an offset from the current selected issue.
         * @param {number} offset Offset (eg: '1' gets the next issue, '-1' gets the previous issue)
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         * @private
         */
        _getIssueByNavigation: function(offset) {
            var index = this.indexOf(this.selected);
            var newIndex = index + offset;
            var model = this.at(newIndex);
            var deferred = new jQuery.Deferred();

            if (model) {
                this.select(model);
                deferred.resolve(model);
            } else if (offset > 0 && this.hasNextPage()) {
                this._loadPageAndSelect("next", "first").done(function() {
                    deferred.resolve(this.selected);
                }.bind(this));
            } else if (offset < 0 && this.hasPreviousPage()) {
                this._loadPageAndSelect("prev", "last").done(function() {
                    deferred.resolve(this.selected);
                }.bind(this));
            } else {
                deferred.reject();
            }

            return deferred.promise();
        },

        /**
         * Gets the next issue
         *
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         */
        getNextIssue: function() {
            return this._getIssueByNavigation(1);
        },

        /**
         * Gets the previous issue
         *
         * @returns {jQuery.Promise} Promise that will be resolved with the selected issue, or rejected if the issue
         *          does not exist.
         */
        getPreviousIssue: function() {
            return this._getIssueByNavigation(-1);
        },

        updateSelectedIssue: function () {
            if (this.selected) {
                this.selected.fetch();
            }
        },

        updateIssue: function(issueId) {
            var issue = this.get(issueId);
            if (issue) {
                issue.fetch();
            }
        },

        hasIssueInSearch: function (issueKey) {
            return !!_.where(this.allIssues, {key: issueKey}).length;
        },

        isEmptySearch: function () {
            return !this.allIssues.length;
        },

        /**
         * This method removes the model from the collection. If the model was selected, it will
         * try to select a new issue based on the following algorithm:
         *
         *  * If there is a next issue, select it. ...
         *  * If there is a previous issue, select it. Else...
         *  * The list is empty, select nothing
         *
         * @param {JIRA.Components.Search.Result} model Issue to delete
         */
        removeAndUpdateSelectionIfNeeded: function (model) {
            var issueKey = model.get('key');
            var issueToSelectAfterRemoveOperation;
            var allKeys = _.chain(this.allIssues).map(function (issue) {return issue.key;}).value();
            var currentIndex = _.indexOf(allKeys, issueKey);
            var hasNext = currentIndex + 1 < allKeys.length;
            var hasPrevious = currentIndex - 1 >= 0;

            if (hasNext) {
                issueToSelectAfterRemoveOperation = allKeys[currentIndex + 1];
            }
            else if (hasPrevious) {
                issueToSelectAfterRemoveOperation = allKeys[currentIndex - 1];
            }
            else {
                // There are no more issues, select nothing
                issueToSelectAfterRemoveOperation = null;
            }

            // Remove the issue from this.allIssues
            for (var i = 0; i < this.allIssues.length; i++) {
                var issue = this.allIssues[i];
                if (issue.key === issueKey) {
                    this.allIssues.splice(i, 1);
                    break;
                }
            }

            // Remove the issue from the pagination related counters
            this.state.totalRecords = this.state.totalRecords - 1;
            this.totalRecordsInDB = this.totalRecordsInDB - 1;

            // Unselect and remove it
            this.unselect();
            this.remove(model);

            // If we have an issue to select after the remove operation, load its page
            if (issueToSelectAfterRemoveOperation) {
                return this.jumpToPageForIssue(issueToSelectAfterRemoveOperation).done(_.bind(function() {
                    this.trigger("issueDeleted");
                }, this));
            } else {
                return new jQuery.Deferred().resolve(0).promise().done(_.bind(function() {
                    this.trigger("issueDeleted");
                }, this));
            }
        },

        getIssueKeyForIndex: function(index) {
            var issue = this.allIssues[index];
            if(!issue) return;

            return issue.key;
        },

        getIssueAtGlobalIndex: function(index) {
            return this.allIssues[index];
        },


        getPositionOfIssueInSearchResults: function(issueId) {
            var position = _.indexOf(_.pluck(this.allIssues, 'id'), issueId);
            if (position > -1) {
                return position;
            } else {
                return null;
            }
        },

        getPositionOfIssueInPage: function(issueId) {
            var model = this.get(issueId);
            var position = this.indexOf(model);
            if (position > -1) {
                return position;
            } else {
                return null;
            }
        },

        /**
         * @deprecated In JIRA 7.0. Will be removed in JIRA 8.0. Use getTotalIssuesInSearch() instead;
         */
        getTotalIssues: function() {
            return this.getTotalIssuesInSearch();
        },

        getTotalIssuesInSearch: function() {
            return this.allIssues.length;
        },

        getTotalIssuesInDb: function() {
            return this.totalRecordsInDB;
        }
    });

    AJS.deprecate.prop(Results.prototype, 'getTotalIssues', {
        removeInVersion: '8.0',
        alternativeName: 'jira/components/search/results#getTotalIssuesInSearch()',
        sinceVersion: '7.1',
        displayName: "Method jira/components/search/results#getTotalIssues()"
    });

    return Results;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:brace', location = '/inline-issue-create/lib/backbone.brace/backbone.brace-amd.js' */
define("jira/inline-issue-create/lib/backbone", [
    "atlassian/libs/factories/backbone-1.0.0",
    "atlassian/libs/underscore-1.5.2",
    "jquery"

], function(backboneFactory, _, $){
    return backboneFactory(_, $);
});

define("jira/inline-issue-create/lib/brace", [
    "jira/inline-issue-create/lib/backbone",
    "atlassian/libs/underscore-1.5.2",
    "atlassian/libs/factories/brace-2014.09.03"
], function(backbone, _, braceFactory) {
    "use strict";
    return braceFactory(_, Backbone);
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:marionette', location = '/inline-issue-create/lib/backbone.marionette/backbone.marionette-amd.js' */
define("jira/inline-issue-create/lib/marionette", [
    "jquery",
    "jira/inline-issue-create/lib/backbone",
    "atlassian/libs/underscore-1.5.2",
    "atlassian/libs/factories/marionette-2.1.0"
], function($, Backbone, _, marionetteFactory) {
    "use strict";
    var Marionette =  marionetteFactory(_, Backbone);

    /**
     * This method unwraps the Backbone.View.
     *
     * By default, Backbone will create a <di`v> and render the template inside. By calling this
     * method, you can get rid of that <div>, so the main element in your template will be the
     * root element in your template.
     */
    var extensions = {
        unwrapTemplate: function unwrapTemplate() {
            var children = this.$el.children();
            if (children.length > 1) {
                AJS.warn("[IIC] Unwrapping template with more than one child - some content will be lost");
            }

            var child = $(children.get(0));
            if (this.$el.parent().length) {
                // If the template is already rendered in the page
                this.$el.replaceWith(child);
                this.setElement(child);
            } else {
                // If the template is in memory
                this.setElement(child);
            }
        }
    };

    _.extend(Marionette.ItemView.prototype, extensions);
    _.extend(Marionette.CompositeView.prototype, extensions);
    _.extend(Marionette.CollectionView.prototype, extensions);
    _.extend(Marionette.LayoutView.prototype, extensions);

    return Marionette;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:placeholder', location = '/inline-issue-create/lib/jquery-placeholder.js' */
/*! MIT License - https://github.com/mathiasbynens/jquery-placeholder/blob/master/LICENSE-MIT.txt */
/*! http://mths.be/placeholder v2.0.8 by @mathias */
;(function(window, document, $) {

    // Opera Mini v7 doesnt support placeholder although its DOM seems to indicate so
    var isOperaMini = Object.prototype.toString.call(window.operamini) == '[object OperaMini]';
    var isInputSupported = 'placeholder' in document.createElement('input') && !isOperaMini;
    var isTextareaSupported = 'placeholder' in document.createElement('textarea') && !isOperaMini;
    var prototype = $.fn;
    var valHooks = $.valHooks;
    var propHooks = $.propHooks;
    var hooks;
    var placeholder;

    if (isInputSupported && isTextareaSupported) {

        placeholder = prototype.placeholder = function() {
            return this;
        };

        placeholder.input = placeholder.textarea = true;

    } else {

        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this
                .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
                .not('.placeholder')
                .bind({
                    'focus.placeholder': clearPlaceholder,
                    'blur.placeholder': setPlaceholder
                })
                .data('placeholder-enabled', true)
                .trigger('blur.placeholder');
            return $this;
        };

        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;

        hooks = {
            'get': function(element) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value;
                }

                return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
            },
            'set': function(element, value) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value = value;
                }

                if (!$element.data('placeholder-enabled')) {
                    return element.value = value;
                }
                if (value == '') {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != safeActiveElement()) {
                        // We can't use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass('placeholder')) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };

        if (!isInputSupported) {
            valHooks.input = hooks;
            propHooks.value = hooks;
        }
        if (!isTextareaSupported) {
            valHooks.textarea = hooks;
            propHooks.value = hooks;
        }

        $(function() {
            // Look for forms
            $(document).delegate('form', 'submit.placeholder', function() {
                // Clear the placeholder values so they don't get submitted
                var $inputs = $('.placeholder', this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });

        // Clear placeholder values upon page reload
        $(window).bind('beforeunload.placeholder', function() {
            $('.placeholder').each(function() {
                this.value = '';
            });
        });

    }

    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {};
        var rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }

    function clearPlaceholder(event, value) {
        var input = this;
        var $input = $(input);
        if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
            if ($input.data('placeholder-password')) {
                $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = '';
                $input.removeClass('placeholder');
                input == safeActiveElement() && input.select();
            }
        }
    }

    function setPlaceholder() {
        var $replacement;
        var input = this;
        var $input = $(input);
        var id = this.id;
        if (input.value == '') {
            if (input.type == 'password') {
                if (!$input.data('placeholder-textinput')) {
                    try {
                        $replacement = $input.clone().attr({ 'type': 'text' });
                    } catch(e) {
                        $replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
                    }
                    $replacement
                        .removeAttr('name')
                        .data({
                            'placeholder-password': $input,
                            'placeholder-id': id
                        })
                        .bind('focus.placeholder', clearPlaceholder);
                    $input
                        .data({
                            'placeholder-textinput': $replacement,
                            'placeholder-id': id
                        })
                        .before($replacement);
                }
                $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
                // Note: `$input[0] != input` now!
            }
            $input.addClass('placeholder');
            $input[0].value = $input.attr('placeholder');
        } else {
            $input.removeClass('placeholder');
        }
    }

    function safeActiveElement() {
        // Avoid IE9 `document.activeElement` of death
        // https://github.com/mathiasbynens/jquery-placeholder/pull/99
        try {
            return document.activeElement;
        } catch (exception) {}
    }

}(this, document, jQuery));;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:util', location = '/inline-issue-create/util/util.js' */
/*globals console*/
define('jira/inline-issue-create/util', [
    'jquery'
], function(
    $
) {
    "use strict";

    var bodyStyle = (document.body || document.documentElement).style;
    var eventNames = ["oAnimationEnd", "MSAnimationEnd", "mozAnimationEnd", "webkitAnimationEnd", "animationend"];

    var logFilter;

    return {
        cssAnimationsSupport: bodyStyle.transition !== undefined || bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.MsTransition !== undefined || bodyStyle.OTransition !== undefined,
        addClassAndRemoveOnAnimationEnd: function addClassAndRemoveOnAnimationEnd(el, className, durationInMilis) {
            var i;
            el = $(el);

            function listener() {
                for (i = 0; i < eventNames.length; i++) {
                    el.off(eventNames[i], listener);
                }
                el.removeClass(className);
            }

            if (this.cssAnimationsSupport) {
                for (i = 0; i < eventNames.length; i++) {
                    el.on(eventNames[i], listener);
                }
            } else {
                setTimeout(function() {
                    el.removeClass(className);
                }, durationInMilis || 1000);
            }
            el.addClass(className);
        },
        scrollElementToView: function scrollElementToView($scrollingContainer, $element) {
            var viewportRect = $scrollingContainer[0].getBoundingClientRect();
            var elementRect = $element[0].getBoundingClientRect();

            var containerScrollTop = $scrollingContainer.scrollTop();
            var scrollOffset = 0;
            if (elementRect.top < viewportRect.top) {
                // the element is before the view port begining
                scrollOffset = elementRect.top - viewportRect.top;
            } else if (viewportRect.bottom < elementRect.bottom) {
                // the element is after the view port ending
                scrollOffset = elementRect.bottom - viewportRect.bottom;
            }

            if (scrollOffset !== 0) {
                $scrollingContainer.scrollTop(containerScrollTop + scrollOffset);
            }
        },
        keyCode: {
            ENTER: 13,
            ESC: 27
        },
        after: function after(object, method, body) {
            if (!_.isFunction(body)) {
                throw "Body is not a function";
            }
            object[method] = _.wrap(object[method], function wrapper(originalFunction) {
                var originalArguments = Array.prototype.slice.call(arguments, 1);
                var result = originalFunction.apply(object, originalArguments);
                body.apply(this, _.union([result], originalArguments));
                return result;
            });
        },

        /**
         *
         * @param object
         * @param {...*} message
         */
        error: function error(object) {
            if (console && console.error) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (_.isString(args[0])) {
                    args[0] = "[IIC]" + args[0];
                }
                console.error.apply(console, args);
            }
        },        /**
         *
         * @param object
         * @param {...*} message
         */
        debug: function debug(object) {
            if(this.shouldDisplay(object)){
                if (console && console.debug) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (_.isString(args[0])) {
                        args[0] = "[IIC]" + args[0];
                    }
                    console.debug.apply(console, args);
                }
            }
        },
         /*
         * @param object
         * @param {...*} message
         */
        trace: function trace(object) {
            if(this.shouldDisplay(object)){
                if (console && console.debug) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (_.isString(args[0])) {
                        args[0] = "[IIC]" + args[0];
                    }
                    console.debug.apply(console, args);
                }
            }
        },
        shouldDisplay: function(object) {
            if(logFilter === "all" || object === logFilter) {
                return true;
            }
            return false;
        },
        showLogsFor: function showLogsFor(object) {
            logFilter = object;
        }
    };
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/custom-form-container-factory.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {
    "use strict";

    var build = function () {
        var JiraFormsContainer = JIRA.Forms.Container;

        return JiraFormsContainer.extend({
            lazyInit: function lazyInit() {
                var options = this.options.call(this);
                this.prefilledValues = options.prefilledValues;
                this.prefilledValues.fieldsToRetain = _.keys(options.prefilledValues);
                this.prefilledValues =  $.param(options.prefilledValues);

                // Override options to just return what was evaluated and not evaluate it twice.
                // This way extra objects won't get created when super tries to call options again .
                this.options = function overridenOpitons() {
                    return options;
                };
                return this._super();
            },
            /**
             * Renders quick form. What is actually rendered is based apon user configuration. Full form will be showed first,
             * but if user switches to configurable form that will be persisted.
             *
             * It was extended, to use values retrieved from inline issue create JQL context.
             *
             * @return jQuery.Deferred
             */
            render: function render() {
                var instance = this,
                    deferred = $.Deferred();
                // re-evaluate options
                this.lazyInit();

                // values provided from context should be treated as they were provided by user
                // for backwards compatibility reasons check whether method is there
                if(_.isFunction(instance.model.markFieldAsDirty)) {
                    Object.keys(this.options().prefilledValues).forEach(function(key) {
                        instance.model.markFieldAsDirty(key);
                    });
                }

                instance.model.getUseConfigurableForm().done(function getUseConfigurableFormDone(answer) {
                    if (answer === true) {
                        instance.configurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element]);
                            instance.$element.append(scripts);
                        });
                    } else {
                        instance.unconfigurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element, scripts]);
                            instance.$element.append(scripts);
                        });
                    }
                }).fail(function getUseConfigurableFormFailed() {
                    deferred.resolveWith(instance, [instance.$element]);
                });

                return deferred.promise();
            }
        });
    };
    return {build: build};
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/prefillable-create-issue-dialog-init-form.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog/init-form', [
    'underscore',
    'jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory'
], function (
    _,
    CustomFormContainerFactory
) {
    "use strict";

    /**
     * Initializes the JIRA.Forms.Container form and resolves passed deferred param with JIRA.Forms.Container.
     *
     * @param {jQuery.Deferred} deferred - Deferred that is resolved to the JIRA.Forms.Container form after the WRM resources have been downloaded and the form is ready to be displayed. Can be used to asynchronously show the form when all resources are downloaded.
     * @param {jQuery.Promise} fieldValuesRetrieved - Promise that is resolved with form parameters obtained from rest resource. The parameters are needed to ensure that the issue created will satisfy the actual JQL entered by user.
     */
    return function (deferred, fieldValuesRetrieved)  {
        if (!_.isObject(fieldValuesRetrieved)) {
            throw new Error("You must provide promise that will resolve with fieldValues to create this form. Use standard create issue form if you have none.");
        }

        var JiraFormsCreateIssueModel = JIRA.Forms.CreateIssueModel;
        var JiraFormsConfigurableCreateIssueForm = JIRA.Forms.ConfigurableCreateIssueForm;
        var JiraFormsUnconfigurableCreateIssueForm = JIRA.Forms.UnconfigurableCreateIssueForm;
        var JiraFormsCreateIssueError = JIRA.Forms.CreateIssueError;
        var applyErrorsToForm = JIRA.applyErrorsToForm;
        var applyErrorMessageToForm = JIRA.applyErrorMessageToForm;

        var data;
        fieldValuesRetrieved.done(function whenInitializedAndHasFields(responseData) {
            data = responseData;

            data.prefilledFields = data.prefilledFields || {};
            data.errors = data.errors || {};
            data.errorMessages = data.errorMessages || {};
        }).fail(function whenFailedInitialization() {
            data = {
                prefilledFields: {},
                errors: {},
                errorMessages: {}
            };
        });

        // Copied from Quick Edit plugin to override the title
        var CustomFormContainer = CustomFormContainerFactory.build();
        var form = new CustomFormContainer(function containerInitFunction() {
            var containerOptions = {
                title: "Create Issue",
                id: "prefillable-create-issue-dialog",
                globalEventNamespaces: ["PrefillableCreateIssueDialog"],
                issueType: undefined // we will set that later when context is resolved
            };

            // model that gets fields and sets user preferences
            var model = new JiraFormsCreateIssueModel({
                projectId: undefined, // we will set that later when context is resolved
                issueType: undefined // we will set that later when context is resolved
            });

            var configurableForm = new JiraFormsConfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            var unconfigurableForm = new JiraFormsUnconfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            return {
                globalEventNamespaces: containerOptions.globalEventNamespaces,
                model: model,
                errorHandler: new JiraFormsCreateIssueError(),
                configurableForm: configurableForm,
                unconfigurableForm: unconfigurableForm,
                // when this variable is used it will be already defined because
                // this function isn't called until AFTER fieldValuesRetrieved is resolved
                prefilledValues: data.prefilledFields
            };
        });

        var dialog = form.asDialog({
            windowTitle: "Create Issue",
            id: "prefillable-create-issue-dialog"
        });

        // we can modify dialog's options after creation, specifically the
        // delayShowUntil option, as it is used in the show method for the first time
        dialog.options.delayShowUntil = function delayShowUntilFieldValuesRetrieved() {
            return fieldValuesRetrieved;
        };

        form.asDialog = function asDialog() {
            return form.dialog;
        };

        dialog.onContentReady(function formInitialized() {
            if (_.keys(data.errors).length) {
                // add global error message indicating that there are field errors            }
                data.errorMessages.unshift("Please fix the fields marked below.");
                // add per-field error messages
                applyErrorsToForm(form.$element, data.errors);
            }
            if (data.errorMessages.length) {
                // add global error message, join multiple messsages with <br> if needed
                applyErrorMessageToForm(form.$element, data.errorMessages.join("<br/>"));
            }
        });

        deferred.resolve(form);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-preffilable-create-issue-dialog', location = '/inline-issue-create/components/prefillable-create-issue-dialog/prefillable-create-issue-dialog.js' */
define('jira/inline-issue-create/prefillable-create-issue-dialog', [
    'wrm/require',
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/loading/loading',
    'jira/flag',
    'jira/inline-issue-create/prefillable-create-issue-dialog/init-form'
], function (
    wrmRequire,
    $,
    _,
    Marionette,
    Loading,
    Flag,
    initForm
) {
    "use strict";

    var ajsDim = AJS.dim;
    var ajsUndim = AJS.undim;

    var showLoadingIndicator = function () {
        ajsDim();
        Loading.showLoadingIndicator();
    };
    var hideLoadingIndicator = function () {
        ajsUndim();
        Loading.hideLoadingIndicator();
    };

    /**
     * Factory to create Create Issue Form promise
     *
     * @return promise that is resolved with JIRA.Forms.Container
     */
    var createPrefillableCreateIssueForm = function createPrefillableCreateIssueForm(
        fieldValuesRetrieved,
        shouldShowLoadingIndicator
    ) {
        var deferred = new $.Deferred();

        if (shouldShowLoadingIndicator) {
            showLoadingIndicator();
        }

        wrmRequire(['wr!com.atlassian.jira.jira-quick-edit-plugin:quick-create-issue'], initForm.bind(undefined, deferred, fieldValuesRetrieved)).fail(function () {
            if (shouldShowLoadingIndicator) {
                hideLoadingIndicator();
            }
            Flag.showErrorMsg(null, "The JIRA server could not be contacted. This may be a temporary glitch or the server may be down.");
        });

        return deferred.promise();
    };

    return {
        createPrefillableCreateIssueForm: createPrefillableCreateIssueForm
    };
});

define('jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory', [
    'jquery',
    'underscore'
], function (
    $,
    _
) {
    "use strict";

    var JiraFormsContainer = JIRA.Forms.Container;

    var build = function () {
        return JiraFormsContainer.extend({
            lazyInit: function lazyInit() {
                var options = this.options.call(this);
                this.prefilledValues = options.prefilledValues;
                this.prefilledValues.fieldsToRetain = _.keys(options.prefilledValues);
                this.prefilledValues =  $.param(options.prefilledValues);

                // Override options to just return what was evaluated and not evaluate it twice.
                // This way extra objects won't get created when super tries to call options again .
                this.options = function overridenOpitons() {
                    return options;
                };
                return this._super();
            },
            /**
             * Renders quick form. What is actually rendered is based apon user configuration. Full form will be showed first,
             * but if user switches to configurable form that will be persisted.
             *
             * It was extended, to use values retrieved from inline issue create JQL context.
             *
             * @return jQuery.Deferred
             */
            render: function render() {
                var instance = this,
                    deferred = $.Deferred();
                // re-evaluate options
                this.lazyInit();

                // values provided from context should be treated as they were provided by user
                // for backwards compatibility reasons check whether method is there
                if(_.isFunction(instance.model.markFieldAsDirty)) {
                    Object.keys(this.options().prefilledValues).forEach(function(key) {
                        instance.model.markFieldAsDirty(key);
                    });
                }

                instance.model.getUseConfigurableForm().done(function getUseConfigurableFormDone(answer) {
                    if (answer === true) {
                        instance.configurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element]);
                            instance.$element.append(scripts);
                        });
                    } else {
                        instance.unconfigurableForm.render(instance.prefilledValues).done(function rendered(el, scripts) {
                            deferred.resolveWith(instance, [instance.$element, scripts]);
                            instance.$element.append(scripts);
                        });
                    }
                }).fail(function getUseConfigurableFormFailed() {
                    deferred.resolveWith(instance, [instance.$element]);
                });

                return deferred.promise();
            }
        });
    };
    return {build: build};
});

define('jira/inline-issue-create/prefillable-create-issue-dialog/ondone', [
    'underscore',
    'jira/inline-issue-create/prefillable-create-issue-dialog/custom-form-container-factory'
], function (
    _,
    CustomFormContainerFactory
) {
    "use strict";

    var JiraFormsCreateIssueModel = JIRA.Forms.CreateIssueModel;
    var JiraFormsConfigurableCreateIssueForm = JIRA.Forms.ConfigurableCreateIssueForm;
    var JiraFormsUnconfigurableCreateIssueForm = JIRA.Forms.UnconfigurableCreateIssueForm;
    var JiraFormsCreateIssueError = JIRA.Forms.CreateIssueError;
    var applyErrorsToForm = JIRA.applyErrorsToForm;
    var applyErrorMessageToForm = JIRA.applyErrorMessageToForm;

    return function (deferred, fieldValuesRetrieved)  {
        if (!_.isObject(fieldValuesRetrieved)) {
            throw new Error("You must provide promise that will resolve with fieldValues to create this form. Use standard create issue form if you have none.");
        }

        var data;
        fieldValuesRetrieved.done(function whenInitializedAndHasFields(responseData) {
            data = responseData;

            data.prefilledFields = data.prefilledFields || {};
            data.errors = data.errors || {};
            data.errorMessages = data.errorMessages || {};
        }).fail(function whenFailedInitialization() {
            data = {
                prefilledFields: {},
                errors: {},
                errorMessages: {}
            };
        });

        // Copied from Quick Edit plugin to override the title
        var CustomFormContainer = CustomFormContainerFactory.build();
        var form = new CustomFormContainer(function containerInitFunction() {
            var containerOptions = {
                title: "Create Issue",
                id: "prefillable-create-issue-dialog",
                globalEventNamespaces: ["PrefillableCreateIssueDialog"],
                issueType: undefined // we will set that later when context is resolved
            };

            // model that gets fields and sets user preferences
            var model = new JiraFormsCreateIssueModel({
                projectId: undefined, // we will set that later when context is resolved
                issueType: undefined // we will set that later when context is resolved
            });

            var configurableForm = new JiraFormsConfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            var unconfigurableForm = new JiraFormsUnconfigurableCreateIssueForm({
                model: model,
                title: containerOptions.title,
                globalEventNamespaces: containerOptions.globalEventNamespaces
            });

            return {
                globalEventNamespaces: containerOptions.globalEventNamespaces,
                model: model,
                errorHandler: new JiraFormsCreateIssueError(),
                configurableForm: configurableForm,
                unconfigurableForm: unconfigurableForm,
                // when this variable is used it will be already defined because
                // this function isn't called until AFTER fieldValuesRetrieved is resolved
                prefilledValues: data.prefilledFields
            };
        });

        var dialog = form.asDialog({
            windowTitle: "Create Issue",
            id: "prefillable-create-issue-dialog"
        });

        // we can modify dialog's options after creation, specifically the
        // delayShowUntil option, as it is used in the show method for the first time
        dialog.options.delayShowUntil = function delayShowUntilFieldValuesRetrieved() {
            return fieldValuesRetrieved;
        };

        form.asDialog = function asDialog() {
            return form.dialog;
        };

        dialog.onContentReady(function formInitialized() {
            if (_.keys(data.errors).length) {
                // add global error message indicating that there are field errors            }
                data.errorMessages.unshift("Please fix the fields marked below.");
                // add per-field error messages
                applyErrorsToForm(form.$element, data.errors);
            }
            if (data.errorMessages.length) {
                // add global error message, join multiple messsages with <br> if needed
                applyErrorMessageToForm(form.$element, data.errorMessages.join("<br/>"));
            }
        });

        deferred.resolve(form);
    };
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget.soy' */
// This file was automatically generated from inline-issue-create-widget.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.InlineIssueCreate.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.InlineIssueCreate == 'undefined') { JIRA.Templates.InlineIssueCreate = {}; }


JIRA.Templates.InlineIssueCreate.trigger = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="iic' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '"><div class="iic-trigger"><button type="button">' + soy.$$escapeHtml("Create issue") + '</button></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.trigger.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.trigger';
}


JIRA.Templates.InlineIssueCreate.widget = function(opt_data, opt_ignored) {
  opt_data = opt_data || {};
  return '<div class="iic-widget' + ((opt_data.cssClass) ? ' ' + soy.$$escapeHtml(opt_data.cssClass) : '') + '"><form action="#" method="POST" class="iic-widget__form aui"><div class="iic-widget__issue-type-selector-container"></div><div><textarea name="summary" rows="1" cols="50" maxlength="255" class="iic-widget__summary" placeholder="' + soy.$$escapeHtml("What needs to be done?") + '">' + ((opt_data.summary) ? soy.$$escapeHtml(opt_data.summary) : '') + '</textarea><div class="iic-widget__footer"><div class="iic-widget__description-container"></div><button type="button" class="aui-button aui-button-subtle iic-widget__more" title="' + soy.$$escapeHtml("Open create dialog") + '"><span class="aui-icon aui-icon-small aui-iconfont-more">' + soy.$$escapeHtml("More") + '</span></button><button type="button" class="aui-button aui-button-link iic-widget__cancel">' + soy.$$escapeHtml("Cancel") + '</button></div></div></form></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.widget.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.widget';
}


JIRA.Templates.InlineIssueCreate.issueTypeSelector = function(opt_data, opt_ignored) {
  return '<div class="iic-widget__issue-type-selector"><button type="button" class="iic-widget__issue-type-selector__trigger aui-dropdown2-trigger" aria-owns="iic-issue-type-dropdown-' + soy.$$escapeHtml(opt_data.widgetId) + '" aria-haspopup="true">' + ((! opt_data.isLocked) ? '<img src="' + soy.$$escapeHtml(opt_data.issueTypeIconUrl) + '" width="16" height="16" />' : '<img src="data:image/gif;base64,R0lGODlhEAAQAMQAAP///+7u7t3d3bu7u6qqqpmZmYiIiHd3d2ZmZlVVVURERDMzMyIiIhEREQARAAAAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBwAQACwAAAAAEAAQAAAFdyAkQgGJJOWoQgIjBM8jkKsoPEzgyMGsCjPDw7ADpkQBxRDmSCRetpRA6Rj4kFBkgLC4IlUGhbNQIwXOYYWCXDufzYPDMaoKGBoKb886OjAKdgZAAgQkfCwzAgsDBAUCgl8jAQkHEAVkAoA1AgczlyIDczUDA2UhACH5BAUHABAALAAAAAAPABAAAAVjICSO0IGIATkqIiMKDaGKC8Q49jPMYsE0hQdrlABCGgvT45FKiRKQhWA0mPKGPAgBcTjsspBCAoH4gl+FmXNEUEBVAYHToJAVZK/XWoQQDAgBZioHaX8igigFKYYQVlkCjiMhACH5BAUHABAALAAAAAAQAA8AAAVgICSOUGGQqIiIChMESyo6CdQGdRqUENESI8FAdFgAFwqDISYwPB4CVSMnEhSej+FogNhtHyfRQFmIol5owmEta/fcKITB6y4choMBmk7yGgSAEAJ8JAVDgQFmKUCCZnwhACH5BAUHABAALAAAAAAQABAAAAViICSOYkGe4hFAiSImAwotB+si6Co2QxvjAYHIgBAqDoWCK2Bq6A40iA4yYMggNZKwGFgVCAQZotFwwJIF4QnxaC9IsZNgLtAJDKbraJCGzPVSIgEDXVNXA0JdgH6ChoCKKCEAIfkEBQcAEAAsAAAAABAADgAABUkgJI7QcZComIjPw6bs2kINLB5uW9Bo0gyQx8LkKgVHiccKVdyRlqjFSAApOKOtR810StVeU9RAmLqOxi0qRG3LptikAVQEh4UAACH5BAUHABAALAAAAAAQABAAAAVxICSO0DCQKBQQonGIh5AGB2sYkMHIqYAIN0EDRxoQZIaC6bAoMRSiwMAwCIwCggRkwRMJWKSAomBVCc5lUiGRUBjO6FSBwWggwijBooDCdiFfIlBRAlYBZQ0PWRANaSkED1oQYHgjDA8nM3kPfCmejiEAIfkEBQcAEAAsAAAAABAAEAAABWAgJI6QIJCoOIhFwabsSbiFAotGMEMKgZoB3cBUQIgURpFgmEI0EqjACYXwiYJBGAGBgGIDWsVicbiNEgSsGbKCIMCwA4IBCRgXt8bDACkvYQF6U1OADg8mDlaACQtwJCEAIfkEBQcAEAAsAAABABAADwAABV4gJEKCOAwiMa4Q2qIDwq4wiriBmItCCREHUsIwCgh2q8MiyEKODK7ZbHCoqqSjWGKI1d2kRp+RAWGyHg+DQUEmKliGx4HBKECIMwG61AgssAQPKA19EAxRKz4QCVIhACH5BAUHABAALAAAAAAQABAAAAVjICSOUBCQqHhCgiAOKyqcLVvEZOC2geGiK5NpQBAZCilgAYFMogo/J0lgqEpHgoO2+GIMUL6p4vFojhQNg8rxWLgYBQJCASkwEKLC17hYFJtRIwwBfRAJDk4ObwsidEkrWkkhACH5BAUHABAALAAAAQAQAA8AAAVcICSOUGAGAqmKpjis6vmuqSrUxQyPhDEEtpUOgmgYETCCcrB4OBWwQsGHEhQatVFhB/mNAojFVsQgBhgKpSHRTRxEhGwhoRg0CCXYAkKHHPZCZRAKUERZMAYGMCEAIfkEBQcAEAAsAAABABAADwAABV0gJI4kFJToGAilwKLCST6PUcrB8A70844CXenwILRkIoYyBRk4BQlHo3FIOQmvAEGBMpYSop/IgPBCFpCqIuEsIESHgkgoJxwQAjSzwb1DClwwgQhgAVVMIgVyKCEAIfkECQcAEAAsAAAAABAAEAAABWQgJI5kSQ6NYK7Dw6xr8hCw+ELC85hCIAq3Am0U6JUKjkHJNzIsFAqDqShQHRhY6bKqgvgGCZOSFDhAUiWCYQwJSxGHKqGAE/5EqIHBjOgyRQELCBB7EAQHfySDhGYQdDWGQyUhADs=" width="16" height="16" />') + '</button><div id="iic-issue-type-dropdown-' + soy.$$escapeHtml(opt_data.widgetId) + '" class="aui-dropdown2 aui-style-default iic-widget__issue-type-selector__dropdown"><div class="aui-dropdown2-section"><ul class="aui-list-truncate"></ul></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.issueTypeSelector.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.issueTypeSelector';
}


JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem = function(opt_data, opt_ignored) {
  return '<li><a href="#" class="aui-icon-container" data-id="' + soy.$$escapeHtml(opt_data.id) + '" style="background-image: url(\'' + soy.$$escapeHtml(opt_data.iconUrl) + '\');">' + soy.$$escapeHtml(opt_data.name) + '</a></li>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem';
}


JIRA.Templates.InlineIssueCreate.description = function(opt_data, opt_ignored) {
  return '<div class="iic-widget__description' + ((! opt_data.issueTypeName) ? ' iic-widget__description_invisible' : '') + '">' + soy.$$escapeHtml("New") + ' <span class="iic-widget__description__selected-issue-type-name">' + ((opt_data.issueTypeName) ? soy.$$escapeHtml(opt_data.issueTypeName) : '') + '</span></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.InlineIssueCreate.description.soyTemplateName = 'JIRA.Templates.InlineIssueCreate.description';
}
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/possibleValues.js' */
define('jira/inline-issue-create/entities/possible-values', [
    'backbone',
    'jira/inline-issue-create/lib/brace'
], function (
    Backbone,
    Brace
) {
    "use strict";

    return Brace.Collection.extend({
        url: function url() {
            var queries = _.map(this.jqls, function (jql) {return "query=" + encodeURIComponent(jql) + "&";});
            return AJS.contextPath() + "/rest/inline-create/1.0/context/possibleValues/" + this.getEntityName() + "?".concat.apply("?", queries);
        },
        getEntityName: undefined,
        initialize: function initialize(attributes, options) {
            this._initializeState(attributes, options);
        },
        _initializeState: function _initializeState(attributes, options) {
            if (options && options.jqls) {
                this.jqls = options.jqls;
            } else {
                this.jqls = undefined;
            }

            this.fetching = false;
            this.initialized = false;
        },
        parse: function parse(response) {
            return response.values;
        },
        setJQLs: function settJQLs(jqls) {
            if (_.isEqual(this.jqls, jqls)) {
                return;
            }
            this.jqls = jqls;
            this.fetch({reset: true});
        },
        reset: function reset() {
            this.fetching = false;
            this.initialized = true;
            return Backbone.Collection.prototype.reset.apply(this, arguments);
        },
        fetch: function fetch(options) {
            var collection = this;

            function triggerFetched() {
                collection.fetching = false;
                collection.initialized = true;
                collection.trigger("fetch:finished");
            }

            options = options || {};
            if (options.success) {
                options.success = _.wrap(options.success, function successWrapper(originalSuccessHandler) {
                    triggerFetched();
                    return originalSuccessHandler.apply(collection, Array.prototype.slice.call(arguments, 1));
                });
            } else {
                options.success = triggerFetched;
            }
            this.trigger("fetch:started");
            this.fetching = true;
            return Backbone.Collection.prototype.fetch.call(this, options);
        },
        isInitialized: function isInitialized() {
            return this.initialized;
        },
        isFetching: function isFetching() {
            return this.fetching;
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/issueType.js' */
define('jira/inline-issue-create/entities/issue-type', [
    'jira/inline-issue-create/lib/brace'
], function (
    Brace
) {
    "use strict";
    var IssueTypeModel = Brace.Model.extend({
        namedAttributes: {
            id: "string",
            name: "string",
            description: "string",
            iconUrl: "string",
            subtask: "boolean"
        }
    });

    return IssueTypeModel;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/issueTypes.js' */
define('jira/inline-issue-create/entities/issue-types', [
    'jira/inline-issue-create/entities/possible-values',
    'jira/inline-issue-create/entities/issue-type'
], function (
    PossibleValues,
    IssueTypeModel
) {
    "use strict";

    return PossibleValues.extend({
        model: IssueTypeModel,
        getEntityName: function () {
            return "issuetype";
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/project.js' */
define('jira/inline-issue-create/entities/project', [
    'jira/inline-issue-create/lib/brace'
], function (
    Brace
) {
    "use strict";
    return Brace.Model.extend({
        namedAttributes: {
            id: "number"
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/projects.js' */
define('jira/inline-issue-create/entities/projects', [
    'jira/inline-issue-create/entities/possible-values',
    'jira/inline-issue-create/entities/project'
], function (
    PossibleValues,
    ProjectModel
) {
    "use strict";

    return PossibleValues.extend({
        model: ProjectModel,
        comparator: function comparator(project) {
            return project.getId();
        },
        getEntityName: function () {
            return "project";
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/inlineIssue.js' */
define('jira/inline-issue-create/entities/inline-issue', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/brace'
], function (
    $,
    _,
    Brace
) {
    "use strict";

    return Brace.Model.extend({
        initialize: function initialize() {
            this._isSaving = false;
        },

        save: function save() {
            var instance = this;
            var deferred = $.ajax(AJS.contextPath() + "/rest/inline-create/1.0/issue", {
                data: JSON.stringify(this.toJSON()),
                contentType: 'application/json',
                type: 'POST'
            });
            this._isSaving = true;
            return deferred.always(function unmarkSending() {
                instance._isSaving = false;
            });
        },

        isSaving: function isSaving() {
            return this._isSaving;
        }
    });
});

;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/inlineBootstrap.js' */
define('jira/inline-issue-create/entities/inline-bootstrap', [
    'backbone',
    'jira/inline-issue-create/lib/brace',
    'jira/inline-issue-create/entities/projects',
    'jira/inline-issue-create/entities/issue-types'
], function (
    Backbone,
    Brace,
    ProjectsCollection,
    IssueTypesCollection
    ) {
    "use strict";

    return Brace.Model.extend({

        issueTypesCollectionType: IssueTypesCollection,
        projectsCollectionType: ProjectsCollection,

        namedAttributes: {
            hasCreateIssuePermission: "boolean",
            hasScheduleIssuePermission: "boolean"
        },

        initialize : function initialize(){
            this.issueTypes = new this.issueTypesCollectionType();
            this.projects = new this.projectsCollectionType();
        },

        url: function url() {
            var queries = _.map(this.jqls, function (jql) {return "query=" + encodeURIComponent(jql) + "&";});
            return AJS.contextPath() + "/rest/inline-create/1.0/context/bootstrap"+ "?".concat.apply("?", queries);
        },
        _initializeState: function _initializeState(attributes, options) {
            if (options && options.jqls) {
                this.jqls = options.jqls;
            } else {
                this.jqls = undefined;
            }

            this.fetching = false;
            this.initialized = false;
        },
        setJQLs: function setJQLs(jqls) {
            if (_.isEqual(this.jqls, jqls)) {
                return;
            }
            this.jqls = jqls;
            this.fetch({reset: true});
        },
        parse: function parse(response) {
            var instance = this;
            // SW-1051 - brace doesn't allow to pass extra attributes
            var issueTypes = _.map(response.issueTypes.values, function(issueType) {
                return _.pick(issueType, _.keys(instance.issueTypes.model.prototype.namedAttributes));
            });
            this.issueTypes.reset(issueTypes);

            var projects = _.map(response.projects.values, function(project) {
                return _.pick(project, _.keys(instance.projects.model.prototype.namedAttributes));
            });
            this.projects.reset(projects);

            return _.pick(response, "hasCreateIssuePermission", "hasScheduleIssuePermission");
        },
        fetch: function fetch(options) {
            var model = this;

            function triggerFetched() {
                model.fetching = false;
                model.initialized = true;
                JIRA.trace("inline.create.bootstrap.fetched");
            }

            options = options || {};
            if (options.success) {
                options.success = _.wrap(options.success, function successWrapper(originalSuccessHandler) {
                    triggerFetched();
                    return originalSuccessHandler.apply(model, Array.prototype.slice.call(arguments, 1));
                });
            } else {
                options.success = triggerFetched;
            }
            this.fetching = true;
            JIRA.trace("inline.create.bootstrap.fetching");
            return Backbone.Model.prototype.fetch.call(this, options);
        },
        isInitialized: function isInitialized() {
            return this.initialized;
        },
        isFetching: function isFetching() {
            return this.fetching;
        },
        fireWhenInitialized: function fireWhenInitialized(func) {
            if(this.isInitialized() && (!this.isFetching())){
                func();
            } else {
                this.listenToOnce(this, "sync", func);
            }
        }
    });
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/description.js' */
define('jira/inline-issue-create/views/description', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var DescriptionView = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.description,
        ui: {
            selectedIssueTypeName: '.iic-widget__description__selected-issue-type-name'
        },
        modelEvents: {
            "change:selectedIssueType": function onSelectedIssueTypeChange() {
                var name = (this.model.getSelectedIssueType() && this.model.getSelectedIssueType().getName()) || "";
                if (name) {
                    this.$el.removeClass("iic-widget__description_invisible");
                    this.ui.selectedIssueTypeName.text(name);
                } else {
                    this.$el.addClass("iic-widget__description_invisible");
                }
            }
        },
        serializeData: function serializeData() {
            var data = {};
            if (this.model.getSelectedIssueType()) {
                data = this.model.getSelectedIssueType().toJSON();
            }
            return {
                issueTypeName: data.name
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

    return DescriptionView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/issueTypeDropdown.js' */
define('jira/inline-issue-create/views/issue-type-dropdown', [
    'jquery',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/views/issue-type-dropdown-item'
], function (
    $,
    Marionette,
    IssueTypeDropdownItemView
) {
    "use strict";

    var IssueTypesDropdown = Marionette.CompositeView.extend({
        childView: IssueTypeDropdownItemView,
        childViewOptions: function itemViewOptions(model, index) {
            return {
                model: model,
                dropdownModel: this.model
            };
        },
        template: JIRA.Templates.InlineIssueCreate.issueTypeSelector,
        childViewContainer: ".aui-list-truncate",
        ui: {
            trigger: '.iic-widget__issue-type-selector__trigger',
            issueTypeIcon: '.iic-widget__issue-type-selector__trigger img',
            issueTypeDropdown: '.iic-widget__issue-type-selector__dropdown'
        },
        events: {
            "focus @ui.trigger": function onTriggerFocus() {
                this.ui.trigger.click();
            }
        },
        modelEvents: {
            "change:selectedIssueType": function onSelectedIssueTypeChange() {
                if (this.model.getSelectedIssueType()) {
                    this.ui.issueTypeIcon.attr("src", this.model.getSelectedIssueType().getIconUrl());
                }
            },
            "change:lockState": function onLockStateChange(m, state) {
                this.render();
                if (state === this.model.constants.STATE_LOCK_SENDING) {
                    this.ui.trigger.attr("aria-disabled", true);
                } else {
                    this.ui.trigger.attr("aria-disabled", false);
                }
            }
        },
        onChildviewSelected: function onChildviewSelected(itemView){
            this.trigger("issueTypeSelected", itemView.model);
        },
        initialize: function initialize() {
            this.isDropdownShown = false;
            _.bindAll(this, 'onDropdownShow', 'onDropdownHide');
        },
        serializeData: function serializeData() {
            var data = {};
            if (this.model.getSelectedIssueType()) {
                data = this.model.getSelectedIssueType().toJSON();
            }

            return {
                widgetId: this.options.widgetId,
                isLocked: this.model.getLockState() !== this.model.constants.STATE_LOCK_UNLOCKED,
                issueTypeIconUrl: data.iconUrl
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.ui.issueTypeDropdown.on("aui-dropdown2-show", this.onDropdownShow);
            this.ui.issueTypeDropdown.on("aui-dropdown2-hide", this.onDropdownHide);
            if (this.isDropdownShown) {
                this.ui.trigger.click();
            }
        },
        onDropdownShow: function onDropdownShow() {
            this.couldYouPositionDropdownRelativelyToIssueTypeIconPleaseThankYouVeryMuch();

            this.isDropdownShown = true;

            // If the collection is currently fetching, we have to hide the dropdown so it dosen't show as empty.
            // We do it with a css change because we want everyone to think it is shown.
            // After the collection finishes fetching we can show the dropdown again as it will have items inside it
            if (this.collection.isFetching()) {
                this.ui.issueTypeDropdown.css("display", "none");
                this.listenToOnce(this.collection, "reset", function collectionFetched() {
                    // we need to make sure we still want to display the dropdown as the user
                    // could do some other action in the time between attaching this listener and it being fired
                    if (this.isDropdownShown) {
                        this.ui.issueTypeDropdown.css("display", "block");
                    }
                });
            }
        },
        onDropdownHide: function onDropdownHide() {
            this.ui.trigger.removeClass("iic-widget__issue-type-selector__trigger_opened-up");
            this.isDropdownShown = false;
        },
        calculateDropdownDirectionAndHeightPosition: function calculateDropdownDirectionAndHeightPosition(){
            var triggerHeight = this.ui.issueTypeIcon.outerHeight();
            var dropdownContentHeight = this.ui.issueTypeDropdown.outerHeight();
            if ($("body").outerHeight(true) < this.ui.issueTypeIcon.offset().top + triggerHeight + dropdownContentHeight) {
                return {
                    vAlignment: "top"
                };
            } else {
                return {
                    vAlignment: "bottom"
                };
            }
        },
        couldYouPositionDropdownRelativelyToIssueTypeIconPleaseThankYouVeryMuch: function positionDropdownRelativelyToIssueTypeIcon() {
            var $dropdown = this.ui.issueTypeDropdown;
            $dropdown.attr("style", "");

            // we don't want dorpdown to be attached to body so we put it back where it was
            $dropdown.appendTo(this.$el);

            var triggerPosition = this.ui.issueTypeIcon.position();
            var triggerHeight = this.ui.issueTypeIcon.outerHeight();
            var dropdownContentHeight = $dropdown.outerHeight();
            var position = this.calculateDropdownDirectionAndHeightPosition();
            var visibleDropdownContentHeight = position.limitHeight ? position.limitHeight : dropdownContentHeight;

            if (position.vAlignment === "top") {
                $dropdown.addClass("aui-dropdown2-alignment-top");
            } else {
                $dropdown.removeClass("aui-dropdown2-alignment-top");
            }

            $dropdown.attr({
                "data-dropdown2-alignment": "left",
                "aria-hidden": "false"
            }).css({
                display: "block",
                left: triggerPosition.left,
                top: ((position.vAlignment === "top") ? triggerPosition.top - visibleDropdownContentHeight : triggerPosition.top + triggerHeight) + "px"
            });

            if(position.limitHeight) {
                $dropdown.css({
                    "max-height": position.limitHeight + "px",
                    "overflow-y": "auto"
                });
            }

            if (position.vAlignment === "top") {
                this.ui.trigger.addClass("iic-widget__issue-type-selector__trigger_opened-up");
            }
        }
    });

    return IssueTypesDropdown;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/issueTypeDropdownItem.js' */
define('jira/inline-issue-create/views/issue-type-dropdown-item', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var ItemView = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.issueTypeSelectorItem,
        initialize: function initialize(options) {
            this.dropdownModel = options.dropdownModel;
        },
        events: {
            "click a": function onClick(e) {
                e.preventDefault();
                this.trigger("selected");
            }
        },
        onRender: function onRender() {
            this.unwrapTemplate();
        }
    });

    return ItemView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/defaultTrigger.js' */
define('jira/inline-issue-create/views/default-trigger', [
    'jquery',
    'jira/inline-issue-create/lib/marionette'
], function (
    $,
    Marionette
) {
    "use strict";

    var DefaultTrigger = Marionette.ItemView.extend({
        template: JIRA.Templates.InlineIssueCreate.trigger,
        ui: {
            trigger: ' .iic-trigger'
        },
        events: {
            "click @ui.trigger": function onClick(e) {
                e.preventDefault();
                this.trigger("selected");
            }
        },
        initialize: function initialize(options) {
            this.widget = options.widget;

            this.listenTo(this.widget, "activated", this.hide);
            this.listenTo(this.widget, "deactivated", this.show);
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            if (this.widget.model.getState() === this.widget.model.constants.STATE_ACTIVE) {
                this.hide();
            }
        },
        hide: function hide() {
            this.ui.trigger.addClass("iic-trigger_hidden");
        },
        show: function show() {
            this.ui.trigger.removeClass("iic-trigger_hidden");
        }
    });

    return DefaultTrigger;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/entities/widget.js' */
define('jira/inline-issue-create/entities/widget-constants', [], function () {
    "use strict";

    var frozenObjectCanNotBeUnfrozenSoGTFO = {
        STATE_CLOSED: "STATE_CLOSED",
        STATE_ACTIVE: "STATE_ACTIVE",
        STATE_LOCK_TEMP_INACTIVE: "STATE_LOCK_TEMP_INACTIVE",
        STATE_LOCK_SENDING: "STATE_LOCK_SENDING",
        STATE_LOCK_PERM_INACTIVE: "STATE_LOCK_PERM_INACTIVE",
        STATE_LOCK_UNLOCKED: "STATE_LOCK_UNLOCKED"
    };
    Object.freeze(frozenObjectCanNotBeUnfrozenSoGTFO); // IE8 is dead!
    return frozenObjectCanNotBeUnfrozenSoGTFO;
});

define('jira/inline-issue-create/entities/widget', [
    'jira/inline-issue-create/lib/brace',
    'jira/inline-issue-create/entities/issue-types',
    'jira/inline-issue-create/entities/issue-type',
    'jira/inline-issue-create/entities/widget-constants'
], function (
    Brace,
    IssueTypesCollection,
    IssueTypeModel,
    WidgetConstants
) {
    "use strict";

    var SELECTED_ISSUE_TYPE_STORAGE_KEY = "iic.slectedIssueType";

    var constants = WidgetConstants;

    var WidgetModel = Brace.Model.extend({

        constants: constants,

        defaults: {
            state: constants.STATE_CLOSED,
            lockState: constants.STATE_LOCK_UNLOCKED
        },

        namedAttributes: {
            "summary": "",
            "selectedIssueType": IssueTypeModel,
            "issueTypes": IssueTypesCollection,
            "state": "",
            "lastState": "",
            "lockState": ""
        },
        initialize: function initialize(attributes) {
            var previouslySelectedIssueTypeJSON;
            var previouslySelectedIssueType;

            if (!attributes || !attributes.selectedIssueType) {
                if (localStorage) {
                    previouslySelectedIssueTypeJSON = JSON.parse(localStorage.getItem(SELECTED_ISSUE_TYPE_STORAGE_KEY)) || {};
                    previouslySelectedIssueTypeJSON = previouslySelectedIssueTypeJSON || {};
                    previouslySelectedIssueType = this.getIssueTypes() && this.getIssueTypes().find(function findIssue(issueType) {
                        return issueType.getId() === previouslySelectedIssueTypeJSON.id;
                    });
                }

                if (previouslySelectedIssueType) {
                    this.setSelectedIssueType(previouslySelectedIssueType);
                } else if (this.getIssueTypes()) {
                    this.setSelectedIssueType(this.getIssueTypes().at(0));
                }
            }

            this.on("change:selectedIssueType", function onSelectedIssueTypeChange(e) {
                var selectedIssueType = this.getSelectedIssueType();
                if (selectedIssueType) {
                    localStorage.setItem(SELECTED_ISSUE_TYPE_STORAGE_KEY, JSON.stringify(selectedIssueType.toJSON()));
                }
            });

            this.listenTo(this.getIssueTypes(), "reset", function onIssueTypesReset() {
                var selectedIssueTypeId = this.getSelectedIssueType() && this.getSelectedIssueType().getId();
                var currentlySelectedIssueTypeInTheCollection;

                if (!selectedIssueTypeId) {
                    selectedIssueTypeId = previouslySelectedIssueTypeJSON.id;
                }

                if (selectedIssueTypeId !== undefined) {
                    currentlySelectedIssueTypeInTheCollection = this.getIssueTypes().get(selectedIssueTypeId);
                    if (currentlySelectedIssueTypeInTheCollection) {
                        // make sure we use the model from the collection, not the one potentially populated from localStorage
                        this.setSelectedIssueType(currentlySelectedIssueTypeInTheCollection);
                    } else {
                        this.setSelectedIssueType(this.getIssueTypes().at(0));
                    }
                } else {
                    this.setSelectedIssueType(this.getIssueTypes().at(0));
                }

            });
        },
        changeState: function changeState(newState) {
            if (newState === this.getState()) {
                return;
            }
            this.setLastState(this.getState());
            this.setState(newState);
        },
        setSelectedIssueTypeIfAvailable: function setSelectedIssueTypeIfAvailable(issueTypeToSelect) {
            if (issueTypeToSelect) {
                var newIssueType = this.getIssueTypes().get(issueTypeToSelect.getId());
                if (newIssueType) {
                    this.setSelectedIssueType(newIssueType);
                }
            }
        },
        toIssueData: function toIssueData() {
            return {
                summary: this.getSummary(),
                issueTypeId: this.getSelectedIssueType() && this.getSelectedIssueType().getId()
            };
        }
    });

    return WidgetModel;
});

;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/views/widget.js' */
define('jira/inline-issue-create/views/widget', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/util'
], function (
    $,
    _,
    Marionette,
    util
) {
    "use strict";
    var ERROR_ANIMATION_LENGTH = 500;

    var WidgetView = Marionette.LayoutView.extend({
        template: JIRA.Templates.InlineIssueCreate.widget,

        regions: {
            issueTypeSelector: ".iic-widget__issue-type-selector-container",
            description: ".iic-widget__description-container"
        },
        ui: {
            summary: '.iic-widget__summary',
            more: '.iic-widget__more',
            cancel: '.iic-widget__cancel',
            form: '.iic-widget__form',
            withTitle: '[title]'
        },
        events: {
            "input @ui.summary": "onSummaryChange",
            "change @ui.summary": "onSummaryChange",
            "keyup @ui.summary": function(e) {
                var value = this.ui.summary.val();
                if (value.length > 255) {
                    this.ui.summary.val(value.substr(0, 255));
                }
                this.onSummaryChange(e);
            },
            "keydown @ui.summary": function onSummaryKeyboard(e) {
                var value = this.ui.summary.val();

                if (e.keyCode === util.keyCode.ENTER) {
                    e.preventDefault();
                    if (value !== "" && value.length <= 255) {
                        if (this.model.getLockState() === this.model.constants.STATE_LOCK_UNLOCKED) {
                            this.ui.summary.blur();
                            this.trigger("createIssue");
                        } else {
                            // TODO unhack this, should reference the appropriate view, probably raise an event to which the view would react
                            util.addClassAndRemoveOnAnimationEnd(this.$(".issue-type-selector"), "iic-error", ERROR_ANIMATION_LENGTH);
                        }
                    } else {
                        util.addClassAndRemoveOnAnimationEnd(this.ui.summary, "iic-error", ERROR_ANIMATION_LENGTH);
                    }
                } else if (e.keyCode === util.keyCode.ESC) {
                    this.trigger("deactivate", {
                        reason: "keypress"
                    });
                } else if (value.length > 255) {
                    util.addClassAndRemoveOnAnimationEnd(this.ui.summary, "iic-error", ERROR_ANIMATION_LENGTH);
                }
            },
            "click @ui.cancel": function onCancelClick(e) {
                e.preventDefault();
                if (this.model.getLockState() !== this.model.constants.STATE_LOCK_SENDING) {
                    this.trigger("deactivate", {
                        reason: "cancel"
                    });
                }

            },
            "click @ui.more": function onMoreClick(e) {
                e.preventDefault();
                if (this.model.getLockState() !== this.model.constants.STATE_LOCK_SENDING) {
                    this.trigger("openFullIssueDialog");
                }
            }
        },
        modelEvents: {
            "change:summary": function onSummaryChange() {
                this.ui.summary.val(this.model.getSummary());
                this.adjustSummarySize();
            },
            "change:state": function onStateChange(model, state) {
                if (state === this.model.constants.STATE_ACTIVE) {
                    this.activate();
                } else if (state === this.model.constants.STATE_CLOSED) {
                    this.deactivate();
                }
            },
            "change:lockState": function onStateLockChange(model, state) {
                if (this.ui.summary.prop) {
                    if (state === this.model.constants.STATE_LOCK_SENDING) {
                        this.ui.summary.prop("disabled", true);
                    } else {
                        this.ui.summary.prop("disabled", false);
                    }
                }
            }
        },
        initialize: function initialize(options) {
            this.cssClass = options.cssClass || "";
            this.listenTo(this.issueTypeSelector, "show", function () {
                this.listenTo(this.issueTypeSelector.currentView, "issueTypeSelected", function () {
                    this.focusSummary();
                });
            });

            _.bindAll(this, 'adjustSummarySize', "onBodyClick");
        },
        onClose: function onClose() {
            $(document).off("click.iic", this.onBodyClick);
        },
        onBodyClick: function onBodyClick(e) {
            // check if target is not the clicked element and hasn't it inside
            if (!this.$el.is(e.target) && this.$el.has(e.target).length === 0) {
                if (this.ui.summary.val() === "") {
                    this.trigger("deactivate", {
                        reason: "cancel"
                    });
                } else if (this.ui.summary.is(":focus")) {
                    // When clicking on issue in agile, even though cursor isn't in the textarea anymore,
                    // blur event isn't fired properly and technically textarea is still focused.
                    // This is why we have to blur it manually.
                    this.ui.summary.blur();
                }
            }
        },
        serializeData: function serializeData() {
            return {
                summary: this.model.getSummary(),
                cssClass: this.cssClass
            };
        },
        onRender: function onRender() {
            this.unwrapTemplate();
            this.ui.withTitle.tooltip({aria: true});

            var that = this;
            this.ui.summary.on('change cut paste drop keydown input',  function deferedAdjustSummarySize() {
                _.defer(that.adjustSummarySize);
            });

            // JAG renders sprint content detached from the DOM so we need to defer this until after it is attached
            _.defer(that.adjustSummarySize);

            this.ui.summary.placeholder();
            if (this.model.getState() === this.model.constants.STATE_ACTIVE) {
                this.activate();
            } else {
                this.deactivate();
            }
        },
        adjustSummarySize: function adjustSummarySize() {
            this.ui.summary.css('height', 'auto');
            var outerHeight = this.ui.summary.outerHeight();
            var scrollHeight = Math.max(outerHeight + this.ui.summary.prop('scrollHeight') - this.ui.summary.prop('clientHeight'), outerHeight);
            if (scrollHeight) {
                this.ui.summary.height(scrollHeight+'px');
            }
        },
        reset: function reset() {
            this.ui.summary.attr("style", "");
        },
        hide: function hide() {
            this.$el.addClass("iic-widget_hidden");
            $(document).off("click.iic", this.onBodyClick);
        },
        show: function show() {
            this.$el.removeClass("iic-widget_hidden");
            this.adjustSummarySize();

            // Add event handler to check if we can close the widget when users clicks outside of it.
            // We need to defer this because event bubbling would cause this to be immediately
            // executed when user clicks on the trigger to show the widget
            var instance = this;
            _.defer(function() {
                $(document).off("click.iic", instance.onBodyClick);
                $(document).on("click.iic", instance.onBodyClick);
            });
        },
        focusSummary: function focusSummary() {
            this.ui.summary.focus();
        },
        activate: function activate() {
            this.show();
            this.trigger("activated");
        },
        focus: function focus() {
            this.focusSummary();
            this.trigger("focused");
        },
        deactivate: function deactivate() {
            this.hide();
            this.trigger("deactivated");
        },
        onSummaryChange: function onSummaryChange(e) {
            this.trigger("summaryChanged", this.ui.summary.val());
        }
    });

    return WidgetView;
});;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget.js' */
define('jira/inline-issue-create/widget', [
    'jquery',
    'underscore',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/util',
    'jira/inline-issue-create/entities/widget',
    'jira/inline-issue-create/entities/issue-types',
    'jira/inline-issue-create/entities/projects',
    'jira/inline-issue-create/entities/inline-issue',
    'jira/inline-issue-create/views/widget',
    'jira/inline-issue-create/views/issue-type-dropdown',
    'jira/inline-issue-create/views/description',
    'jira/inline-issue-create/prefillable-create-issue-dialog',
    'jira/inline-issue-create/analytics'
], function (
    $,
    _,
    Marionette,
    Util,
    WidgetModel,
    IssueTypeCollection,
    ProjectsCollection,
    InlineIssue,
    WidgetLayout,
    IssueTypeDropdownView,
    DescriptionView,
    PrefillableCreateIssueDialog,
    Analytics
) {
    "use strict";

    /**
     * This function takes options hash and creates a options.fieldName field in options.context object.
     * If options.parameter is a function it is used as a constructor, if it is an object it is taken as-is.
     * If it is empty, the new object is created using default constructor.
     * @param options {parameter, context, fieldName, defaultOptions, defaultConstructor}
     */
    function createFieldFromParam(options) {
        if (_.isFunction(options.parameter)) {
            options.context[options.fieldName] = new options.parameter(options.defaultOptions);
        } else if (_.isObject(options.parameter)) {
            options.context[options.fieldName] = options.parameter;
        } else if (undefined === options.parameter) {
            options.context[options.fieldName] = new options.defaultConstructor(options.defaultOptions);
        }
    }

    var IicWidget = Marionette.Controller.extend({
        initialize: function initialize(options) {
            this._initializeComponents(options);

            if (options.jqls) {
                this.setCurrentJQLs(options.jqls);
            }
            if (options.container) {
                this.attach(options.container);
            }
            this._initializeEvents(options);
        },

        _initializeComponents: function _initializeComponents(options) {
            // createFieldFromParam wasn't used here as the constructor for collection takes 2 parameters
            if (_.isFunction(options.issueTypes)) {
                this.issueTypes = new options.issueTypes(undefined, {
                    jqls: options.jqls
                });
            } else if (_.isObject(options.issueTypes)) {
                this.issueTypes = options.issueTypes;
            } else {
                this.issueTypes = new IssueTypeCollection(undefined, {
                    jqls: options.jqls
                });
            }

            // createFieldFromParam wasn't used here as the constructor for collection takes 2 parameters
            if (_.isFunction(options.projects)) {
                this.projects = new options.projects(undefined, {
                    jqls: options.jqls
                });
            } else if (_.isObject(options.projects)) {
                this.projects = options.projects;
            } else {
                this.projects = new ProjectsCollection(undefined, {
                    jqls: options.jqls
                });
            }

            createFieldFromParam({
                context: this,
                fieldName: "model",
                defaultOptions: {
                    issueTypes: this.issueTypes
                },
                parameter: options.model,
                defaultConstructor: WidgetModel
            });

            createFieldFromParam({
                context: this,
                fieldName: "dropdownView",
                defaultOptions: {
                    model: this.model,
                    collection: this.issueTypes,
                    widgetId: this.model.cid
                },
                parameter: options.dropdownView,
                defaultConstructor: IssueTypeDropdownView
            });

            createFieldFromParam({
                context: this,
                fieldName: "descriptionView",
                defaultOptions: {
                    model: this.model,
                    widgetId: this.model.cid
                },
                parameter: options.descriptionView,
                defaultConstructor: DescriptionView
            });

            this.view = new WidgetLayout({
                model: this.model,
                cssClass: options.cssClass
            });
            this.analytics = new Analytics({widget: this});
            this._currentInlineIssue = undefined;
        },
        _initializeEvents: function _initializeEvents(options) {
            this.listenTo(this.view, "summaryChanged", function onSummaryChanged(newSummary) {
                this.model.setSummary(newSummary);
            });
            this.listenTo(this.view, "createIssue", this.createIssue);
            this.listenTo(this.view, "deactivate", this.deactivate);
            this.listenTo(this.view, "openFullIssueDialog", function onOpenFullIssueDialog() {
                this.trigger("openCreateIssueDialog", {reason: "manual"});
                this.openCreateIssueDialog();
            });
            this.listenTo(this.model, 'change:state', this.onStateChange);
            this.listenTo(this.model, 'change:lockState', this.onLockStateChange);
            this.listenTo(this.issueTypes, 'reset', this.checkWidgetLocked);
            this.listenTo(this.projects, 'reset', this.checkWidgetLocked);

            this.on("issueCreated", function resetSummaryOnIssueCreated() {
                this.model.setSummary("");
            });
            //kick off the world
            this.checkWidgetLocked();
        },
        render: function render() {
            //detaching regions as render would destroy all of them
            //we want to re-attach just after we'll rerender the view
            this.view.issueTypeSelector.attachView(undefined);
            this.view.description.attachView(undefined);
            this.view.render();

            this.view.issueTypeSelector.show(this.dropdownView);
            this.view.description.show(this.descriptionView);
            this.listenTo(this.dropdownView, "issueTypeSelected", function (selectedIssueTypeModel) {
                this.model.setSelectedIssueType(selectedIssueTypeModel);
            });
        },
        onStateChange: function (model, state) {
            if (state === this.model.constants.STATE_ACTIVE) {
                this.trigger('activated');
            } else if (state === this.model.constants.STATE_CLOSED) {
                this.trigger('deactivated');
            }
        },
        onLockStateChange: function onLockStateChange(model, lockState) {
            if (lockState === this.model.constants.STATE_LOCK_PERM_INACTIVE) {
                if (this.model.getState() === this.model.constants.STATE_ACTIVE) {
                    this.deactivate();
                }
            }
        },
        activate: function activate() {
            if (this.model.getLockState() !== this.model.constants.STATE_LOCK_PERM_INACTIVE) {
                this.model.changeState(this.model.constants.STATE_ACTIVE);
                return true;
            } else {
                return false;
            }
        },
        deactivate: function deactivate() {
            this.model.changeState(this.model.constants.STATE_CLOSED);
        },
        checkWidgetLocked: function checkWidgetLocked() {
            //are collections loading?
            if (this.issueTypes.isFetching() || !this.issueTypes.isInitialized()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_TEMP_INACTIVE);
            }
            if (this.projects.isFetching() || !this.projects.isInitialized()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_TEMP_INACTIVE);
            }
            //or maybe we are actually saving new issue
            if (this._currentInlineIssue && this._currentInlineIssue.isSaving()) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_SENDING);
            }
            //are collections empty?
            if (!this.issueTypes.length) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_PERM_INACTIVE);
            }
            if (this.projects.length !== 1) {
                return this.model.setLockState(this.model.constants.STATE_LOCK_PERM_INACTIVE);
            }
            //okay! we are good!
            this.model.setLockState(this.model.constants.STATE_LOCK_UNLOCKED);
        },
        focus: function focus() {
            this.view.focus();
        },
        reset: function reset() {
            this.model.setSummary("");
            this.view.reset();
        },
        attach: function attach(container) {
            var $widgetContainer = $(container);
            $widgetContainer.append(this.view.el);
        },
        setCurrentJQLs: function setCurrentJQLs(jqls) {
            this.jqls = jqls;
        },
        setSummary: function setSummary(newSummary) {
            this.model.setSummary(newSummary);
        },
        getSummary: function getSummary() {
            return this.model.getSummary();
        },
        setSelectedIssueTypeIfAvailable: function setSelectedIssueTypeIfAvailable(newIssueType) {
            this.model.setSelectedIssueTypeIfAvailable(newIssueType);
        },
        getSelectedIssueType: function getSelectedIssueType() {
            return this.model.getSelectedIssueType();
        },
        setOverrides: function setOverrides(overrides) {
            this.overrides = overrides;
        },
        createIssue: function createIssue() {
            var instance = this;
            //we need to _.clone objects allowing beforeIssueCreated to modify those data
            var data = {
                summary: this.model.getSummary(),
                contexts: this.jqls,
                issueTypeId: this.model.getSelectedIssueType().getId(),
                overrides: _.clone(this.overrides)
            };
            this.trigger("beforeIssueCreated", instance, data);

            //persist new issue
            this._currentInlineIssue = new InlineIssue(data);
            this._currentInlineIssue.save().done(function successInlineCreate(data) {
                instance.trigger("issueCreated", data.issue, data.prefilledFields, instance, {
                    source: "inline"
                });
                JIRA.trace("inline.create.issue.created");
            }).fail(function failureInlineCreate(response) {
                var dialogDataDeferred = new jQuery.Deferred();
                instance.openCreateIssueDialog(dialogDataDeferred);
                try {
                    var data = JSON.parse(response.responseText);
                    dialogDataDeferred.resolve({
                        errors: data.errors,
                        errorMessages: data.generalErrors,
                        prefilledFields: data.prefilledFields
                    });
                } catch (err) {
                    Util.error(instance, "Could not parse response: " + err, response);
                    var errorMessage = "Unfortunately, there is an internal communication error, so you must use the full dialog to create the issue. Please contact your administrator if this error keeps appearing.";
                    dialogDataDeferred.resolve({
                        errors: {},
                        errorMessages: [errorMessage],
                        prefilledFields: {}
                    });
                }


                instance.trigger("openCreateIssueDialog", {reason: "createFailed"});
            }).always(function checkStateAfterSending() {
                instance.checkWidgetLocked();
            });
            this.checkWidgetLocked();
        },
        openCreateIssueDialog: function openCreateIssueDialog(dialogDataDeferred) {
            var instance = this;
            var issueData = this.model.toIssueData();
            if (this.projects.size() === 1) {
                issueData.project = this.projects.at(0).toJSON();
            }
            var context = {
                summary: issueData.summary,
                contexts: this.jqls,
                issueTypeId: this.model.getSelectedIssueType() ? this.model.getSelectedIssueType() .getId() : undefined,
                overrides: _.clone(this.overrides)
            };
            this.trigger("beforeIssueCreated", instance, context);

            if (!dialogDataDeferred) {
                dialogDataDeferred = this._resolveInlineContext(context, instance);
            }

            var promiseForm = PrefillableCreateIssueDialog.createPrefillableCreateIssueForm(dialogDataDeferred.promise(), true);
            return promiseForm.pipe(function (form) {
                var dialog = form.asDialog();
                function triggerIssueCreated(e, issue) {
                    instance.trigger("issueCreated", issue, issue.fields, instance, {
                        source: "dialog"
                    });
                    JIRA.trace("inline.create.issue.created");
                }
                form.bind("initialized", function () {
                    this.unconfigurableForm.bind("issueCreated", triggerIssueCreated);
                    this.configurableForm.bind("issueCreated", triggerIssueCreated);
                });

                dialog.show();
                return dialog;
            });
        },
        _resolveInlineContext: function(context, instance) {
            var fieldValuesRetrieved = new jQuery.Deferred();
            var fieldValuesResolver = $.ajax(AJS.contextPath() + "/rest/inline-create/1.0/context/resolve", {
                data: JSON.stringify(context),
                contentType: 'application/json',
                type: 'POST'
            });
            fieldValuesResolver.done(function whenInitializedAndHasFields(data) {
                fieldValuesRetrieved.resolve({
                    prefilledFields: data.createIssueInput
                });
            }).fail(function whenFailedInitializingFields() {
                // very basic error recovery
                fieldValuesRetrieved.resolve({
                    prefilledFields: {
                        summary: context.summary ? context.summary : "",
                        issuetype: instance.model.getSelectedIssueType() ?
                            instance.model.getSelectedIssueType().getId() : undefined
                    }
                });
            });
            return fieldValuesRetrieved;
        }
    });

    return IicWidget;
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-analytics.js' */
define('jira/inline-issue-create/analytics', [
    'jira/inline-issue-create/lib/marionette'
], function (
    Marionette
    ) {
    "use strict";

    return Marionette.Controller.extend({
        initialize: function initialize(options) {
            this.loadTimestamp = new Date().getTime();
            var widget = options.widget;
            this.widgetId = widget.model.cid.substring(1);

            this.listenTo(widget, "issueCreated", this.onIssueCreated);
            this.listenTo(widget, "openCreateIssueDialog", this.onOpenCreateIssueDialog);
            this.listenTo(widget, "activated", this.onActivated);
            this.listenTo(widget, "deactivated", this.onDeactivated);

        },
        triggerAnalytics: function triggerAnalytics(name, params) {
            var args = _.defaults({}, params, {
                instance: this.widgetId,
                timestarted: this.loadTimestamp
            });
            AJS.trigger("analyticsEvent", { name: "jira.inlinecreate." + name, data: args });
        },
        onOpenCreateIssueDialog: function onOpenCreateIssueDialog(args) {
            this.triggerAnalytics("openDialog", {
                reason: args.reason
            });
        },
        onIssueCreated: function onIssueCreated(issue, prefilledFields, widget, args) {
            if (args.source === "inline") {
                this.triggerAnalytics("issueCreatedInline");
            } else {
                this.triggerAnalytics("issueCreatedDialog");
            }
        },
        onDeactivated: function onDeactivated() {
            this.triggerAnalytics("deactivated");
        },
        onActivated: function onActivated() {
            this.triggerAnalytics("activated");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.plugins.inline-create.jira-inline-issue-create-plugin:component-widget', location = '/inline-issue-create/components/inline-issue-create-widget/inline-issue-create-widget-group.js' */
define('jira/inline-issue-create/widget-group', [
    'jquery',
    'jira/inline-issue-create/lib/marionette',
    'jira/inline-issue-create/widget',
    'jira/inline-issue-create/entities/inline-bootstrap'
], function WidgetGroup(
    $,
    Marionette,
    IicWidget,
    InlineBootstrap
) {
    "use strict";

    var WidgetGroup = Marionette.Controller.extend({
        initialize: function initialize(options) {
            this.TriggerView = options.TriggerView;
            this.Widget = IicWidget;
            this.widgets = {};
            this.currentJQLs = undefined;
            this.createdCallback = options.createdCallback;
            this.activeWidget = undefined;
            this.inlineBootstrap = options.inlineBootstrap || new InlineBootstrap();
            this.widgetOptions = _.defaults(options.widgetOptions || {}, {
                issueTypes: this.inlineBootstrap.issueTypes,
                projects: this.inlineBootstrap.projects
            });
        },
        getWidget: function getWidget(id) {
            if (!this.widgets[id]) {
                this.widgets[id] = this._createNewWidget(id);
            }
            return this.widgets[id];
        },
        setCurrentJqls: function setCurrentJqls(jqls) {
            this.currentJQLs = jqls;
            _.each(this.widgets, function setWidgetJqls(w) {
                w.widget.setCurrentJQLs(jqls);
            });
            this.inlineBootstrap.setJQLs(jqls);
        },
        activateWidget: function activateWidget(widget) {
            if (this.activeWidget === widget) {
                widget.focus();
                return;
            }
            var previouslyActiveWidget = this.activeWidget;
            this.activeWidget = undefined;
            _.each(this.widgets, function deactivateWidget(w) {
                if (w !== widget) {
                    w.widget.deactivate();
                }
            });

            var isActivated = widget.activate();
            if (isActivated) {
                widget.focus();
                this.activeWidget = widget;
                this.trigger("widget:activated", widget, previouslyActiveWidget);

                if (previouslyActiveWidget) {
                    widget.setSummary(previouslyActiveWidget.getSummary());
                    widget.setSelectedIssueTypeIfAvailable(previouslyActiveWidget.getSelectedIssueType());
                    previouslyActiveWidget.reset();
                }
            }

            return isActivated;
        },
        _createNewWidget: function _createNewWidget(id) {
            var manager = this;

            var widget = new this.Widget(this.widgetOptions);
            widget.on("deactivated", function onWidgetDeactivated() {
                if (manager.activeWidget === widget) {
                    manager.activeWidget = undefined;
                    widget.reset();
                }
            });

            if (this.createdCallback) {
                this.createdCallback(widget, id);
            }

            if (this.currentJQLs) {
                widget.setCurrentJQLs(this.currentJQLs);
            }

            var trigger = new manager.TriggerView({
                widget: widget
            });

            trigger.on("selected", function () {
                manager.activateWidget(widget);
            });

            return {
                widget: widget,
                trigger: trigger,
                render: function render($element) {
                    trigger.render();
                    $element.append(trigger.$el);
                    widget.attach(trigger.$el);
                    widget.render();
                    manager.trigger("widget:rendered", widget, trigger, $element);
                }
            };
        }
    });

    return WidgetGroup;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:inline-issue-create', location = 'inline-issue-create/InlineIssueCreate.js' */
define("jira/components/inline-issue-create", [
    "jira/components/libs/marionette-2.1.0",
    "jira/inline-issue-create/widget",
    "jira/inline-issue-create/views/default-trigger",
    "jira/inline-issue-create/entities/inline-bootstrap",
    "underscore"
], function(
    Marionette,
    Widget,
    Trigger,
    Bootstrap,
    _
) {
    "use strict";

    return Marionette.Object.extend({
        _buildBootstrap: function(){
            this.bootstrap = new Bootstrap();
            this.listenTo(this.bootstrap, {
                "sync": function() {
                    this.widget.setCurrentJQLs(this.bootstrap.jqls);
                }
            });
        },

        _buildWidget: function() {
            this.widget = new Widget({
                issueTypes: this.bootstrap.issueTypes,
                projects: this.bootstrap.projects
            });
            this.listenTo(this.widget, {
                "issueCreated": function(issue, fields){
                    this.trigger("issueCreated", {
                        issue: issue,
                        fields: fields
                    });
                },
                "activated": function(){
                    this.trigger("activated");
                },
                "deactivated": function(){
                    this.trigger("deactivated");
                }
            });
        },

        _buildTrigger: function() {
            this.widgetTrigger = new Trigger({
                widget: this.widget
            });
            this.listenTo(this.widgetTrigger, {
                "selected": function () {
                    this.activate();
                    this.trigger("inlineIssueCreateOpened");
                }
            });
        },

        initialize: function() {
            this._buildBootstrap();
            this._buildWidget();
            this._buildTrigger();
            this.render();
        },

        setJQL: function(jql) {
            this.bootstrap.setJQLs([jql]);
        },

        render: function() {
            this.widgetTrigger.render();
            this.widget.render();
        },

        show: function(el) {
            this.render();
            el.append(this.widgetTrigger.$el);
            this.widget.attach(el);
        },

        activate: function() {
            if (this.bootstrap.projects.length) {
                var isActivated = this.widget.activate();
                if (isActivated) {
                    this.widget.focus();
                }
            } else {
                this.widget.openCreateIssueDialog();
            }
        },

        activateWithJQL: function(jql) {
            this.bootstrap.jqls = [jql];
            this.bootstrap.fetch({reset: true}).done(_.bind(function() {
                if (this.bootstrap.projects.length) {
                    var isActivated = this.widget.activate();
                    if (isActivated) {
                        this.widget.focus();
                    }
                }
            }, this));
        }
    });

});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/SimpleIssueList.js' */
define("jira/components/simpleissuelist", [
    "jira/components/simpleissuelist/controllers/list",
    "jira/components/simpleissuelist/services/api",
    "jira/components/simpleissuelist/services/inline-issue-create",
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/underscore",
    "jquery"
], function(
    ControllerList,
    ServiceAPI,
    InlineIssueCreate,
    Marionette,
    _,
    jQuery
) {
    "use strict";

    return Marionette.Object.extend({
        initialize: function() {
            if (this.options.displayInlineIssueCreate) {
                this.inlineIssueCreate = new InlineIssueCreate();
                this.listenTo(this.inlineIssueCreate, {
                    "issueCreated": function(issueInfo) {
                        this.trigger("issueCreated", issueInfo);
                    },
                    "activated deactivated": function() {
                        // We need to defer this because the Inline Issue Create component
                        // trigger those events *before* it is actually activated or deactivated
                        _.defer(_.bind(function() {
                            this.list.adjustSize();
                        }, this));
                    }
                });
            }
            
            this.list = new ControllerList({
                baseURL: this.options.baseURL,
                inlineIssueCreate: this.inlineIssueCreate
            });
            this.listenTo(this.list, {
                "goToPreviousPage": function() {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage("prev");
                },
                "goToNextPage": function() {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage("next");
                },
                "goToPage": function(page) {
                    this.trigger("list:pagination");
                    this.searchResults.jumpToPage(page);
                },
                "refresh": function() {
                    this.trigger('refresh');
                },
                "selectIssue": function(event) {
                    this.trigger("list:select", {
                        id: event.id,
                        key: event.key,
                        absolutePosition: this.searchResults.getPositionOfIssueInSearchResults(event.id),
                        relativePosition: this.searchResults.getPositionOfIssueInPage(event.id)
                    });
                    this.searchResults.select(event.id);
                },
                "sort": function(jql) {
                    this.trigger('sort', jql);
                },
                "update": function() {
                    this.trigger("update");
                }
            });
            ServiceAPI.init(this);
        },

        load: function (searchResults, issueIdOrKey) {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }

            this.searchResults = searchResults;
            if (this.options.displayInlineIssueCreate) {
                this.inlineIssueCreate.setJQL(this.searchResults.jql);
            }

            this.listenTo(this.searchResults, {
                "before:loadpage": function() {
                    this.trigger("before:loadpage");
                },
                "error:loadpage": function(errorInfo) {
                    this.trigger("error:loadpage", errorInfo);
                },
                "reset": function () {
                    this.list.update(this.searchResults);
                },
                "unselect": function (unselectedModel) {
                    this.list.unselectIssue(unselectedModel.get("id"));
                },
                "select": function (selectedModel) {
                    var modelId = selectedModel.get("id") || null;
                    if (modelId) {
                        this.list.selectIssue(selectedModel.get("id"));
                    }
                    this.trigger("select", {
                        id: modelId,
                        key: selectedModel.get('key')
                    });
                },
                "change": function (model) {
                    this.list.updateIssue(model);
                }
            });

            if (issueIdOrKey) {
                // If we are looking for a specific key, jump to the page containing that key
                searchResults.jumpToPageForIssue(issueIdOrKey);
            } else {
                // If we are not looking for a specific key, just load the first page
                searchResults.jumpToPage("first");
            }
        },

        show: function(el) {
            this.list.render({
                el: el
            });
        },

        selectNext: function() {
            if (!this.searchResults) return;
            return this.searchResults.selectNext();
        },

        selectPrevious: function() {
            if (!this.searchResults) return;
            return this.searchResults.selectPrev();
        },

        selectIssue: function(issueId) {
            this.searchResults.select(issueId);
        },

        _getIssueById: function(issueId) {
            if (!this.searchResults) return;
            return this.searchResults.get(issueId);
        },

        refreshIssue: function(issueId) {
            var model = this._getIssueById(issueId);
            if (!model) return;

            model.fetch();
        },

        updateIssue: function(issueId, data) {
            var model = this._getIssueById(issueId);
            if (!model) return;
            model.set(data);
        },

        adjustSize: function() {
            this.list.adjustSize();
        },

        disableIssue: function(issueId) {
            var model = this._getIssueById(issueId);
            if (!model) return;

            model.set("inaccessible", true);
        },

        removeIssue: function(issueId){
            var model = this._getIssueById(issueId);
            if (!model) return new jQuery.Deferred().reject().promise();

            return this.searchResults.removeAndUpdateSelectionIfNeeded(model);
        },

        onDestroy: function() {
            this.list.destroy();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/controllers/List.js' */
define("jira/components/simpleissuelist/controllers/list", [
    "jira/components/simpleissuelist/views/pagination",
    "jira/components/simpleissuelist/views/issuelist",
    "jira/components/simpleissuelist/views/endstablesearch",
    "jira/components/simpleissuelist/views/layout",
    "jira/components/simpleissuelist/views/loading",
    "jira/components/simpleissuelist/views/refresh",
    "jira/components/libs/marionette-2.1.0",
    "jira/components/orderby"
], function(
    Pagination,
    IssueList,
    EndStableSearch,
    Layout,
    Loading,
    Refresh,
    Marionette,
    OrderBy
) {
    "use strict";

    return Marionette.ViewManager.extend({
        _buildPagination: function() {
            return this.buildView("pagination", function() {
                var view = new Pagination({
                    baseURL: this.baseURL
                });
                this.listenTo(view, {
                    "prev": function() {
                        this.trigger("goToPreviousPage");
                    },
                    "next": function() {
                        this.trigger("goToNextPage");
                    },
                    "goto": function(page) {
                        this.trigger("goToPage", page);
                    }
                });
                return view;
            });
        },

        _buildList: function() {
            return this.buildView("list", function() {
                var view = new IssueList();
                this.listenTo(view, {
                    "childview:select": function (childview) {
                        var model = childview.model;
                        this.trigger("selectIssue", {
                            id: model.get('id'),
                            key: model.get('key')
                        });
                    },
                    "update": function () {
                        this.trigger("update");
                    }
                });
                return view;
            });
        },

        _buildEndStableSearch: function() {
            return this.buildView("endOfStableSearch", function() {
                return new EndStableSearch();
            });
        },

        _buildRefresh: function(){
            return this.buildView("refresh", function() {
                var refresh = new Refresh();
                this.listenTo(refresh, {
                    "refresh": function () {
                        this.trigger("refresh");
                    }
                });
                return refresh;
            });
        },

        _buildLayout: function() {
            return this.buildView("layout", function() {
                var view = new Layout();
                this.listenTo(view, {
                    "render": function () {
                        // Render the sub-views
                        this.getView("layout").getRegion("pagination").show(this.getView("pagination"));
                        this.getView("layout").getRegion("searchResults").show(this.getView("list"));
                        this.getView("layout").getRegion("refresh").show(this.getView("refresh"));

                        // OrderBy is a special case, as it is not a view but an external component
                        this.getView("layout").getRegion("orderBy")._ensureElement();
                        this.orderBy.setElement(this.getView("layout").getRegion("orderBy").$el);
                        this.orderBy.render();

                        if (this.inlineIssueCreate) {
                            this.getView("layout").inlineIssueCreateContainer._ensureElement();
                            this.inlineIssueCreate.show(this.getView("layout").inlineIssueCreateContainer.$el);
                        }
                    }
                });
                return view;
            });
        },

        _buildOrderBy: function() {
            this.orderBy = OrderBy.create();

            this.orderBy.onSort(function(jql) {
                this.trigger("sort", jql);
            }, this);

            return this.orderBy;
        },

        _buildViews: function () {
            // Build the views
            this._buildLayout();
            this._buildPagination();
            this._buildList();
            this._buildRefresh();
            this._buildEndStableSearch();

            // Render the layout
            this.getView("layout").render();
        },

        initialize: function(options) {
            // As OrderBy is not an internal view, we can create and reuse it when needed.
            this._buildOrderBy();
            this.baseURL = options.baseURL;
            this.inlineIssueCreate = options.inlineIssueCreate;
            this._buildViews();
        },

        render: function(options) {
            options = options || {};
            var el = options.el;    
            el.append(this.getView("layout").$el);
            this.getView("layout").setElement(el);
        },

        onDestroy: function() {
            this.hideView("layout");
        },

        update: function(searchResults) {
            // Display the EndOfStableSearch message if needed
            if (searchResults.isAtTheEndOfStableSearch()) {
                this.getView("layout").getRegion("endOfStableMessageContainer").show(this.getView("endOfStableSearch"));
            } else {
                this.getView("layout").getRegion("endOfStableMessageContainer").empty();
            }

            // Update the views with the search results
            this.getView("list").update(searchResults);
            this.getView("refresh").render();
            this.getView("pagination").update(searchResults);
            this.orderBy.setElement(this.getView("layout").getRegion("orderBy").$el);
            this.orderBy.render();
            this.orderBy.setJql(searchResults.jql);
            
            if (this.inlineIssueCreate) {
                this.inlineIssueCreate.render();
            }

            // Make sure everything fits on the screen
            this.adjustSize();
        },

        hideLoading: function () {
            this.hideView("loading");
        },

        showLoading: function() {
            this.showView("loading", function () {
                var view = new Loading();
                this.listenTo(view, {
                    "render": function () {
                        this.getView("layout").$el.prepend(view.$el);
                    }
                });
                return view;
            });
        },

        updateIssue: function(model) {
            this.getView("list").updateIssue(model);
        },

        unselectIssue: function(issueId) {
            this.getView("list").unselectIssue(issueId);
        },

        selectIssue: function(issueId) {
            this.getView("list").selectIssue(issueId);
        },

        adjustSize: function() {
            if (!this.getView("layout")) return;
            if (!this.getView("list")) return;

            var listPanel = this.getView("layout").ui.listPanel;
            var listContent = this.getView("list").$el;
            var paginationContainer = this.getView("layout").getRegion("pagination").$el;

            var offsetTop = listContent.offset().top + listPanel.scrollTop();
            var paginationHeight = (paginationContainer ? paginationContainer.outerHeight() : 0);
            var windowHeight = window.innerHeight;
            var endOfStableSearchMessageHeight = ( !this.getView("endOfStableSearch") ? 0 : this.getView("endOfStableSearch").$el.outerHeight());
            var inlineIssueCreateHeight = this.getView("layout").inlineIssueCreateContainer.$el.outerHeight() || 0;

            listPanel.css("height", windowHeight - offsetTop - endOfStableSearchMessageHeight - paginationHeight - inlineIssueCreateHeight);

            this.getView("list").scrollSelectedIssueIntoView();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/services/API.js' */
define("jira/components/simpleissuelist/services/api", [

], function(

) {
    "use strict";

    return {
        init: function(simpleIssueList) {
            AJS.namespace("JIRA.API.Issues");

            JIRA.API.Issues.nextIssue = function() {
                simpleIssueList.selectNext();
            };

            JIRA.API.Issues.previousIssue = function() {
                simpleIssueList.selectPrevious();
            };
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/services/InlineIssueCreate.js' */
define("jira/components/simpleissuelist/services/inline-issue-create", [
    "jira/components/inline-issue-create"
], function(
    InlineIssueCreate
) {
    "use strict";

    return InlineIssueCreate;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/endofstablesearch.soy' */
// This file was automatically generated from endofstablesearch.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.endStableSearch = function(opt_data, opt_ignored) {
  return '<div class="end-of-stable-message"><p>' + soy.$$escapeHtml("Too many search results to display. Refine your search criteria and try again.") + '</p></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.endStableSearch.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.endStableSearch';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/issue.soy' */
// This file was automatically generated from issue.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.issue = function(opt_data, opt_ignored) {
  return '<li title="' + soy.$$escapeHtml(opt_data.summary) + '" data-key="' + soy.$$escapeHtml(opt_data.key) + '"><a class="splitview-issue-link" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.key) + '"><span class="issue-link-key"><img height="16" width="16" alt="' + soy.$$escapeHtml(opt_data.typeName) + '" title="' + soy.$$escapeHtml(opt_data.typeName) + ' - ' + soy.$$escapeHtml(opt_data.typeDescription) + '" src="' + soy.$$escapeHtml(opt_data.typeIcon) + '" />&nbsp;' + soy.$$escapeHtml(opt_data.key) + '</span><span class="issue-link-summary">' + soy.$$escapeHtml(opt_data.summary) + '</span></a></li>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.issue.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.issue';
}


JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue = function(opt_data, opt_ignored) {
  return '<li class="inaccessible-issue" data-key="' + soy.$$escapeHtml(opt_data.key) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</li>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.inaccessibleIssue';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/issuelist.soy' */
// This file was automatically generated from issuelist.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.issueList = function(opt_data, opt_ignored) {
  return '<div class="list-content"><ol class="issue-list"></ol></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.issueList.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.issueList';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/layout.soy' */
// This file was automatically generated from layout.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.layout = function(opt_data, opt_ignored) {
  return '<div class="simple-issue-list"><div class="list-panel"><div class="list-ordering"></div><div class="search-results"></div></div><div class="end-of-stable-message-container"></div><div class="inline-issue-create-container"></div><div class="aui-group pagination-view count-pagination"><div class="refresh-container aui-item"></div><div class="pagination-container aui-item"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.layout.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.layout';
}


JIRA.Components.SimpleIssueList.Templates.loading = function(opt_data, opt_ignored) {
  return '<div class="loading"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.loading.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.loading';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/pagination.soy' */
// This file was automatically generated from pagination.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.pagination = function(opt_data, opt_ignored) {
  var output = '<div class="pagination" data-displayable-total="' + soy.$$escapeHtml(opt_data.displayableTotal) + '">';
  var MAX_PAGES_DISPLAYED__soy6 = 5;
  var lastPage__soy7 = Math.floor((opt_data.displayableTotal - 1) / opt_data.pageSize);
  var pageNumber__soy8 = Math.floor(opt_data.startIndex / opt_data.pageSize);
  var urlFragment__soy9 = '' + ((opt_data.hasQueryString) ? soy.$$filterNoAutoescape(opt_data.searchQuery) + '&startIndex=' : soy.$$filterNoAutoescape(opt_data.searchQuery) + '?startIndex=');
  var prevStartIndex__soy19 = opt_data.startIndex - opt_data.pageSize;
  output += ((prevStartIndex__soy19 >= 0) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(prevStartIndex__soy19) + '" data-start-index="' + soy.$$escapeHtml(prevStartIndex__soy19) + '" class="icon icon-previous" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8,lastPage__soy7 + 1)) + '"><span>&lt;&lt; ' + soy.$$escapeHtml("Previous") + '</span></a>' : '') + JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch({startPage: pageNumber__soy8 - Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), endPage: pageNumber__soy8 + Math.floor(MAX_PAGES_DISPLAYED__soy6 / 2), lastPage: lastPage__soy7, urlFragment: urlFragment__soy9, currentPage: pageNumber__soy8 + 1, maxPagesDisplayed: MAX_PAGES_DISPLAYED__soy6, pageSize: opt_data.pageSize, displayableTotal: opt_data.displayableTotal});
  var nextStartIndex__soy41 = Math.min(opt_data.startIndex + opt_data.pageSize, opt_data.displayableTotal);
  output += ((nextStartIndex__soy41 < opt_data.displayableTotal) ? '<a href="' + soy.$$escapeHtml(urlFragment__soy9) + soy.$$escapeHtml(nextStartIndex__soy41) + '" data-start-index="' + soy.$$escapeHtml(nextStartIndex__soy41) + '" class="icon icon-next" title="' + soy.$$escapeHtml(AJS.format("Go to page {0} of {1}",pageNumber__soy8 + 2,lastPage__soy7 + 1)) + '"><span>' + soy.$$escapeHtml("Next") + ' &gt;&gt;</span></a>' : '') + '</div>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.pagination.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.pagination';
}


JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch = function(opt_data, opt_ignored) {
  return '' + ((opt_data.lastPage < opt_data.maxPagesDisplayed) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.lastPage})) : (opt_data.startPage < 0) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: 0, endPage: opt_data.endPage - opt_data.startPage})) : (opt_data.endPage > opt_data.lastPage) ? JIRA.Components.SimpleIssueList.Templates.numberLinks(soy.$$augmentMap(opt_data, {startPage: opt_data.startPage - (opt_data.endPage - opt_data.lastPage), endPage: opt_data.lastPage})) : JIRA.Components.SimpleIssueList.Templates.numberLinks(opt_data));
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.numberLinksLogicBranch';
}


JIRA.Components.SimpleIssueList.Templates.numberLinks = function(opt_data, opt_ignored) {
  var output = '';
  var size__soy76 = opt_data.endPage - opt_data.startPage + 1;
  if (size__soy76 > 1) {
    var iLimit79 = Math.round(size__soy76);
    for (var i79 = 0; i79 < iLimit79; i79++) {
      var pageIndex__soy80 = i79 + opt_data.startPage;
      var pageNumber__soy81 = pageIndex__soy80 + 1;
      var pageStartIndex__soy82 = pageIndex__soy80 * opt_data.pageSize;
      var pageEndIndex__soy83 = Math.min(pageStartIndex__soy82 + opt_data.pageSize, opt_data.displayableTotal);
      var pageBoundaries__soy84 = '' + soy.$$escapeHtml(AJS.format("Issues {0} - {1}",pageStartIndex__soy82 + 1,pageEndIndex__soy83));
      output += ' ' + ((pageNumber__soy81 == opt_data.currentPage) ? '<strong title="' + soy.$$escapeHtml(pageBoundaries__soy84) + '">' + soy.$$escapeHtml(pageNumber__soy81) + '</strong>' : '<a href="' + soy.$$escapeHtml(opt_data.urlFragment) + soy.$$escapeHtml(pageStartIndex__soy82) + '" data-page="' + soy.$$escapeHtml(pageNumber__soy81) + '" data-start-index="' + soy.$$escapeHtml(pageStartIndex__soy82) + '" title="' + soy.$$escapeHtml(pageBoundaries__soy84) + '">' + soy.$$escapeHtml(pageNumber__soy81) + '</a>');
    }
  }
  return output;
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.numberLinks.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.numberLinks';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/refresh.soy' */
// This file was automatically generated from refresh.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.SimpleIssueList.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.SimpleIssueList == 'undefined') { JIRA.Components.SimpleIssueList = {}; }
if (typeof JIRA.Components.SimpleIssueList.Templates == 'undefined') { JIRA.Components.SimpleIssueList.Templates = {}; }


JIRA.Components.SimpleIssueList.Templates.refresh = function(opt_data, opt_ignored) {
  return '<a href="#" class="refresh-table" title="' + soy.$$escapeHtml("Refresh results") + '"><span class="aui-icon aui-icon-small aui-iconfont-refresh-small">' + soy.$$escapeHtml("Refresh results") + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Components.SimpleIssueList.Templates.refresh.soyTemplateName = 'JIRA.Components.SimpleIssueList.Templates.refresh';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/simpleissuelist/templates", function() {
    "use strict";

    return JIRA.Components.SimpleIssueList.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.SimpleIssueList.Templates", null, require("jira/components/simpleissuelist/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/EndStableSearch.js' */
define("jira/components/simpleissuelist/views/endstablesearch", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.endStableSearch
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Issue.js' */
define("jira/components/simpleissuelist/views/issue", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.issue,

        ui: {
            link: 'a'
        },

        events: {
            'simpleClick': function (ev) {
                ev.preventDefault();
                this.trigger('select');
            }
        },

        serializeData: function() {
            var model = this.model;
            return {
                "id": model.get("id"),
                "key": model.get("key"),
                "summary": model.get("summary"),
                "typeName": model.get("type").name,
                "typeDescription": model.get("type").description,
                "typeIcon": model.get("type").iconUrl
            };
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        highlight: function() {
            this.$el.addClass("focused");
            this.ui.link.focus();
            this.scrollIntoView();
        },

        unhighlight: function() {
            this.$el.removeClass("focused");
        },

        scrollIntoView: function() {
            this.$el.scrollIntoViewForAuto();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/InaccessibleIssue.js' */
define("jira/components/simpleissuelist/views/inaccessibleissue", [
    "jira/components/simpleissuelist/views/issue",
    "jira/components/simpleissuelist/templates"
], function(
    Issue,
    Templates
) {
    "use strict";

    return Issue.extend({
        template: Templates.inaccessibleIssue,

        triggers: {
            'click': "select"
        },

        serializeData: function() {
            var model = this.model;
            return {
                "key": model.get("key")
            };
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/IssueList.js' */
define("jira/components/simpleissuelist/views/issuelist", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/views/inaccessibleissue",
    "jira/components/simpleissuelist/views/issue",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    InaccessibleIssue,
    Issue,
    Templates
) {
    "use strict";

    return Marionette.CompositeView.extend({
        template: Templates.issueList,

        childViewContainer: "ol",

        getChildView: function(issue) {
            if (issue.get('inaccessible')) {
                return InaccessibleIssue;
            } else {
                return Issue;
            }
        },

        // Needs to be overwritten with noop because the default implementation
        // is to add some events to the collection when this view is initially
        // rendered, for handling cases like an item added or removed to/from
        // the collection. That case is not going to happen (as we always reset
        // the full collection), so those events are not necessary.
        _initialEvents: function() {},

        onUpdate: function() {
            // If this issue was already selected, highlight it again
            if (this.collection.selected) {
                var childView = this.children.findByModel(this.collection.selected);
                if (childView) {
                    childView.highlight();
                }
            }
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        /**
         * Updates the list with new data.
         *
         * @param {JIRA.Components.Search.Results} collection Data to use
         */
        update: function(collection) {
            this.collection = collection;
            this.render();
            this.triggerMethod("update");
        },

        /**
         * Updates a single issue with new data
         *
         * @param {JIRA.Components.Search.Result} model
         */
        updateIssue: function(model) {
            var view = this.children.findByModel(model);

            // Destroy existing view
            if (!view) return;
            this.removeChildView(view);

            // Create the child view from scratch
            var ChildView = this.getChildView(model);
            var index = this.collection.indexOf(model);
            this.addChild(model, ChildView, index);

            this.triggerMethod("update");
        },

        /**
         * Unselects an issue, if exists
         *
         * @param {Number} issueId Issue to unselect
         */
        unselectIssue: function(issueId){
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var model = this.collection.get(issueId);
            if (!model) return;

            var view = this.children.findByModel(model);
            if (!view) return;

            view.unhighlight();
        },

        /**
         * Selects an issue, if exists
         *
         * @param {Number} issueId Issue to select
         */
        selectIssue: function(issueId){
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var model = this.collection.get(issueId);
            if (!model) return;

            var view = this.children.findByModel(model);
            if (!view) return;

            view.highlight();
        },

        scrollSelectedIssueIntoView: function() {
            // Depending on the network speed, this method could be called before having an actual collection.
            if (!this.collection) return;

            var selected = this.collection.selected;
            if (!selected) return;

            var view = this.children.findByModel(selected);
            if (!view) return;

            view.scrollIntoView();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Layout.js' */
define("jira/components/simpleissuelist/views/layout", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.LayoutView.extend({
        template: Templates.layout,

        regions: {
            pagination: ".pagination-container",
            refresh: ".refresh-container",
            searchResults: ".search-results",
            orderBy: ".list-ordering",
            endOfStableMessageContainer: '.end-of-stable-message-container',
            inlineIssueCreateContainer: '.inline-issue-create-container'
        },

        ui: {
            listPanel: ".list-panel"
        },

        showLoading: function() {
            this.ui.listPanel.addClass("loading");
        },

        hideLoading: function() {
            this.ui.listPanel.removeClass("loading");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Loading.js' */
define("jira/components/simpleissuelist/views/loading", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.loading,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Pagination.js' */
define("jira/components/simpleissuelist/views/pagination", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/uri",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    URI,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.pagination,

        ui: {
            prev: ".icon-previous",
            next: ".icon-next",
            page: "a[data-page]"
        },

        triggers: {
            "click @ui.prev": "prev",
            "click @ui.next": "next"
        },

        onRender: function() {
            this.unwrapTemplate();
        },

        events: {
            "click @ui.page": function(e) {
                var val = e.target.getAttribute("data-page");
                e.preventDefault();
                this.trigger("goto", parseInt(val, 10) - 1);
            }
        },

        update: function(collection) {
            this.collection = collection;
            this.render();
        },

        serializeData: function() {
            if (!this.collection) return; //Because on the very first render, we don't have the collection yet.

            var url = new URI(this.options.baseURL);
            var hasQueryString = url.query().length > 0;

            return {
                startIndex: this.collection.state.pageSize * this.collection.state.currentPage,
                pageSize: this.collection.state.pageSize,
                searchQuery: url.toString(),
                hasQueryString: hasQueryString,
                displayableTotal: this.collection.state.totalRecords
            };
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:simpleissuelist', location = 'simpleissuelist/views/Refresh.js' */
define("jira/components/simpleissuelist/views/refresh", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/simpleissuelist/templates"
], function(
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.refresh,
        triggers: {
            "click": "refresh"
        },

        onRender: function() {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/templates/pager.soy' */
// This file was automatically generated from pager.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.Pager.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.Pager == 'undefined') { JIRA.Components.Pager = {}; }
if (typeof JIRA.Components.Pager.Templates == 'undefined') { JIRA.Components.Pager.Templates = {}; }


JIRA.Components.Pager.Templates.Pager = function(opt_data, opt_ignored) {
  return '<ul class="pager"><li class="previous">' + ((opt_data.previousIssue && opt_data.position != 1) ? '<a data-id="' + soy.$$escapeHtml(opt_data.previousIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" rel="' + soy.$$escapeHtml(opt_data.previousIssue.key) + '" title="' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'"><span class="icon icon-page-prev"><span>' + soy.$$escapeHtml("Previous Issue") + ' \'' + soy.$$escapeHtml(opt_data.previousIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? '<span class="icon icon-page-prev-deactivated" title="' + soy.$$escapeHtml("Not available - this is the first issue") + '"></span>' : '') + '</li><li class="showing">' + ((opt_data.position && opt_data.resultCount) ? soy.$$escapeHtml(AJS.format("{0} of {1}",opt_data.position,opt_data.resultCount)) : '') + '</li><li class="next">' + ((opt_data.nextIssue && opt_data.position != opt_data.resultCount) ? '<a data-id="' + soy.$$escapeHtml(opt_data.nextIssue.id) + '" data-key="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" id="next-issue" rel="' + soy.$$escapeHtml(opt_data.nextIssue.key) + '" title="' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'"><span class="icon icon-page-next"><span>' + soy.$$escapeHtml("Next Issue") + ' \'' + soy.$$escapeHtml(opt_data.nextIssue.key) + '\'</span></span></a>' : (opt_data.position && opt_data.resultCount) ? (opt_data.isAtTheEndOfStableSearch) ? '<span class="icon icon-page-next-deactivated" title="' + soy.$$escapeHtml(AJS.format("Whoa, you\x27\x27ve got quite a few issues there. We can show you the first {0}, but you should refine your search to return fewer issues.",opt_data.stableSearchCount)) + '"></span>' : '<span class="icon icon-page-next-deactivated" title="' + soy.$$escapeHtml("Not available - this is the last issue") + '"></span>' : '') + '</li></ul>';
};
if (goog.DEBUG) {
  JIRA.Components.Pager.Templates.Pager.soyTemplateName = 'JIRA.Components.Pager.Templates.Pager';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/pager/templates", function() {
    "use strict";

    return JIRA.Components.Pager.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.Pager.Templates", null, require("jira/components/pager/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/views/PagerView.js' */
define("jira/components/pager/views/pager", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/pager/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        getTemplate: function() {
            if (this.searchResults && this.searchResults.selected) return Templates.Pager;
            else return false;
        },

        ui: {
            "next": ".next a",
            "previous": ".previous a",
            "nextIcon": ".next span.icon"
        },

        triggers: {
            "simpleClick @ui.next": "next",
            "simpleClick @ui.previous": "previous"
        },

        update: function(searchResults) {
            this.searchResults = searchResults;
            // Backbone usually delegates DOM events when the View is constructed, not when it is rendered.
            // As we have variable templates (i.e. the first time we render the view the template is likely
            // to be undefined), we need to re-delegate the events every time we render.
            this.undelegateEvents();
            this.render();
            this.delegateEvents();
        },

        onRender: function() {
            if(this.searchResults && this.searchResults.selected) {
                var lastIssue = this.searchResults.getIssueAtGlobalIndex(this.searchResults.allIssues.length - 1);

                if (lastIssue.id === this.searchResults.selected.id && this.searchResults.isAtTheEndOfStableSearch()) {
                    this.ui.nextIcon.tooltip({
                        gravity: 'ne'
                    });
                }
            }

            if (AJS.activeShortcuts) {
                if (AJS.activeShortcuts.j) { AJS.activeShortcuts.j._addShortcutTitle(this.$el.find(this.ui.nextIssue));}
                if (AJS.activeShortcuts.k) { AJS.activeShortcuts.k._addShortcutTitle(this.$el.find(this.ui.previousIssue));}
            }
        },

        serializeData: function() {
            var model = this.searchResults;

            var selected = model.selected;
            if (!selected) return;

            var currentIssuePosition = this.searchResults.getPositionOfIssueInSearchResults(this.searchResults.selected.id);
            var templateData = {
                position: currentIssuePosition + 1,
                resultCount: this.searchResults.getTotalIssuesInDb()
            };

            var nextIssue = this.searchResults.getIssueAtGlobalIndex(currentIssuePosition + 1);
            if (nextIssue) {
                templateData.nextIssue = {
                    id: nextIssue.id,
                    key: nextIssue.key
                };
            } else if (this.searchResults.isAtTheEndOfStableSearch()) {
                templateData.isAtTheEndOfStableSearch = true;
                templateData.stableSearchCount = this.searchResults.allIssues.length;
            }

            var previousIssue = this.searchResults.getIssueAtGlobalIndex(currentIssuePosition - 1);
            if (previousIssue) {
                templateData.previousIssue = {
                    id: previousIssue.id,
                    key: previousIssue.key
                };
            }

            return templateData;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:pager', location = 'pager/Pager.js' */
define("jira/components/pager", [
    "jira/components/pager/views/pager",
    "jira/components/libs/marionette-2.1.0"
], function (
    View,
    Marionette
) {
    "use strict";

    return Marionette.ViewManager.extend({
        _buildSearchResults: function(searchResults) {
            this._destroySearchResults();

            this.searchResults = searchResults;
            this.listenTo(this.searchResults, {
                "select reset": function () {
                    this.getView("view").update(this.searchResults);
                }
            });
        },

        _destroySearchResults: function() {
            if (!this.searchResults) return;

            this.stopListening(this.searchResults);
            delete this.searchResults;
        },

        _buildView: function() {
            this.buildView("view", function () {
                var view = new View({
                    el: this.el
                });
                this.listenTo(view, {
                    "next": function() {
                        this.trigger("next");
                    },
                    "previous": function() {
                        this.trigger("previous");
                    }
                });
                return view;
            });
        },

        initialize: function(options) {
            this.el = options.el;

            this._buildView();
        },

        onDestroy: function() {
            Marionette.ViewManager.prototype.onDestroy.call(this);
            this._destroySearchResults();
        },

        load: function(searchResults) {
            this._buildSearchResults(searchResults);
        },

        update: function(searchResults) {
            this.load(searchResults);
            this.getView("view").update(searchResults);
        },

        show: function(el) {
            this.hideView("view");
            this.showView("view", function () {
                var view = new View({
                    el: el
                });
                this.listenTo(view, {
                    "next": function() {
                        this.trigger("next");
                    },
                    "previous": function() {
                        this.trigger("previous");
                    }
                });
                return view;
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'lib/jquery.ui.sidebar.js' */
/*!
 * jQuery UI Sidebar
 * http://jqueryui.com
 *
 * Depends:
 *   jquery.ui.widget.js
 */
;(function($) {


    $.widget( "ui.sidebar",  {
        version: "0.1",

        /* defaults */
        options: {
            minWidth: function (ui) { return 50; },
            maxWidth: function (ui) { return window.innerWidth; },
            resize: $.noop,
            easeOff: 0
        },

        /**
         * @constructor
         */
        _create: function() {
            _.bindAll(this,
                "_handleDrag",
                "_persist",
                "_setContainment",
                "_setHandlePosition",
                "updatePosition");

            if (this.options.easeOff) {
                this.updatePosition = _.debounce(this.updatePosition, this.options.easeOff);
            }
            if (!this.options.id) {
                console.error("ui.sidebar: You must specify an id")
            }
            // Create the handle before restoring anything, as the restore operation could fire some events that
            // might end using the handle before it is created. JRADEV-20661
            this._addHandle();
            this._restore();
            $(window).resize(_.debounce(this.updatePosition, 30));
        },

        /**
         * Restores the sidebar to the user configured width
         * @private
         */
        _restore: function () {
            if (window.localStorage) {
                var width = localStorage.getItem("ui.sidebar." + this.options.id);
                if (width) {
                    this._setWidth(width);
                }
            }
        },

        /**
         * Persists the sidebar to the user configured width so it works across page refreshes.
         * @private
         */
        _persist: function () {
            if (window.localStorage) {
                localStorage.setItem("ui.sidebar." + this.options.id, this.element.outerWidth());
            }
        },

        /**
         * Sets the min & max width boundaries for dragging side bar
         * @private
         */
        _setContainment: function () {
            var windowHeight = window.innerHeight;
            this._elementLeft = this.element.offset().left;
            this._minLeft = this._elementLeft + this.options.minWidth(this);
            this._maxLeft = Math.max(this._minLeft, this._elementLeft + this.options.maxWidth(this));
            this.handle.draggable({containment: [this._minLeft, windowHeight,  this._maxLeft, windowHeight]});
        },

        /**\
         * Sets the width of sidebar
         * @param {Object} e
         * @param {Object} ui
         * @private
         */
        _handleDrag: function (e, ui) {
            var target = ui.position.left - this._elementLeft;
            this._setWidth(target, true);
        },

        _setWidth: function (target, force) {
            if (!force) {
                var maxWidth = this.options.maxWidth(this);
                var minWidth = this.options.minWidth(this);
                if (target > maxWidth) {
                    target = maxWidth
                } else if (target < minWidth) {
                    target = minWidth;
                }
            }
            // JRADEV-20949 Assume box-sizing is border-box, adjusting target width for padding/border.
            // The reason this.element is not box-sizing: border-box is because Safari does not respect this
            // with display: table-cell
            target -= this.element.outerWidth() - this.element.width();
            this.element.width(target);
            this.options.resize(target);
        },


        /**
         * Appends a drag handle next to the sidebar
         * @private
         */
        _addHandle: function () {
            var el = document.createElement("div");
            el.setAttribute("class", "ui-sidebar");
            this.handle = $(el).appendTo(this.element);
            this.handle.draggable({axis: "x", drag: this._handleDrag, stop: this._persist});
            this.handle.mousedown(this._setContainment);
            _.defer(this._setHandlePosition);
        },

        /**
         * Aligns the drag handler to the sidebar
         * @private
         */
        _setHandlePosition: function () {
            this._setContainment();
            if (this._minLeft === this._maxLeft) {
                this.handle.hide();
            } else {
                var elOffset = this.element.offset();
                var left = elOffset.left + this.element.outerWidth();
                this.handle.css({
                    top: elOffset.top,
                    left: left,
                    height: this.element.outerHeight()
                }).show();
            }
        },

        /**
         * Updates position of handle. You trigger this externally by jQuery(".sidebar").sidebar("updatePosition")
         */
        updatePosition: function () {
            this._setHandlePosition();
            this._setWidth(this.handle.offset().left - this._elementLeft);
            this._persist();
        }
    });

})( jQuery );
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/templates/detailslayout.soy' */
// This file was automatically generated from detailslayout.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Components.DetailsLayout.Templates.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Components == 'undefined') { JIRA.Components = {}; }
if (typeof JIRA.Components.DetailsLayout == 'undefined') { JIRA.Components.DetailsLayout = {}; }
if (typeof JIRA.Components.DetailsLayout.Templates == 'undefined') { JIRA.Components.DetailsLayout.Templates = {}; }


JIRA.Components.DetailsLayout.Templates.container = function(opt_data, opt_ignored) {
  return '<div class="details-layout"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.container.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.container';
}


JIRA.Components.DetailsLayout.Templates.layout = function(opt_data, opt_ignored) {
  return '<div class="aui-group split-view"><div class="aui-item list-results-panel"></div><div class="aui-item detail-panel"><div class="issue-container"></div><div class="tools-container"></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.layout.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.layout';
}


JIRA.Components.DetailsLayout.Templates.empty = function(opt_data, opt_ignored) {
  return '<div><div class="navigator-content empty-results"><div class="jira-adbox jira-adbox-medium no-results no-results-message"><h3>' + soy.$$escapeHtml("No issues were found to match your search") + '</h3><p class="no-results-hint">' + soy.$$filterNoAutoescape(AJS.format("Try modifying your search criteria or {0}creating a new issue{1}",'<a class="create-issue" href="' + "/jira" + '/secure/CreateIssue!default.jspa">','</a>')) + '</p></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.empty.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.empty';
}


JIRA.Components.DetailsLayout.Templates.loading = function(opt_data, opt_ignored) {
  return '<div class="loading"></div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.loading.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.loading';
}


JIRA.Components.DetailsLayout.Templates.tools = function(opt_data, opt_ignored) {
  return '<div class="issue-tools"><div class="pager-container"></div>' + ((opt_data.showExpand) ? '<button title="' + soy.$$escapeHtml(AJS.format("Expand issue ( {0} )",opt_data.expandShortcutKey)) + '" class="aui-button aui-button-subtle expand"><span class="aui-icon aui-icon-small aui-iconfont-focus">' + soy.$$escapeHtml(AJS.format("Expand issue ( {0} )",opt_data.expandShortcutKey)) + '</span></button>' : '') + '</div>';
};
if (goog.DEBUG) {
  JIRA.Components.DetailsLayout.Templates.tools.soyTemplateName = 'JIRA.Components.DetailsLayout.Templates.tools';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/templates/amd-wrapper.js' */
/**
 * This file is used to wrap the templates exported in the global namespace
 * by Google Closure Compile with an AMD module. The goal of this AMD module
 * is to hold a reference to the templates, even when they are removed from
 * the global namespace.
 *
 * Please, note that this AMD can be used only in JavaScript land. Soy templates
 * still have to use the global reference. In other words, if someone removes
 * the global reference, it needs to be restored *before* executing a template.
 */
define("jira/components/detailslayout/templates", function() {
    "use strict";

    return JIRA.Components.DetailsLayout.Templates;
});

/**
 * Force an execution of the module factory, in order to capture a reference to
 * the templates in the AMD module. This will allow other AMD modules access the
 * templates even if the global reference is removed.
 */
AJS.namespace("JIRA.Components.DetailsLayout.Templates", null, require("jira/components/detailslayout/templates"));
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/controllers/Tools.js' */
define("jira/components/detailslayout/controllers/tools", ["require"], function(require) {
    "use strict";

    var Marionette = require("jira/components/libs/marionette-2.1.0");
    var Pager = require("jira/components/pager");
    var ToolsView = require("jira/components/detailslayout/views/tools");

    return Marionette.ViewManager.extend({
        initialize: function(options) {
            this.showExpand = options.showExpand;

            this._buildTools();
            this._buildPager();
        },

        show: function (el) {
            this.toolsView.setElement(el);
            this.toolsView.render();
        },

        load: function(searchResults) {
            this.pager.update(searchResults);
        },

        onDestroy: function() {
            this.pager.destroy();
        },

        _buildTools: function() {
            this.toolsView = this.buildView("toolsView", function () {
                var view = new ToolsView({
                    showExpand: this.showExpand
                });
                this.listenTo(view, {
                    render: function() {
                        view.pager._ensureElement();
                        this.pager.show(view.pager.$el);
                    },
                    expand: function() {
                        this.trigger('expand');
                    }
                });
                return view;
            });
        },

        _buildPager: function() {
            this.pager = new Pager();
            this.listenTo(this.pager, {
                "next": function() {
                    this.trigger("pager:next");
                },
                "previous": function() {
                    this.trigger("pager:previous");
                }
            });
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Container.js' */
define("jira/components/detailslayout/views/container", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.container,

        onRender: function () {
            this.unwrapTemplate();
        },

        showView: function(view) {
            this.$el.append(view.$el);
        },

        showLoading: function(loadingView) {
            this.$el.prepend(loadingView.$el);
        },

        hideLoading: function(loadingView) {
            loadingView.$el.detach();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Empty.js' */
define("jira/components/detailslayout/views/empty", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.empty,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Tools.js' */
define("jira/components/detailslayout/views/tools", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates",
    "jira/ajs/keyboardshortcut/keyboard-shortcut"
], function (
    Marionette,
    Templates,
    KeyboardShortcut
) {
    "use strict";

    return Marionette.LayoutView.extend({
        initialize: function(options) {
            this.showExpand = options.showExpand;
        },

        template: Templates.tools,

        regions: {
            pager: ".pager-container"
        },

        ui: {
            expand: ".expand"
        },

        triggers: {
            "click @ui.expand": "expand"
        },

        serializeData: function() {
            return {
                showExpand: this.showExpand || false,
                expandShortcutKey: KeyboardShortcut.getKeyboardShortcutKeys('fullscreen.issue')
            };
        },

        onRender: function() {
            if (this.showExpand) {
                this.ui.expand.tooltip({
                    gravity: 'e'
                });
            }
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Layout.js' */
define("jira/components/detailslayout/views/layout", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/libs/underscore",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    _,
    Templates
) {
    "use strict";

    return Marionette.LayoutView.extend({
        template: Templates.layout,

        regions: {
            issuesList: ".list-results-panel",
            issueEditor: ".issue-container",
            tools: ".tools-container"
        },

        ui: {
            detailPanel: '.detail-panel'
        },

        onRender: function() {
            this.issuesList._ensureElement();
        },

        maximizeDetailPanelHeight: function() {
            var issueContainerTop = this.ui.detailPanel.offset().top;
            this.ui.detailPanel.css("height", window.innerHeight - issueContainerTop);
        },

        showDraggable: function() {
            var oldSize = 0;

            this.issuesList.$el.sidebar({
                id: "layoutview-draggable",
                minWidth: function () {
                    return 250;
                },
                maxWidth: _.bind(function () {
                    return this.$el.width() - 500;
                }, this),
                resize: _.bind(function(newSize) {
                    // This should be handled by the sidebar plugin :(
                    if (newSize !== oldSize) {
                        oldSize = newSize;
                        this.trigger("resize");
                    }
                }, this)
            });
        },

        updateDraggable: function() {
            this.issuesList.$el.sidebar("updatePosition");
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/views/Loading.js' */
define("jira/components/detailslayout/views/loading", [
    "jira/components/libs/marionette-2.1.0",
    "jira/components/detailslayout/templates"
], function (
    Marionette,
    Templates
) {
    "use strict";

    return Marionette.ItemView.extend({
        template: Templates.loading,

        onRender: function () {
            this.unwrapTemplate();
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-components:detailslayout', location = 'detailslayout/DetailsLayout.js' */
define("jira/components/detailslayout", ["require"], function(require) {
    "use strict";

    var _ = require("jira/components/libs/underscore");
    var IssueEditor = require("jira/components/issueeditor");
    var Marionette = require("jira/components/libs/marionette-2.1.0");
    var SimpleIssueList = require("jira/components/simpleissuelist");
    var ViewContainer = require("jira/components/detailslayout/views/container");
    var ViewEmpty = require("jira/components/detailslayout/views/empty");
    var ViewLayout = require("jira/components/detailslayout/views/layout");
    var ViewLoading = require("jira/components/detailslayout/views/loading");
    var Tools = require("jira/components/detailslayout/controllers/tools");

    /**
     * Utility method to create a debounced version of a function. The generated function will have
     * the properties:
     *
     *   - Initial call will happen after <initial> ms
     *   - After the initial call, it will postpone its execution until after <cooldown> milliseconds have elapsed
     *     since the last time it was invoked.
     *   - After the <cooldown> period, the function will be delayed <initial> ms again.
     *
     * Example timelines with values initial=100 and cooldown=500
     *   - Calling the function once:
     *          0ms - Function called
     *        100ms - Function executed
     *
     *   - Calling the function 4 times every 50ms, then again after 1s
     *          0ms - Function called
     *         50ms - Function called
     *        100ms - Function executed (1)
     *        100ms - Function called
     *        150ms - Function called
     *        650ms - Function executed (2)
     *       1000ms - Function called
     *       1100ms - Function executed (3)
     *
     * @param {Function} fn Function to execute
     * @param {number} initial Initial delay in ms.
     * @param {number} cooldown Subsequent delays, in ms.
     * @returns {Function}
     */
    function variableDebounce(fn, initial, cooldown) {
        var timer;
        var currentTimer = initial;

        return function() {
            var args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn.apply(this, args);
                currentTimer = initial;
            }, currentTimer);
            currentTimer = cooldown;
        };
    }

    return Marionette.ViewManager.extend({
        _buildIssueEditor: function () {
            var editor = this.issueEditor = new IssueEditor();
            var options = this.options;


            this._loadIssueInEditor = variableDebounce(_.bind(function(issueData) {
                editor.loadIssue({
                    id: issueData.id,
                    key: issueData.key,
                    detailView: !options.shouldUpdateCurrentProject
                }).always(_.bind(function() {
                    this.hideLoading();
                }, this));
            }, this), 100, 500);

            this.listenTo(editor, {
                "loadError": function (issueData) {
                    this.simpleIssueList.disableIssue(issueData.issueId);
                    this.trigger("editorError");
                },
                "loadComplete": function (issue, options) {
                    this.adjustSize();

                    // The editor model does not provide info about the issue type, we can't
                    // update that value on the list.
                    this.simpleIssueList.updateIssue(issue.id, {
                        key: issue.get('entity').key,
                        summary: issue.get('entity').summary,
                        status: issue.get('entity').status.name
                    });

                    var eventPayload = {
                        issueKey: issue.get('entity').key,
                        issueId: issue.id,
                        issueEditorOptions: options
                    };
                    if (options && options.loadReason === "issues-cache-refresh") {
                        this.trigger("editorLoadedFromCache", eventPayload);
                    } else {
                        this.trigger("editorLoaded", eventPayload);
                    }
                },
                "saveSuccess": function (event) {
                    this.simpleIssueList.refreshIssue(event.issueId);
                    this.trigger("editor:saveSuccess", {
                        event: event.issueId,
                        savedFieldIds: event.savedFieldIds,
                        savedFieldTypes: event.savedFieldTypes,
                        duration: event.duration
                    });
                },
                "editField": function (event) {
                    this.trigger("editor:editField", event);
                },
                "editFieldCancel": function (event) {
                    this.trigger("editor:editFieldCancel", event);
                },
                "linkToIssue": function(event) {
                    this.trigger("linkToIssue", event);
                },
                "refineViewer": function(event) {
                    event.preventDefault();
                    this.updateEditor(event.query);
                },
                "linkInErrorMessage": function(event) {
                    event.preventDefault();
                    this.simpleIssueList.selectIssue(event.issueData.id);
                }
            });
        },

        _buildSimpleIssueList: function () {
            this.simpleIssueList = new SimpleIssueList({
                baseURL: this.baseURL,
                displayInlineIssueCreate: this.options.displayInlineIssueCreate
            });
            this.listenTo(this.simpleIssueList, {
                "select": function (issueData) {
                    this.trigger('select', issueData);
                },
                "update": function () {
                    this.trigger("list:update");
                },
                "refresh": function () {
                    this.trigger("list:refresh");
                },
                "sort": function (jql) {
                    this.trigger("list:sort", jql);
                },
                "list:select": function(event) {
                    this.trigger("list:select", {
                        id: event.id,
                        key: event.key,
                        absolutePosition: event.absolutePosition,
                        relativePosition: event.relativePosition
                    });
                },
                "list:pagination": function() {
                    this.trigger("list:pagination");
                },
                "before:loadpage": function() {
                    this.showLoading();
                },
                "error:loadpage": function(errorInfo) {
                    this.hideLoading();
                    this.trigger("error:loadpage", errorInfo);
                },
                "issueCreated": function(issueInfo) {
                    this.trigger("issueCreated", issueInfo);
                }
            });
        },

        _buildContainerView: function () {
            this.containerView = this.buildView("containerView", function() {
                var view = new ViewContainer();
                this.listenTo(view, {
                    "render": function() {
                        this.getView("layoutView").render();
                        this.getView("emptyView").render();
                        this.getView("loadingView").render();
                        view.$el.prepend(this.getView("layoutView").$el);
                    }
                });
                return view;
            });
        },

        _buildEmptyView: function() {
            this.emptyView = this.buildView("emptyView", function() {
                var view;
                if (typeof this.options.emptyViewFactory === "function") {
                    view = this.options.emptyViewFactory();
                } else {
                    view = new ViewEmpty();
                }

                this.listenTo(view, {
                    "render": function () {
                        this.containerView.$el.append(view.$el);
                        this.adjustSize();
                        this.trigger("empty");
                    }
                });
                return view;
            });
        },

        _showEmptyView: function () {
            this.layoutView.$el.detach();
            this.containerView.$el.empty();
            this.containerView.showView(this.emptyView);
            this.adjustSize();
            this.trigger("empty");
        },

        _buildTools: function() {
            this.tools = new Tools({
                showExpand: this.useExpand
            });
            this.listenTo(this.tools, {
                "expand": function() {
                    this.trigger('expand');
                },
                "pager:next": function() {
                    var data = this.selectNext();
                    this.trigger("pager:next", data);
                },
                "pager:previous": function() {
                    var data = this.selectPrevious();
                    this.trigger("pager:previous", data);
                }
            });
        },

        _buildLayoutView: function() {
            this.layoutView = this.buildView("layoutView", function () {
                var view = new ViewLayout();
                this.listenTo(view, {
                    "render": function () {
                        view.issueEditor._ensureElement();
                        this.issueEditor.setContainer(view.issueEditor.$el);

                        view.issuesList._ensureElement();
                        this.simpleIssueList.show(view.issuesList.$el);

                        view.tools._ensureElement();
                        this.tools.show(view.tools.$el);
                    },
                    "resize": function () {
                        this.adjustSize();
                    }
                });
                return view;
            });
        },

        _buildLoadingView: function() {
            this.loadingView = this.buildView("loadingView", function () {
                return new ViewLoading();
            });
        },

        _buildComponents: function() {
            this._buildIssueEditor();
            this._buildSimpleIssueList();
            this._buildTools();
        },

        _buildViews: function() {
            this._buildLayoutView();
            this._buildEmptyView();
            this._buildLoadingView();
            this._buildContainerView();

            this.containerView.render();
        },

        initialize: function (options) {
            this.baseURL = options.baseURL;
            this.useExpand = options.useExpand || false;

            this._buildComponents();
            this._buildViews();
        },

        _showLoadingView: function () {
            this.containerView.showLoading(this.loadingView);
        },

        _hideLoadingView: function () {
            this.containerView.hideLoading(this.loadingView);
        },

        _showLayoutView: function() {
            this.emptyView.$el.detach();
            this.containerView.showView(this.layoutView);
            this.layoutView.showDraggable();
            this.adjustSize();
        },

        show: function (el) {
            el.replaceWith(this.containerView.$el);
            return this.containerView.$el;
        },

        onDestroy: function() {
            Marionette.ViewManager.prototype.onDestroy.call(this);
            this.issueEditor.close();
            this.simpleIssueList.destroy();
            this.tools.destroy();
            this.hideView("layoutView");
            this.hideView("loadingView");
            this.hideView("emptyView");
            this.hideView("containerView");
        },

        showLoading: function () {
            this._showLoadingView();
        },

        hideLoading: function() {
            this._hideLoadingView();
        },

        load: function (searchResults, issueIdOrKey) {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }
            this.searchResults = searchResults;
            this.listenTo(this.searchResults, {
                "issueDeleted": function () {
                    if (!this.searchResults.length) {
                        this._showEmptyView();
                    }
                },
                "select selectIssueNotInList": function (issueModel) {
                    this.showLoading();
                    this._loadIssueInEditor({
                        id: issueModel.id,
                        key: issueModel.get('key')
                    });
                }
            });

            if (this.searchResults.isEmptySearch()) {
                this._showEmptyView();
            } else {
                this.simpleIssueList.load(this.searchResults, issueIdOrKey);
                this.tools.load(this.searchResults);
                this._showLayoutView();
            }

            this.trigger("list:render");
        },

        adjustSize: function () {
            _.defer(_.bind(function () {
                if (this.getView("layoutView")) {
                    this.simpleIssueList.adjustSize();
                    this.getView("layoutView").maximizeDetailPanelHeight();
                    this.issueEditor.applyResponsiveDesign();
                    this.getView("layoutView").updateDraggable();
                }

                if (this.getView("emptyView")) {
                    var emptyViewContainer = this.getView("emptyView").$el;
                    var issueContainerTop = emptyViewContainer.length && emptyViewContainer.offset().top;
                    emptyViewContainer.css("height", window.innerHeight - issueContainerTop);
                }
            }, this));
        },

        refreshIssue: function (issueId) {
            this.simpleIssueList.refreshIssue(issueId);
            return this.issueEditor.refreshIssue();
        },

        removeIssue: function (issueId) {
            this.showLoading();
            return this.simpleIssueList.removeIssue(issueId)
                .always(_.bind(function () {
                    this.hideLoading();
                }, this))
                .done(_.bind(function (listLength) {
                    if (listLength === 0) {
                        this._showEmptyView();
                    }
                }, this));
        },

        getActiveIssueId: function () {
            return this.issueEditor.getIssueId();
        },

        getActiveIssueKey: function () {
            return this.issueEditor.getIssueKey();
        },

        selectNext: function() {
            return this.simpleIssueList.selectNext();
        },

        selectPrevious: function() {
            return this.simpleIssueList.selectPrevious();
        },

        updateEditor: function(params) {
            this.showLoading();
            this.listenToOnce(this.issueEditor, "loadComplete", function() {
                this.hideLoading();
            });
            this.issueEditor.updateIssueWithQuery(params);
        },

        isLoading: function() {
            return this.issueEditor.isCurrentlyLoading();
        },

        hasSavesInProgress: function() {
            return this.issueEditor.hasSavesInProgress();
        },

        canDismissComment: function() {
            return this.issueEditor.canDismissComment();
        },

        getEditorFields: function() {
            return this.issueEditor.getFields();
        },

        abortPending: function() {
            return this.issueEditor.abortPending();
        },

        beforeHide: function() {
            return this.issueEditor.beforeHide();
        },

        beforeShow: function() {
            return this.issueEditor.beforeShow();
        },

        removeIssueMetadata: function() {
            return this.issueEditor.removeIssueMetadata();
        },

        editField: function(field) {
            return this.issueEditor.editField(field);
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:uri', location = 'libs/uri.js' */
define("jira/components/libs/uri", [
    "atlassian/libs/uri-1.14.1"
], function(
    URI
) {
    "use strict";

    return URI;
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/templates/splitview.soy' */
// This file was automatically generated from splitview.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace JIRA.Templates.SplitView.
 */

if (typeof JIRA == 'undefined') { var JIRA = {}; }
if (typeof JIRA.Templates == 'undefined') { JIRA.Templates = {}; }
if (typeof JIRA.Templates.SplitView == 'undefined') { JIRA.Templates.SplitView = {}; }


JIRA.Templates.SplitView.fullSplitView = function(opt_data, opt_ignored) {
  return '<div class="aui-group split-view"><div class="aui-item list-results-panel"><div class="list-panel"><div class="list-ordering"></div><div class="list-content">' + ((opt_data.issuePanelData) ? JIRA.Templates.SplitView.issueList(opt_data.issuePanelData) : '') + '</div></div><div class="end-of-stable-message-container"></div><div class="aui-group pagination-view count-pagination"><div class="refresh-container aui-item">' + JIRA.Templates.IssueNav.refreshResults(null) + '</div><div class="pagination-container aui-item">' + ((opt_data.pagination) ? JIRA.Templates.IssueNavTable.pagination(opt_data.pagination) : '') + '</div></div></div><div class="aui-item detail-panel navigator-issue-only"><div></div></div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.fullSplitView.soyTemplateName = 'JIRA.Templates.SplitView.fullSplitView';
}


JIRA.Templates.SplitView.issueList = function(opt_data, opt_ignored) {
  var output = '<ol class="issue-list">';
  var iLimit16 = opt_data.issues.length;
  for (var i16 = 0; i16 < iLimit16; i16++) {
    var issue__soy17 = opt_data.issues[i16];
    var issueID__soy18 = opt_data.issueIDs[i16];
    var isHighlighted__soy19 = issueID__soy18 == opt_data.highlightedID;
    output += (issue__soy17) ? '<li ' + ((isHighlighted__soy19) ? 'class="focused"' : '') + ' data-id="' + soy.$$escapeHtml(issueID__soy18) + '" data-key="' + soy.$$escapeHtml(issue__soy17.key) + '" title="' + soy.$$escapeHtml(issue__soy17.summary) + '">' + JIRA.Templates.SplitView.issueRow(issue__soy17) + '</li>' : JIRA.Templates.SplitView.inaccessibleIssueRow({isHighlighted: isHighlighted__soy19, issueID: issueID__soy18});
  }
  output += '</ol>';
  return output;
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueList.soyTemplateName = 'JIRA.Templates.SplitView.issueList';
}


JIRA.Templates.SplitView.issueRow = function(opt_data, opt_ignored) {
  return '<a class="splitview-issue-link" data-issue-key="' + soy.$$escapeHtml(opt_data.key) + '" href="' + soy.$$escapeHtml("/jira") + '/browse/' + soy.$$escapeHtml(opt_data.key) + '">' + ((opt_data.type) ? JIRA.Templates.SplitView.issueIcon(opt_data.type) + '&nbsp;' : '') + '<span class="issue-link-key">' + soy.$$escapeHtml(opt_data.key) + '</span><br/><span class="issue-link-summary">' + soy.$$escapeHtml(opt_data.summary) + '</span></a>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueRow.soyTemplateName = 'JIRA.Templates.SplitView.issueRow';
}


JIRA.Templates.SplitView.issueIcon = function(opt_data, opt_ignored) {
  return '<img height="16" width="16" alt="' + soy.$$escapeHtml(opt_data.name) + '" title="' + soy.$$escapeHtml(opt_data.name) + ' - ' + soy.$$escapeHtml(opt_data.description) + '" src="' + soy.$$escapeHtml(opt_data.iconUrl) + '" />';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueIcon.soyTemplateName = 'JIRA.Templates.SplitView.issueIcon';
}


JIRA.Templates.SplitView.inaccessibleIssueRow = function(opt_data, opt_ignored) {
  return '<li class="inaccessible-issue ' + ((opt_data.isHighlighted) ? 'focused' : '') + '" data-id="' + soy.$$escapeHtml(opt_data.issueID) + '">' + soy.$$escapeHtml("This issue can no longer be opened") + '</li>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.inaccessibleIssueRow.soyTemplateName = 'JIRA.Templates.SplitView.inaccessibleIssueRow';
}


JIRA.Templates.SplitView.issueDetailsNoSelection = function(opt_data, opt_ignored) {
  return '<div></div>';
};
if (goog.DEBUG) {
  JIRA.Templates.SplitView.issueDetailsNoSelection.soyTemplateName = 'JIRA.Templates.SplitView.issueDetailsNoSelection';
}
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Analytics.js' */
define("jira/issues/views/details/analytics", [
], function(
) {
    "use strict";

    return {
        triggerIssueTableRefresh: function() {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.issueTableRefresh", {
                source: "jira.issuenav.global"
            });
        },

        triggerOpenIssueFromTable: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.openIssueFromTable", {
                issueId: data.id,
                absolutePosition: data.absolutePosition + 1,
                relativePosition: data.relativePosition + 1,
                source: "jira.issuenav.global"
            });
        },

        triggerViewIssue: function(data){
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.viewIssue", {
                issueId: data.issueId,
                loadReason: data.loadReason,
                duration: data.duration,
                loadedFromDom: false,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEdit: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit", {
                issueId: data.issueId,
                savedFieldIds: data.savedFieldIds,
                savedFieldTypes: data.savedFieldTypes,
                duration: data.duration,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEditStart: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.start", {
                issueId: data.issueId,
                fieldId: data.fieldId,
                fieldType: data.fieldType,
                source: "jira.issuenav.global"
            });
        },

        triggerInlineEditCancel: function(data) {
            JIRA.Issues.Application.execute("analytics:trigger", "kickass.inlineEdit.cancel", {
                issueId: data.issueId,
                fieldId: data.fieldId,
                fieldType: data.fieldType,
                source: "jira.issuenav.global"
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Traces.js' */
define("jira/issues/views/details/traces", [
], function(
) {
    "use strict";

    return {
        triggerSearchFinished: function() {
            JIRA.trace("jira.search.finished");
        },

        triggerStableUpdate: function() {
            JIRA.trace("jira.search.stable.update");
        }

    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/ApplicationAdapter.js' */
define('jira/issues/views/details/application-adapter', [
], function (
) {
    "use strict";

    var existingHandlers = {
        "reqres": {},
        "commands": {}
    };
    
    function replaceHandlers(type, handlers) {
        for (var handlerName in handlers) {
            var implementation = handlers[handlerName];
            
            if (JIRA.Issues.Application.reqres.hasHandler(handlerName)) {
                existingHandlers[type][handlerName] = JIRA.Issues.Application.reqres.getHandler(handlerName);
            } else {
                existingHandlers[type][handlerName] = null;
            }

            JIRA.Issues.Application.reqres.setHandler(handlerName, implementation);
        }    
    }

    function restoreReqRes(type) {
        for (var handlerName in existingHandlers[type]) {
            var implementation = existingHandlers[type][handlerName];
            
            if (implementation) {
                JIRA.Issues.Application.reqres.setHandler(handlerName, implementation);
            } else {
                JIRA.Issues.Application.reqres.removeHandler(handlerName);
            }
            
            delete existingHandlers[type][handlerName];
        }
    }    
    
    return {
        init: function (detailsLayout) {
            replaceHandlers("reqres", {
                "issueEditor:canDismissComment": function() {
                    return detailsLayout.canDismissComment();
                },
                "issueEditor:getIssueId": function() {
                    return detailsLayout.getActiveIssueId();
                },
                "issueEditor:getIssueKey": function() {
                    return detailsLayout.getActiveIssueKey();
                },
                "issueEditor:refreshIssue": function() {
                    return detailsLayout.refreshIssue();
                },
                "issueEditor:isCurrentlyLoading": function() {
                    return detailsLayout.isLoading();
                },
                "issueEditor:hasSavesInProgress": function() {
                    return detailsLayout.hasSavesInProgress();
                },
                "issueEditor:fields": function() {
                    return detailsLayout.getEditorFields();
                }
            });

            replaceHandlers("commands", {
                "issueEditor:abortPending": function() {
                    return detailsLayout.abortPending();
                },
                "issueEditor:beforeHide": function() {
                    return detailsLayout.beforeHide();
                },
                "issueEditor:beforeShow": function() {
                    return detailsLayout.beforeShow();
                },
                "issueEditor:removeIssueMetadata": function() {
                    return detailsLayout.removeIssueMetadata();
                },
                "issueEditor:updateIssueWithQuery": function() {
                    return detailsLayout.updateEditor();
                },
                "issueEditor:editField": function(field) {
                    return detailsLayout.editField(field);
                }
            });
        },
        
        destroy: function() {
            restoreReqRes("reqres");
            restoreReqRes("commands");
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/services/Metrics.js' */
define('jira/issues/views/details/metrics', [
    'internal/browser-metrics'
], function (
    metrics
) {
    "use strict";

    return {
        viewIssue: function () {
            metrics.start({
                isInitial: true,
                key: "jira.issue.view",
                ready: [
                    {selector: "#key-val", requireUpdate: false},
                    ".issue-body-content"
                ]
            });
        },

        startFromPageLoad: function () {
            metrics.start({
                isInitial: true,
                key: "jira.issue.nav-detail"
            });
        },

        start: function () {
            metrics.start({
                key: "jira.issue.nav-detail"
            });
        },

        end: function () {
            metrics.end({
                key: "jira.issue.nav-detail"
            });
        }
    };
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/views/details/Details.js' */
define("jira/issues/views/details", [
    'jira/components/lib/marionette-2.1.0',
    'jira/components/detailslayout',
    'jira/components/search/results',
    'jira/issues/views/details/metrics',
    "jira/issues/views/details/analytics",
    "jira/issues/views/details/traces",
    "jira/issues/views/details/application-adapter",
    'jira/dropdown/dropdown-factory',
    'jira/components/libs/uri'
], function(
    Marionette,
    DetailsLayout,
    Results,
    metrics,
    analytics,
    traces,
    applicationAdapter,
    DropdownFactory,
    URI
) {
    "use strict";

    return Marionette.Object.extend({
        _buildSearchResults: function(search) {
            this._destroySearchResults();

            var searchResults = search.getResults();
            var keys = searchResults._getIssueIdsToKeys();
            var ids = searchResults.get('issueIds');
            var issues = _.map(ids, function (id) { return {id: id, key: keys[id]}; });

            this.searchResults = new Results([], {
                totalRecordsInDB: searchResults.get('total'),
                pageSize: searchResults.get('pageSize'),
                totalRecordsInSearch: searchResults.get('issueIds').length,
                issues: issues,
                jql: search.getEffectiveJql(),
                allowNoSelection: true
            });
        },

        _destroySearchResults: function() {
            if (this.searchResults) {
                this.stopListening(this.searchResults);
                delete this.searchResults;
            }
        },

        _buildDetailsLayout: function(searchPageModule) {
            var currentQuery = new URI().query();
            var url = new URI(AJS.contextPath() + "/issues/").query(currentQuery).removeQuery("startIndex");
            this.detailsLayout = new DetailsLayout({
                baseURL: url.toString(),
                shouldUpdateCurrentProject: false
            });
            var boundAdjustSize = _.bind(this.detailsLayout.adjustSize, this.detailsLayout);

            this.listenTo(this.detailsLayout, {
                "select": function(issueData) {
                    if (issueData.id) {
                        var shouldReplaceCurrentURLInTheHistory = false;
                        var isThereAnIssueInTheCurrentURL = this.search.getResults().getSelectedIssue().getKey();
                        if (!isThereAnIssueInTheCurrentURL) {
                            shouldReplaceCurrentURLInTheHistory = true;
                        }
                        this.search.getResults().selectIssueById(issueData.id, {replace: shouldReplaceCurrentURLInTheHistory});
                    }
                },
                "list:refresh": function() {
                    metrics.start();
                    analytics.triggerIssueTableRefresh();
                    this.search.refresh();
                },
                "list:sort": function(jql) {
                    this.search.doSort(jql);
                },
                "list:update": function() {
                    traces.triggerSearchFinished();
                    traces.triggerStableUpdate();
                },
                "list:render": function() {
                    this.trigger("render");
                },
                "empty": function() {
                    traces.triggerSearchFinished();
                    this.trigger("render");
                },
                "destroy": function() {
                    JIRA.Issues.offHorizontalResize(boundAdjustSize);
                    JIRA.Issues.offVerticalResize(boundAdjustSize);
                },
                "list:select": function(event) {
                    metrics.start();
                    analytics.triggerOpenIssueFromTable({
                        issueId: event.id,
                        absolutePosition: event.absolutePosition,
                        relativePosition: event.relativePosition
                    });
                },
                "list:pagination": function() {
                    metrics.start();
                },
                "editorLoaded": function(event) {
                    metrics.end();
                    analytics.triggerViewIssue({
                        issueId: event.issueId,
                        loadReason: event.loadReason,
                        duration: event.duration
                    });

                    // Danger, horrible code ahead!!
                    //
                    // The scenario: before, the element '.issue-container' had the scroll for the IssueEditor. Now, the
                    // element with the scroll is it's parent '.detail-panel' (this helps heaps with the position of the
                    // pager).
                    //
                    // The problem(s): design flaws in other components make supporting that scenario near impossible:
                    //  *  Dropdowns in IssueEditor specify that they should get auto-closed when the user scrolls on
                    //    '.issue-container'. That's wrong because it assumes that the scroll will always happen on
                    //    that element. We can't change this without affecting all the users of the IssueEditor.
                    //  * AJS.Dropdown creates an instance for every element marked as 'js-default-dropdown' that handles
                    //    the logic for showing/hidding the dropdown... but does not provide external access to that
                    //    instance. So there is no way to gracefuly close the dropdown, change its properties, etc.
                    //    Changing this will require a change in JIRA core.
                    //
                    // The solution: when the IssueEditor is rendered, serach for all the elements with the scroll
                    // attribute ('data-hide-on-scroll') and change it so it points to '.detail-panel'. Then, rebind
                    // all the dialogs.
                    this.container.find("[data-hide-on-scroll~='.issue-container']").each(function(idx, item) {
                        var $item = AJS.$(item);
                        $item.data("hasDropdown", false);
                        $item.off('click');
                        $item.attr("data-hide-on-scroll", $item.attr("data-hide-on-scroll").replace(".issue-container", ".detail-panel"));
                    });
                    DropdownFactory.bindGenericDropdowns(this.container);
                },
                "editorLoadedFromCache": function() {
                    metrics.end();
                },
                "editor:saveSuccess": function(event) {
                    analytics.triggerInlineEdit({
                        issueId: event.event,
                        savedFieldIds: event.savedFieldIds,
                        savedFieldTypes: event.savedFieldTypes,
                        duration: event.duration
                    });
                },
                "editor:editField": function(event) {
                    analytics.triggerInlineEditStart({
                        issueId: event.issueId,
                        fieldId: event.fieldId,
                        fieldType: event.fieldType
                    });
                },
                "editor:editFieldCancel": function(event) {
                    analytics.triggerInlineEditCancel({
                        issueId: event.issueId,
                        fieldId: event.fieldId,
                        fieldType: event.fieldType
                    });
                },
                "linkToIssue": function(event) {
                    metrics.viewIssue();

                    searchPageModule.reset({
                        selectedIssueKey: event.issueKey
                    });
                }
            });
            
            JIRA.Issues.onHorizontalResize(boundAdjustSize);
            JIRA.Issues.onVerticalResize(boundAdjustSize);
        },

        _destroyDetailsLayout: function() {
            this.detailsLayout.destroy();
            delete this.detailsLayout;
        },

        _buildSearch: function(search) {
            this.search = search;
            this.listenTo(this.search.getResults(), {
                "change:resultsId": this._loadSearch,
                "issueDeleted": function(issueData) {
                    var deletedIssue = this.searchResults.get(issueData.id);
                    this.searchResults.removeAndUpdateSelectionIfNeeded(deletedIssue);
                }
            });

            // These is *not* a regular Backbone event, we can't use listenTo.
            this.search.getResults().onIssueUpdated(this._handleRefreshIssue);

            this.listenTo(this.search.getResults().getSelectedIssue(), {
                "change": function() {
                    var newIssue = this.search.getResults().getSelectedIssue().get('id');
                    if (!newIssue) return;
                    if (!this.searchResults) return;

                    // The selected issue in this.search.getResults() has changed and it isn't
                    // changed in our model: this means it has been changed 'outside' the DetailsLayout
                    // (e.g. push state or API). In this case, we want reload our model to get the
                    // correct page and select the issue.
                    if (this.searchResults.selected && this.searchResults.selected.get('id') !== newIssue) {
                        this.detailsLayout.load(this.searchResults, newIssue);
                    }
                }
            });
        },

        _destroySearch: function(){
            this.search.getResults().setTable(null, {silent: true});
            this.search.getResults().offIssueUpdated(this._handleRefreshIssue);
        },

        _loadSearch: function() {
            var issueKey;

            this._buildSearchResults(this.search);
            if (this.search.getResults().hasSelectedIssue()) {
                issueKey = this.search.getResults().getSelectedIssue().get('key');
            } else if (this.search.getResults().get('startIndex') > 0) {
                issueKey = this.searchResults.getIssueKeyForIndex(this.search.getResults().get('startIndex'));
            } else if (this.search.getResults().hasHighlightedIssue()) {
                issueKey = this.search.getResults().getHighlightedIssue().get('key');
            }

            this.detailsLayout.load(this.searchResults, issueKey);
        },

        _handleRefreshIssue: function(issueId) {
            this.detailsLayout.refreshIssue(issueId);
        },

        initialize: function(options) {
            this._handleRefreshIssue = _.bind(this._handleRefreshIssue, this);

            this._buildDetailsLayout(options.searchPageModule);
            this._buildSearch(options.search);

            // Create a container, we don't want to replace the existing markup
            var container = jQuery("<div></div>");
            options.searchContainer.find(".navigator-content").html('').append(container);
            this.container = this.detailsLayout.show(container);
            jQuery("body").addClass("page-type-split");

            options.fullScreenIssue.hide();

            applicationAdapter.init(this.detailsLayout);
        },

        render: function() {
            // This method is NOT called when the DetailsLayout is loaded initially. It will get called
            // if the uses switches from another layout (i.e. List View) to Details View.

            this._loadSearch();
        },

        close: function() {
            this.destroy();
        },

        onDestroy: function() {
            jQuery("body").removeClass("page-type-split");
            this._destroyDetailsLayout();
            this._destroySearch();
            this._destroySearchResults();
            applicationAdapter.destroy();
        },

        nextIssue: function() {
            this.detailsLayout.selectNext();
        },

        prevIssue: function() {
            this.detailsLayout.selectPrevious();
        },

        isLoading: function() {
            return this.detailsLayout.isLoading();
        },

        isIssueViewActive: function() {
            return false;
        }
    });
});
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/search/FullScreenLayout.js' */
(function(Marionette, SearchService, IssueTable, Application, Messages) {
    "use strict";

    AJS.namespace("JIRA.Issues.FullScreenLayout");

    /**
     * A view containing the entire search/issue app.
     *
     * Handles switching between the search and issue views.
     */
    JIRA.Issues.FullScreenLayout = Marionette.Controller.extend({
        /**
         * Initialise the FullScreenLayout.
         *
         * @param {object} options
         * @param {element} options.searchContainer The element into which the search is to be rendered.
         */
        initialize: function(options) {
            this.searchService = new SearchService({
                searchModule: options.search,
                searchResults: options.search.getResults(),
                columnConfig: options.columnConfig
            });

            this.$navigatorContent = options.searchContainer.find('.navigator-content');
            this.issueTable = new IssueTable({
                searchService: this.searchService,
                el: this.$navigatorContent,
                columnConfig: options.columnConfig
            });
            this.listenTo(this.issueTable, {
                "highlightIssue": function(issueId) {
                    this.searchService.highlightIssue(issueId);
                },
                "render": function() {
                    if (!this.searchService.hasSelectedIssue()) {
                        this.fullScreenIssue.hide();
                    }
                    this.fullScreenIssue.bindSearchService(this.searchService);
                    this.trigger("render");
                }
            });
            this.fullScreenIssue = options.fullScreenIssue;
            this.listenTo(this.fullScreenIssue, {
                "issueHidden": function() {
                    // This is the second highlight. The first one is inside IssueTable component, but due the
                    // internals of FullScreenIssue, when the first one is fired the IssueTable is not in the DOM
                    // so the scrollIntoView() operation will not work. We need to re-highlight the same issue now
                    // that the IssueTable is present in the DOM to force the scroll behaviour
                    this.issueTable.highlightIssue(this.searchService.getHighlightedIssue());
                }
            });

            Application.on("issueEditor:loadError", this.onLoadError, this);
        },

        onLoadError: function(issue) {
            if (!this.fullScreenIssue.isVisible()) {
                this.searchService.unselectIssue();
                Messages.showErrorMsg(
                    AJS.format("{0} can not be opened. The issue may have been deleted or you might not have permission to see the issue.", issue.issueKey),
                    {closeable: true}
                );
            }
        },

        render: function() {
            this.issueTable.show();
        },

        onClose: function() {
            this.fullScreenIssue.deactivate();
            this.issueTable.close();
            this.searchService.close();

            Application.off("issueEditor:loadError", this.onLoadError, this);

            delete this.fullScreenIssue;
            delete this.issueTable;
            delete this.searchService;
        },

        nextIssue: function() {
            this.searchService.selectNextIssue();
        },

        prevIssue: function() {
            this.searchService.selectPreviousIssue();
        },

        returnToSearch: function() {
            this.searchService.unselectIssue();
        },

        handleLeft: function() {
            // No-op
        },

        handleRight: function() {
            // No-op
        },

        isIssueViewActive: function() {
            return this.fullScreenIssue.isVisible();
        },

        isLoading: function() {
            return this.fullScreenIssue.isLoading();
        }
    });
})(JIRA.Marionette, JIRA.Components.SearchService, JIRA.Components.IssueTable, JIRA.Issues.Application, JIRA.Messages);
;
;
/* module-key = 'com.atlassian.jira.jira-issue-nav-plugin:issuenav-common', location = 'content/js/search/EmptyResultsView.js' */
(function() {
    "use strict";

    AJS.namespace("JIRA.Issues.EmptyResultsView");

    JIRA.Issues.EmptyResultsView = JIRA.Issues.BaseView.extend({

        initialize: function(options) {
            this.searchResults = options.searchResults;
        },

        render: function() {
            var message;
            var hint;
            var cssClass;
            var linkType;
            var createIssuePerm = JIRA.Issues.UserParms.get().createIssue;

            if (!JIRA.Issues.LoginUtils.isLoggedIn()) {
                message = "No issues were found to match your search";
                hint = "Try \u003ca\u003elogging in\u003c/a\u003e to see more results";
                cssClass = "not-logged-in-message";
                linkType = 'login';
            } else if (this.searchResults.getJiraHasIssues() === false) {
                message = "No issues have been created (yet)";
                hint = createIssuePerm ? "Be the first to \u003ca\u003ecreate an issue\u003c/a\u003e" : null;
                cssClass = "empty-results-message";
                linkType = 'create';
            } else {
                message = "No issues were found to match your search";
                hint = createIssuePerm ?
                    "Try modifying your search criteria or \u003ca\u003ecreating a new issue\u003c/a\u003e" :
                    "Try modifying your search criteria";
                cssClass = "no-results-message";
                linkType = 'create';
            }

            this.$el.addClass("empty-results");
            this.$el.html(JIRA.Templates.IssueNavTable.noResults({
                message: message,
                hint: hint,
                cssClass: cssClass
            }));

            // Make links within the hint work
            var $links = this.$('.no-results-hint a');
            switch (linkType) {
                case 'create':
                    $links.addClass('create-issue').attr('href', AJS.contextPath() + "/secure/CreateIssue!default.jspa");
                    break;
                case 'login':
                    $links.attr('href', JIRA.Issues.LoginUtils.redirectUrlToCurrent()).addClass('login-link');
                    break;
            }

            _.defer(jQuery.event.trigger, 'updateOffsets.popout');
            _.defer(JIRA.trace, 'jira.search.finished');
        }
    });
}());
;